<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS实验——Lab0串讲</title>
    <link href="/2024/03/06/OS2/"/>
    <url>/2024/03/06/OS2/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统Lab0串讲"><a href="#操作系统Lab0串讲" class="headerlink" title="操作系统Lab0串讲"></a>操作系统Lab0串讲</h1><h2 id="Linux基本操作命令"><a href="#Linux基本操作命令" class="headerlink" title="Linux基本操作命令"></a>Linux基本操作命令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls命令用于列出（list）指定路径下的文件。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span><br>用法<span class="hljs-function">:ls</span> [选项]<span class="hljs-string">...</span> [文件]<span class="hljs-string">...</span><br>选项（常用）：<br>-a 不隐藏任何以. 开始的项目<br>-l 每行只列出一个文件<br></code></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>touch 命令用于创建一个新的文件。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">touch<br>用法:touch [选项]... [文件名]...<br></code></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>mkdir 命令用于创建目录（make directory）。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir<br>用法:mkdir [选项]... 目录...<br></code></pre></td></tr></table></figure><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>mkdir 命令用于创建目录（make directory）。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span><br>用法<span class="hljs-function">:cd</span> [选项]<span class="hljs-string">...</span> 目录<span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>rmdir命令用于 删除空的目录（remove directory）。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir<br>用法:rmdir [选项]... 目录...<br></code></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>rm 命令用于删除（remove）文件，也可以将某个目录及其下属所有文件及其子目录全部删除。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">rm</span><br>用法:<span class="hljs-built_in">rm</span> [选项]... 文件...<br>选项（常用）：<br><span class="hljs-literal">-r</span> 递归删除目录及其内容，如果不加这个命令，删除一个有内容的文件夹会提示不能删。<br><span class="hljs-operator">-f</span> 强制删除。忽略不存在的文件，不提示确认<br></code></pre></td></tr></table></figure><h3 id="cp与mv"><a href="#cp与mv" class="headerlink" title="cp与mv"></a>cp与mv</h3><p>复制（copy）与移动（move）。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span><br>用法:<span class="hljs-keyword">cp</span> [选项]... 源文件... 目录<br>选项（常用）：-r 递归复制目录及其子目录内的所有内容<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span><br>用法:<span class="hljs-built_in">mv</span> [选项]... 源文件... 目录<br></code></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>cat 命令用于拼接（concatenate）文件并输出到标准输出。也可用于查看单个文件内容。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">cat<br>用法:cat [选项]... [文件]...<br></code></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p> head 命令用于输出文件首部内容。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">head<br>用法<span class="hljs-symbol">:he</span>ad [选项]... [文件]...<br>选项（常用）：<br>-<span class="hljs-built_in">n</span> &lt;<span class="hljs-built_in">n</span>&gt; 显示前 &lt;<span class="hljs-built_in">n</span>&gt; 行内容<br>-c &lt;<span class="hljs-built_in">n</span>&gt; 显示前 &lt;<span class="hljs-built_in">n</span>&gt; 个字节内容<br></code></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>touch 命令用于创建一个新的文件。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">tail<br>用法<span class="hljs-symbol">:ta</span>il [选项]... [文件]...<br>选项（常用）：<br>-<span class="hljs-built_in">n</span> &lt;<span class="hljs-built_in">n</span>&gt; 显示末尾 &lt;<span class="hljs-built_in">n</span>&gt; 行内容<br>-c &lt;<span class="hljs-built_in">n</span>&gt; 显示末尾 &lt;<span class="hljs-built_in">n</span>&gt; 个字节内容<br>-f 当文件增长时，输出后续添加的数据（适用于文件不断变化的情况，如日志文件）<br></code></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps 命令用于显示当前进程状态（process status）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">ps</span><br>用法:<span class="hljs-built_in">ps</span> [选项]...<br>选项（常用）：<br><span class="hljs-literal">-e</span> 或 <span class="hljs-literal">-A</span> 显示所有进程<br><span class="hljs-operator">-f</span> 显示全部信息<br></code></pre></td></tr></table></figure><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill 命令用于向进程发送信号（并非仅有杀死进程的功能）。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">kill<br>用法:kill [选项] [pid]...<br>选项（常用）：<br>-s &lt;s&gt; 或 -&lt;s&gt; 指定要发送的信息（<span class="hljs-number">-9</span> 为 <span class="hljs-symbol">SIGKILL</span>）<br></code></pre></td></tr></table></figure><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>sudo 命令用于以超级用户（superuser，或称 root）权限执行命令。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">sudo<br>用法<span class="hljs-symbol">:sudo</span> [命令]<br></code></pre></td></tr></table></figure><h2 id="Vim常用功能"><a href="#Vim常用功能" class="headerlink" title="Vim常用功能"></a>Vim常用功能</h2><h3 id="编辑器的模式"><a href="#编辑器的模式" class="headerlink" title="编辑器的模式"></a>编辑器的模式</h3><p><img src="https://pic.imgdb.cn/item/65e8844a9f345e8d03b934ad.png" alt="编辑器的模式"></p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p><strong>命令模式下</strong>：</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>&lt;n&gt;G或:&lt;n&gt;</td><td>n 为数字。移动到这个文件的第 n 行</td></tr><tr><td>gg</td><td>移动到文件的第一行</td></tr><tr><td>Ctrl+F</td><td>向前（forward）翻页</td></tr><tr><td>Ctrl+B</td><td>向后（backward）翻整页</td></tr></tbody></table><h3 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h3><p><strong>命令模式下</strong>：</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>&#x2F;&lt;word&gt;</td><td>文件下寻找名为 &lt;word&gt;的字符串。</td></tr><tr><td>:%s&#x2F;&lt;word1&gt;&#x2F;&lt;word2&gt;&#x2F;g</td><td>在全文中寻找 &lt;word1&gt;字符串，并将该字符串取代为 &lt;word2&gt;</td></tr></tbody></table><h3 id="剪切、复制、粘贴"><a href="#剪切、复制、粘贴" class="headerlink" title="剪切、复制、粘贴"></a>剪切、复制、粘贴</h3><p><strong>命令模式下</strong>：</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>[n]dd</td><td>删除（delete）游标所在的一行或 n 行，用 p&#x2F;P 可以粘贴（实际更类似于剪切）</td></tr><tr><td>[n]yy</td><td>复制（yank）游标所在的一行或 n 行，用 p&#x2F;P 可以粘贴</td></tr><tr><td>p&#x2F;P</td><td>p 将已复制的数据粘贴（paste）在光标下一行，P 则为粘贴在光标上一行</td></tr><tr><td>u</td><td>复原（undo）前一个动作</td></tr></tbody></table><p><strong>可视模式下</strong>（命令模式输入 操作 v&#x2F;V ），可以通过鼠标或光标批量选择文本段：</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>剪切选择文本</td></tr><tr><td>y</td><td>复制选择文本</td></tr><tr><td>p</td><td>粘贴选择文本</td></tr><tr><td>u</td><td>复原（undo）前一个动作</td></tr></tbody></table><h2 id="GCC编译器的使用"><a href="#GCC编译器的使用" class="headerlink" title="GCC编译器的使用"></a>GCC编译器的使用</h2><p><img src="https://pic.imgdb.cn/item/65e887999f345e8d03c7d916.png" alt="C 语言程序从源代码到可执行文件"></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff">语法:gcc [选项]... [参数]...<br>选项（常用）：<br><span class="hljs-deletion">-o 指定生成的输出文件</span><br><span class="hljs-deletion">-S 将 C 代码转换为汇编代码</span><br><span class="hljs-deletion">-Wall 显示一些警告信息</span><br><span class="hljs-deletion">-c 仅执行编译操作，不进行链接操作，生成可重定位的目标文件</span><br><span class="hljs-deletion">-M 列出依赖</span><br><span class="hljs-deletion">-Ipath 编译时指定头文件目录，使用标准库时不需要指定目</span><br></code></pre></td></tr></table></figure><ul><li>gcc test.c 默认生成名为 a.out 的可执行文件 </li><li>gcc test.c -o test 使用 -o 选项编译链接生成 test 的可执行文件 </li><li>gcc -c test.c -o test.o 使用 -o -c 选项仅编译生成名为 test.o 的目标文件</li></ul><h2 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h2><p>target、dependencies、command 是 Makefile 的基础。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target</span>: dependencies<br>        <span class="hljs-keyword">command</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">command</span> <span class="hljs-number">2</span><br>        ...<br>        <span class="hljs-keyword">command</span> n<br></code></pre></td></tr></table></figure><ul><li>target 是构建 (build) 的目标，可以是目标文件、可执行文件，也可以是一个标签。</li><li>dependencies 是构建该目标所需的其他文件或其他目标。</li><li>command 是构建该目标所需执行的指令。每一个指令 (command) 之前必须按一次制表符键来控制间隔，而不能是空格，否则 make 会报错。</li></ul><p>如果想要构建 target，那么首先要准备好 dependencies，接着执行 command 中的命令，最终完成构建 target。</p><h2 id="Git使用方法"><a href="#Git使用方法" class="headerlink" title="Git使用方法"></a>Git使用方法</h2><p>见“OS假期预习（一）——Linux，Git与Shell脚本”，此处略。</p><h2 id="grep、sed、awk"><a href="#grep、sed、awk" class="headerlink" title="grep、sed、awk"></a>grep、sed、awk</h2><p>sed 是一个文件处理工具，可以将数据行进行替换、删除、新增、选取等特定工作。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sed<br>sed <span class="hljs-selector-attr">[选项]</span> <span class="hljs-string">&#x27;命令&#x27;</span> 输入文本<br>选项（常用）：<br>-n：安静模式，只显示经过sed处理的内容。否则显示输入文本的所有内容。<br>-i：直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。<br>命令（常用）：<br><span class="hljs-selector-attr">[行号]</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[内容]</span>：新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一行之后新增。使用$表示最后一行。后面的命令同理。<br><span class="hljs-selector-attr">[行号]</span>c<span class="hljs-selector-attr">[内容]</span>：取代。用内容取代相应行的文本。<br><span class="hljs-selector-attr">[行号]</span><span class="hljs-selector-tag">i</span><span class="hljs-selector-attr">[内容]</span>：插入。在当前行的上面插入一行文本。<br><span class="hljs-selector-attr">[行号]</span>d：删除当前行的内容。<br><span class="hljs-selector-attr">[行号]</span>p：输出选择的内容。通常与选项-n一起使用。<br>s/re（正则表达式）/string/：将re匹配的内容替换为string。<br></code></pre></td></tr></table></figure><p>awk 是一种处理文本文件的语言，是一个强大的文本分析工具。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">awk</span> &#x27;\$<span class="hljs-number">1</span>&gt;<span class="hljs-number">2</span> &#123;print $<span class="hljs-number">1</span>,$<span class="hljs-number">3</span>&#125;&#x27; my.txt<br></code></pre></td></tr></table></figure><p> 这个命令的格式为  awk ‘pattern action’ file ，pattern 为条件，action 为命令，le 为文件。命令中出现的 $n 代表每一行中用空格分隔后的第 n 项。所以该命令的意义是文件 my.txt 中所有第一项大于 2 的行，输出第一项和第三项。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">awk</span> -F, <span class="hljs-string">&#x27;&#123;print \$2&#125;&#x27;</span> my.txt<br></code></pre></td></tr></table></figure><p>-F选项用来指定用于分隔的字符，默认是空格。所以该命令的 $n 就是用 <code>, </code>分隔的第 n 项了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统理论——引论（1）</title>
    <link href="/2024/03/01/OS1/"/>
    <url>/2024/03/01/OS1/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统理论——引论（1）"><a href="#操作系统理论——引论（1）" class="headerlink" title="操作系统理论——引论（1）"></a>操作系统理论——引论（1）</h1><p>该分类主要将ppt上的内容结合教材与补充资料进行总结<del>复制</del>。</p><blockquote><p>教材：任爱华等，操作系统实用教程（第三版），清华大学出版社， 2010</p><p>参考书：Andrew S. Tanenbaum. 现代操作系统 （第三版），机械工业出版社</p></blockquote><h2 id="从Hello-World开始"><a href="#从Hello-World开始" class="headerlink" title="从Hello World开始"></a>从Hello World开始</h2><p>我们可以先从计算机执行hello world程序开始看起，这个程序的源文件长这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>main() &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算机处理源文件并执行的流程如下：</p><ol><li><p>编译成可执行文件</p></li><li><p>用户告诉shell执行该可执行程序</p><blockquote><p>由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，这样用户就能间接地使用操作系统内核了。在用户和内核之间增加一层<code>“代理”</code>，既能简化用户的操作，又能保障内核的安全，何乐不为呢？用户界面和命令行就是这个另外开发的程序，就是这层<code>“代理”</code>。在Linux下，这个命令行程序叫做 <code>Shell</code>。</p><p><code>Shell</code> 是一个应用程序，它连接了<code>用户</code>和<code>Linux 内核</code>，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 <code>Shell</code> 的本质。<code>Shell</code> 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 <code>QQ</code>、<code>迅雷</code>、<code>Firefox</code> 等其它软件没有什么区别。然而 <code>Shell</code>也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 <code>Shell</code>来使用 Linux，不启动 <code>Shell</code>的话，用户就没办法使用 Linux。</p></blockquote></li><li><p>创建一个新的子进程</p><ul><li>创建进程控制块</li></ul></li><li><p>装入helloworld程序</p><ul><li>操作系统找到该程序，检查其类型</li><li>检查程序首部，找出代码段和数据段的地址</li><li>可执行文件映射到进程结构</li><li>设置CPU上下文环境与程序开始处</li><li>调度helloworld程序</li></ul></li><li><p>执行程序的第一条命令</p><ul><li>执行失败，缺页中断发生</li><li>分配一页内存，并将代码从磁盘读入，继续执行</li><li>更多的缺页中断，读入更多的页面</li></ul></li><li><p>printf</p><ul><li>操作系统检查字符串位置是否正确</li><li>操作系统找到字符串被送往的设备</li><li>设备是一个伪终端，由一个进程控制</li><li>操作系统将字符串送给该进程</li><li>该进程告诉窗口系统他要显示字符串</li><li>窗口系统确定操作合法，将字符串转换为像素</li><li>窗口系统将像素写入存储映像区</li></ul></li><li><p>视频硬件将像素表示转换成一组模拟信号控制显示器（重画屏幕）</p></li><li><p>显示器发射电子束，你在屏幕上看到hello world！</p></li></ol><h3 id="操作系统的工作"><a href="#操作系统的工作" class="headerlink" title="操作系统的工作"></a>操作系统的工作</h3><p>从上面的例子中，大概能了解到操作系统的工作有以下方面：</p><ul><li>程序的执行：负责启动每个程序及结束程序的工作</li><li>完成与硬件有关的工作</li><li>完成与应用无关的工作<ul><li>易于使用，基本服务，统一性</li></ul></li><li>计算机系统的效率与安全问题</li></ul><blockquote><p>假如没有操作系统，该如何操作硬件？</p><p>例子：软盘I&#x2F;O操作</p><ul><li><p>控制芯片NEC PD765有16条命令</p></li><li><p>每一条命令向一个设备寄存器装入长度从1到9字节的特定数据（读写数据、移动磁头臂、格式化磁道，及初始化、检测状态、复位、校准控制器及设备等）</p></li><li><p>以READ为例：13个参数</p></li><li><p>要读取的磁盘块地址、磁道的扇区数、物理介质的记录格式、扇区间隙、对已删除数据地址标识的处理方法</p></li><li><p>操作结束时，控制器芯片在7个字节中返回23个状态及出错字段</p></li><li><p>软盘程序员还要保持注意步进电机的开关状态</p></li></ul></blockquote><p>操作系统在这个例子中，起到了管理硬件、方便使用、提供保护的作用。</p><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务。</p><ul><li>对使用者而言，操作系统提供一个计算机用户与计算机硬件系统之间的接口，使得计算机系统更易于使用；</li><li>对资源管理者而言，操作系统可以有效地控制和管理计算机系统中的各种硬件和软件资源，使之得到更有效的利用；</li><li>合理地组织计算机系统的工作流程，以改善系统性能，如相应时间、系统吞吐量等。</li></ul><h3 id="自顶向下看"><a href="#自顶向下看" class="headerlink" title="自顶向下看"></a>自顶向下看</h3><p>操作系统通过<strong>隐藏硬件</strong>的细节来屏蔽复杂性，呈现给程序良好，清晰，一致，优雅(?)的抽象（创建、实现和管理抽象）。</p><p><img src="https://pic.imgdb.cn/item/65e13df99f345e8d03e4da38.png" alt="操作系统将丑陋的硬件转化成美丽的抽象"></p><h3 id="自底向上看"><a href="#自底向上看" class="headerlink" title="自底向上看"></a>自底向上看</h3><ul><li><p>向上层用户提供服务</p><ul><li>支持多个用户、多个程序</li><li>资源竞争</li></ul></li><li><p>资源的复用（共享）</p><ul><li><p>时间维度</p><p>当一个资源在时间上复用时，不同的程序或用户轮流使用它，第一个程序获取该资源使用结束后，在轮到第二个，第三个。</p><p>例如：只有一个cpu，多个程序需要在该cpu上运行，操作系统先把cpu分给第一个程序，在这个程序运行的足够长的时间（时间长短由操作系统的算法说了算）或者遇到了I&#x2F;O阻塞，操作系统则把cpu分配给下一个程序，以此类推，直到第一个程序重新被分配到了cpu然后再次运行，由于cpu的切换速度很快，给用户的<code>感觉就是这些程序是同时运行的</code>，或者说是并发的，或者说是伪并行的。至于资源如何实现时间复用，或者说谁应该是下一个要运行的程序，以及一个任务需要运行多长时间，这些都是操作系统的工作。</p></li><li><p>空间维度</p><p>每个客户都获取了一个大的资源中的一小部分资源，从而减少了排队等待资源的时间。</p><p>例如：多个运行的程序同时进入内存，硬件层面提供保护机制来确保各自的内存是分割开的，且由操作系统控制，这比一个程序独占内存一个一个排队进入内存效率要高的多。</p><p>有关空间复用的其他资源还有磁盘，在许多系统中，一个磁盘同时为许多用户保存文件。分配磁盘空间并且记录谁正在使用哪个磁盘块是操作系统资源管理的典型任务。</p></li></ul></li></ul><h2 id="操作系统简史"><a href="#操作系统简史" class="headerlink" title="操作系统简史"></a>操作系统简史</h2><h3 id="第一代：真空管和穿孔卡片"><a href="#第一代：真空管和穿孔卡片" class="headerlink" title="第一代：真空管和穿孔卡片"></a>第一代：真空管和穿孔卡片</h3><p>第一台数字计算机ENIAC，未采用二进制操作和存储程序控制，未具备现代电子计算机的主要特征。</p><p>所有的程序设计均用纯粹的硬件语言编写，需要手动修改逻辑单元的连接来运行软件，控制机器的基本功能。甚至没有操作系统的概念。</p><h3 id="第二代：晶体管和批处理系统"><a href="#第二代：晶体管和批处理系统" class="headerlink" title="第二代：晶体管和批处理系统"></a>第二代：晶体管和批处理系统</h3><p>计算机变得更加可靠，可长时间运行。随着计算机速度的提高，速度层面上的人机矛盾已不可容忍。</p><p>同时，当时的计算机非常昂贵，因此很自然的想办法较少机时的浪费。为了实现作业的自动过度，出现了成批处理。</p><p>典型的操作系统：FMS（the Fortran Monitor System），批处理系统。</p><p>批处理技术：计算机系统对一批作业进行处理的系统，可分为联机批处理和脱机批处理。</p><p>脱机批处理系统由主机和卫星机构成。卫星机又称外围计算机，不与主机直接连接，而只与外部设备连接，专门控制外设。这样，主机摆脱了慢速的I&#x2F;O给你工作，可以充分发挥主机的高速计算能力。</p><h3 id="第三代：小规模集成电路和多道程序设计"><a href="#第三代：小规模集成电路和多道程序设计" class="headerlink" title="第三代：小规模集成电路和多道程序设计"></a>第三代：小规模集成电路和多道程序设计</h3><p>20世纪60年代初期，大多数计算机厂商都有两条完全不兼容的生产线。一条是面向字的大型的科学计算机，如IBM 7094，主要用于科学计算和工程计算；另外一条是面向字符的商用计算机，如IBM 1401，主要用于银行和保险公司从事磁带归档和打印服务。</p><p>开发和维护完全不同的产品是昂贵的，同时不同的用户对计算机的用途不同。IBM公司试图通过引入system&#x2F;360系列来同时满足科学计算和商业计算，360系列低档机与1401相当，高档机比7094功能强很多，不同的性能卖不同的价格。</p><p>360是第一个采用了（小规模）芯片（集成电路）的主流机型，与采用晶体管的第二代计算机相比，性价比有了很大的提高。这些计算机的后代仍在大型的计算机中心里使用，此乃现在服务器的前身，这些服务器每秒处理不小于千次的请求。</p><h4 id="多道批处理技术"><a href="#多道批处理技术" class="headerlink" title="多道批处理技术"></a>多道批处理技术</h4><p>在前述的批处理系统中，引入<code>多道程序设计技术</code>后形成<code>多道批处理系统</code>，简称批处理系统。</p><ul><li>多道：系统内可以同时容纳多个作业。这些作业放在外存中组成后备队列，系统按照一定的调度原则每次从后备作业队列选取一个&#x2F;多个作业进入内存运行，运行作业结束、退出运行和后被作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的的作业流。</li><li>成批：在系统运行过程中，不允许用户与其作业发生交互作用。作业一旦进入系统，用户就不能直接干预其作业的运行。</li><li>优点：系统吞吐量大，资源利用率高</li><li>缺点：平均周转时间长，不能提供交互作用能力。</li></ul><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>将CPU处理时间分割成多个<code>时间片</code>，将时间片分给不同程序，达到多个程序<code>“同时”</code>运行的效果。</p><blockquote><p>Why？</p><ul><li>批处理系统一次执行一个程序，I&#x2F;O过程CPU空转</li><li>进一步提高CPU利用率，支持多用户，多进程</li></ul></blockquote><h3 id="第四代：PC机-微机操作系统"><a href="#第四代：PC机-微机操作系统" class="headerlink" title="第四代：PC机 &amp; 微机操作系统"></a>第四代：PC机 &amp; 微机操作系统</h3><p>MSDOS、WINDOWS 95、WINDOWS NT、WINDOWS  2000</p><p>类UNIX(Linux, Freebsd等)</p><h3 id="第五代：分布式与嵌入式系统"><a href="#第五代：分布式与嵌入式系统" class="headerlink" title="第五代：分布式与嵌入式系统"></a>第五代：分布式与嵌入式系统</h3><p>Cluster of Workstation, Network of Workstation, Grid, Cloud</p><p>实时操作系统：Psos, VRTX, RTLinux, VxWorks</p><p>智能操作系统：智能车载、无人机载、智能家庭</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1-假如没有操作系统，怎样控制硬件？"><a href="#1-假如没有操作系统，怎样控制硬件？" class="headerlink" title="1. 假如没有操作系统，怎样控制硬件？"></a>1. 假如没有操作系统，怎样控制硬件？</h3><p>如果没有操作系统，需要手动根据硬件各自不同的接口输入控制指令，分别控制不同的硬件。</p><p>以软盘IO为例，控制芯片NEC PD765有16条命令，每一条命令向一个设备寄存器装入长度从1到9字节的特定数据（读写数据、移动磁头臂、格式化磁道，及初始化、检测状态、复位、校准控制器及设备等）。以READ为例，读数据需要13个参数，要读取的磁盘块地址、磁道的扇区数、物理介质的记录格式、扇区间隙、对已删除数据地址标识的处理方法，操作结束时，控制器芯片在7个字节中返回23个状态及出错字段。</p><p>不同的硬件，其接口是有差异的，并且常常是“丑陋”的，如果有操作系统，操作系统可以完成统一管理“丑陋”的底层接口，向上提供整齐的软件接口的工作。</p><h3 id="2-什么是多道程序设计？多道程序设计与分时系统的区别是什么？"><a href="#2-什么是多道程序设计？多道程序设计与分时系统的区别是什么？" class="headerlink" title="2. 什么是多道程序设计？多道程序设计与分时系统的区别是什么？"></a>2. 什么是多道程序设计？多道程序设计与分时系统的区别是什么？</h3><p>多道程序设计（Multiprogramming）是一种计算机操作系统的运行方式，它允许同时运行多个程序。</p><p>在多道程序设计中，操作系统将CPU时间分割成很短的时间片（时间段），并在每个时间片中将CPU分配给不同的程序。这样，多个程序可以并发地执行，从而提高了系统的吞吐量和利用率。</p><p>相同之处：</p><ol><li><p>都可以同时处理和执行多个作业。</p></li><li><p>都充分利用发挥了计算机系统部件的并行性。</p></li><li><p>都提高了CPU的利用率。</p></li><li><p>都需要在内存中同时保存多个作业。</p></li><li><p>分时技术本身就是多道程序设计技术的延伸。</p></li></ol><p>不同之处：</p><ol><li><p>分时操作系统是给不同用户提供程序的使用，而多道程序系统则是不同程序间的穿插运行。</p></li><li><p>分时操作系统主要是针对于多用户来说的，而多道程序系统主要是针对于多程序来说的。</p></li><li><p>分时系统要求计算机系统是可交互的，而多道程序系统没有提供用户与计算机系统的交互。</p></li><li><p>分时系统中CPU的使用权变更比多道系统中频繁得多，因为分时系统需要保证多个用户同时的使用体验，CPU的切换必须非常快；而多道系统只强调效率，单个程序持续占用CPU的时间会长得多。</p></li></ol><h3 id="3-什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？"><a href="#3-什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？" class="headerlink" title="3. 什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？"></a>3. 什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？</h3><p>批处理系统的主要推动力是提高系统资源利用率和系统吞吐量。这主要体现在两个方面：一是脱机输入&#x2F;输出技术的应用和作业的自动过渡，这大大提高了I&#x2F;O的速度，增加了I&#x2F;O设备与CPU并行工作的程度，从而减少了主机CPU的空闲时间；二是多道程序设计技术的应用，它更进一步提高了CPU、内存和I&#x2F;O设备的利用率以及系统的吞吐量。</p><p>分时系统的形成和发展主要是为了更好地满足用户的需要。这主要体现在三个方面：一是CPU的分时使用，这缩短了作业的平均周转时间；二是人机交互能力的提供，使用户能方便地直接控制自己的作业；三是主机的共享，这使得多个用户（包括远程用户）能同时使用同一台计算机，独立地、互不干扰地处理自己的作业。</p><p>因此，操作系统的这种发展路径是由提高系统效率和满足用户需求这两个主要驱动力共同推动的。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归下降法——处理复杂输入</title>
    <link href="/2024/02/26/OO1/"/>
    <url>/2024/02/26/OO1/</url>
    
    <content type="html"><![CDATA[<h1 id="递归下降法——处理复杂输入"><a href="#递归下降法——处理复杂输入" class="headerlink" title="递归下降法——处理复杂输入"></a>递归下降法——处理复杂输入</h1><p>这篇文章对oolens的推文《OO加油站——递归下降》进行总结。</p><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p>文法（Grammar）是对语言结构的定义与描述，通过形式化的表述来规定语言结构的规则。</p><p>简单来说，<strong>文法是语言的规则</strong>。</p><h3 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h3><p>词法（Lex）是指语言中的词汇及其属性和含义的规则，它规定了一个语言中的“词”是如何构成的。</p><p>假设有一个语法单元“变量名”，定义其为<strong>由大于0个小写字母组成的字符串</strong>，也可以表示成这样：</p><p><img src="https://pic.imgdb.cn/item/65dc4c589f345e8d03187948.png"></p><p>其中：</p><ol><li>尖括号内表示一个语法成分；</li><li>右箭头表示左侧的部分由右侧的部分组成；</li><li>竖线表示右边的规则可以选取竖线两侧的任一种情况。</li></ol><p>这样，我们就可以得到变量名的构成规则。换言之，所定义的变量名<strong>仅限于一个字母或一个字母后接另一个变量名</strong>。</p><div class="note note-success">            <p><strong>Example</strong></p><p>“buaa”是变量名；“buaa_cs”不是变量名，因为它出现了不属于letter中的下划线“_”。</p>          </div><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法（Syntax）是指描述语言中句子结构和组织方式的规则。它规定了一个语言中的”句”是如何构成的。比如说：</p><p><img src="https://pic.imgdb.cn/item/65dc4d619f345e8d031b0835.png"></p><p>在这里，句子是一个主语加上一个谓语连在一起构成的。其中主语可能是<code>i</code>也可能是<code>you</code>；谓语可能是<code>smile</code>，可能是<code>laugh</code>。</p><h2 id="文法分析"><a href="#文法分析" class="headerlink" title="文法分析"></a>文法分析</h2><p>已知一个字符串，如何判断它是不是我们上面定义的变量名？如何判断它是不是我们定义的句子？</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>可以首先判断一下字符串的长度是否为0 。然后对所有字符依次检查它是否是字母。这是比较基础的应用。</p><p>那么考虑下一个问题：</p><blockquote><p>已知有多种词A、B、C、D和他们的构成规则（假设规则间不存在矛盾或重复），给定一个字符串，如果保证字符串完全由这些词组成，依次输出字符串里面的<strong>词</strong>及其所属的<strong>类别</strong>。</p></blockquote><p>这个问题不仅涉及到字符串的判断，也同时涉及到字符串的划分。</p><p>举一个最简单的例子<code>ismileyoulaughsmile</code>。每一个词的开头都是不重复的。因此可以依次读取所有字母，然后依据该字母是什么而判断读到的是什么单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();i++)&#123;<br>  <span class="hljs-keyword">if</span>(str.charAt(i)==<span class="hljs-string">&#x27;i&#x27;</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;i - 主语&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.charAt(i)==<span class="hljs-string">&#x27;y&#x27;</span>)&#123;<br>    i=i+<span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;you - 主语&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.charAt(i)==<span class="hljs-string">&#x27;s&#x27;</span>)&#123;<br>    i=i+<span class="hljs-number">4</span>;<br>    System.out.println(<span class="hljs-string">&quot;smile - 谓语&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    i=i+<span class="hljs-number">4</span>;<br>    System.out.println(<span class="hljs-string">&quot;laugh - 谓语&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>在计算机领域，<strong>token</strong>常常用来表示文本的最小语法单位。这里可以以token来存储字符串经过词法分析得到的一个个单元。</p><p>不妨假设我们用一个<strong>list</strong>来存储分析得到的token，那么每识别出一个token，就可以向这个列表中加上它。这样，经过一遍扫描，我们就可以将一个字符串的信息整合转化成一个token的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();i++)&#123;<br>  <span class="hljs-keyword">if</span>(str.charAt(i)==<span class="hljs-string">&#x27;i&#x27;</span>)&#123;<br>    tokenList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;主语&quot;</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.charAt(i)==<span class="hljs-string">&#x27;y&#x27;</span>)&#123;<br>    i=i+<span class="hljs-number">2</span>;<br>    tokenList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(<span class="hljs-string">&quot;you&quot;</span>,<span class="hljs-string">&quot;主语&quot;</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.charAt(i)==<span class="hljs-string">&#x27;s&#x27;</span>)&#123;<br>    i=i+<span class="hljs-number">4</span>;<br>    tokenList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(<span class="hljs-string">&quot;smile&quot;</span>,<span class="hljs-string">&quot;谓语&quot;</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    i=i+<span class="hljs-number">4</span>;<br>    tokenList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(<span class="hljs-string">&quot;laugh&quot;</span>,<span class="hljs-string">&quot;谓语&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>现已经将字符串转化为一个一个token了，从现在开始，语法分析的对象从初始的字符串可以转化为这个 “token” 列表。</p><p> 从代码设计的角度上来看，通过将字符串经过词法分析转化为 “token” 列表，词法分析这一道工序将半成品<strong>tokenList</strong>传入到下一道工序：语法分析，而不是直接在语法分析阶段调用词法的解析，能够很好的减少这两个不同级别处理之间的耦合。</p><p>为了说明如何进行语法分析，这里引入一个稍显复杂的规则：</p><p><img src="https://pic.imgdb.cn/item/65dc56da9f345e8d03330aac.png"></p><p>在这个结构中，<code>表达式 = 项 + 项 + …… + 项</code>，<code>项 = 因子 * 因子 * …… * 因子</code>；因子用一个字母<code>i</code>表示且不可再分。</p><p>最外层是表达式，表达式可以被看作是几个项的和，项可以被看作是几个因子的乘积，这样，一个表达式的结构很明显的分成了三层，此时进行词法分析是个很简单的过程，我们只需要对i，*，+分别识别即可。</p><p>在思考如何做语法分析的问题前，不妨考虑一下，什么样的结构能够最好的表达各个语法结构之间的关系呢？</p><p>回答这个问题，不妨先回头看看前面已经建立的对该规则的认识：表达式的“三层”，用图像来表示的话应当是下面的样子。</p><p><img src="https://pic.imgdb.cn/item/65dc58039f345e8d0335d73e.png" alt="表达式的“三层”"></p><p>语法分析的目的，就是生成一个这样的树，它用节点之间的联系来表达原本表达式的语法结构。这种树一般被称为<strong>语法树</strong>（Syntax Tree）或<strong>抽象语法树</strong>（Abstract Syntax Tree，AST）。</p><p>可以构建语法树的几个节点类，其中表达式用<strong>Expr</strong>表示，项用<strong>Term</strong>表示，因子用<strong>Factor</strong>表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Expr</span>&#123;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;Term&gt;terms;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Term</span>&#123;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;Factor&gt;factors;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factor</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>语法分析就是建立由这几个类构成的节点的语法树的过程。</p><h3 id="自顶向下建树"><a href="#自顶向下建树" class="headerlink" title="自顶向下建树"></a>自顶向下建树</h3><p>对字符串进行分析时，默认这个字符串代表一个<code>表达式</code>。因此，无论这个字符串的内容是什么，它转化成的语法树的树根都是<code>表达式</code>。</p><p>做法步骤如下：</p><ol><li>对<code>表达式</code>按照规则进行拆分；</li><li>识别出构成<code>表达式</code>的一个一个<code>项</code>；</li><li>对<code>项</code>按照规则进行拆分；</li><li>识别出构成<code>项</code>的一个一个<code>因子</code>；</li><li>构建一颗自顶向下的逻辑树。</li></ol><h4 id="下降"><a href="#下降" class="headerlink" title="下降"></a>下降</h4><p>对于规则</p><p><img src="https://pic.imgdb.cn/item/65dc7bd99f345e8d03934de3.png"></p><p>可以对其进行一定的变化，假设将其翻译为</p><p><img src="https://pic.imgdb.cn/item/65dc7c099f345e8d0393e560.png"></p><p>那么，对于这一条翻译过的规则，它的视角从<code>表达式</code>层到了<code>顶</code>层。也就是说，每一条语法规则，事实上都说明了一个语法单元作为树节点时，它的子节点是如何构成的。而分析这个构成的过程，我们就<strong>在语法树上下降了一层</strong>。</p><h4 id="从全局到局部"><a href="#从全局到局部" class="headerlink" title="从全局到局部"></a>从全局到局部</h4><p>如果从全局的视角来看，综合考虑所有的规则，就会得到上面图中的语法树。它的大小，宽度和深度随着规则的扩张而不断增加，规则条数越多，树越复杂，我们要从全局的视角来处理也就越困难，可以想象一下添加若干将因子再拆成更低层的组成部分的情况：</p><p><img src="https://pic.imgdb.cn/item/65dc7cbc9f345e8d0395f71f.png"></p><p>那么从全局来看，我们的语法树将会变得十分的庞大和复杂，解析它的程序也会变得复杂起来。</p><p>但是实际上，一个节点有关的语法结构，是不随其所在的位置变化的：某个Term无论是Expr的第几个Term，它的构成规则也不会改变，都是由若干个因子和若干个”*”按次序排布构成。<strong>这个局部的性质，不随其在全局的位置和周围的状态改变。</strong>所以，不妨把全局的视角，”短视地”移动到局部：</p><p><img src="https://pic.imgdb.cn/item/65dc7cff9f345e8d0396afea.png"></p><p>那么就能从语法树中提取出这样的的一个结构。它揭示了这样一个事实：<strong>不用管项从哪里来，只需要知道项往哪里去，就能够处理好项的解析。</strong>如果仅仅将这一部分的逻辑抽象出来写一段程序，想必比之前写整个树的程序轻松不少。再往上的另一条规则，也可以被单独抽象出来：</p><p><img src="https://pic.imgdb.cn/item/65dc7d1b9f345e8d03970105.png"></p><p>一个表达式，就是几个项而已。<strong>如果我们能够在这里屏蔽项的解析过程，而直接返回项的解析结果，那么就可以将表达式的解析过程化简为一次简单的下降。</strong></p><div class="note note-danger">            <p><strong>Notice</strong></p><p>以往的代码编写中，可能习惯将解决一个局部问题的具体过程嵌入到更高层次代码的编写中（例如在这俩将解析项的具体过程直接写到解析表达式的过程中）。但事实上，让逻辑变简单的一个方法是，在高层次的代码编写中<strong>忽视局部问题的解决过程</strong>，假设其已经被某个方法解决，从而直接调用该方法即可。</p><p>选择合适的局部视角，合理的屏蔽细节，将具体的实现封装，是让代码高效且清晰的重要手段。</p>          </div><p>如果parseExpr()，parseTerm()分别用来表示解析表达式和项的过程，可以得到下面这种实现：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">parserEx<span class="hljs-symbol">pr:</span><br>  新建一个Term的容器<span class="hljs-built_in">T</span><br>  调用parserTerm获得一个项<span class="hljs-built_in">t</span><br>  <span class="hljs-built_in">T</span>中加上parserTerm返回的项<span class="hljs-built_in">t</span><br>  while 当前token是+<span class="hljs-symbol">:</span><br>    跳过当前token(+)<br>    调用parserTerm获得一个项<span class="hljs-built_in">t</span><br>    <span class="hljs-built_in">T</span>中加上parserTerm返回的项<span class="hljs-built_in">t</span><br>  利用<span class="hljs-built_in">T</span>生成一个新的Expr e<br>  返回e<br></code></pre></td></tr></table></figure><p>可以看到，有了parseTerm()的封装，我们解析Expr的过程(parseExpr)，就变成了对语法规则的简单叙述。parseTerm的过程也如法炮制。</p><p>当然，factor在当前的题目背景下仅是一个i ，因此我们解析factor的过程就是读入一个i ，然后包装成一个factor对象再返回，它不需要调用其他的子过程。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stata">parserTerm:<br>  新建一个<span class="hljs-keyword">Factor</span>的容器F<br>  调用parserFactor获得一个因子f<br>  F中加上parserFactor返回的因子f<br>  <span class="hljs-keyword">while</span> 当前<span class="hljs-keyword">token</span>是*:<br>    跳过当前<span class="hljs-keyword">token</span>(*)<br>    调用parserFactor获得一个因子f<br>    F中加上parserFactor返回的因子f<br>  利用F生成一个新的Term t<br>  返回t<br><br>parserFactor:<br>  检查当前的<span class="hljs-keyword">token</span>是否是i<br>  跳过当前的<span class="hljs-keyword">token</span>(i)<br>  利用i生成一个新的<span class="hljs-keyword">Factor</span> f<br>  返回f<br></code></pre></td></tr></table></figure><p>这样就按每一条规则，生成了解析表达式语法结构的代码。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>必须指出的是，如果我们不曾听说过或者学习过类似的观点，也可以用一个多层的循环来简单地解决这个问题。这是因为我们上面题面给出的语法结构所形成的树，具有固定的层数，我们可以清楚的知道这个树的终结就在子节点的factor处。</p><p>为了更好地说明递归下降法的意义，我们来修改一下上述因子的语法规则:</p><p><img src="https://pic.imgdb.cn/item/65dc7e969f345e8d039c3208.png"></p><p>这么做的话，我们的语法树就不是简单的三层了。甚至说我们并不知道它的层数，因为任何一个因子都可以通过解析为表达式的方式来不断的向下扩张，这无疑给了我们很大的复杂性。我们的解析流程，可能会呈现&lt;表达式&gt;-&lt;项&gt;-&lt;因子&gt;-&lt;表达式&gt;\的递归调用过程。如果再从全局的视角来看，这个语法树的宽度和深度等性质不再可知，它已经变得不可捉摸了。</p><p>但是我们从局部的视角来看，会发现表达式的语法规则没有变，项的也没有变，唯一变的是因子，所以我们只需要修改上面的parseFactor过程就好。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">parserFactor</span>:<br>  检查当前的<span class="hljs-variable">token</span>是否是<span class="hljs-variable">i</span><br>  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> 真:<br>    跳过当前的<span class="hljs-function"><span class="hljs-title">token</span>(<span class="hljs-variable">i</span>)</span><br>    利用<span class="hljs-variable">i</span>生成一个新的<span class="hljs-variable">Factor</span> <span class="hljs-variable">f</span><br>    返回<span class="hljs-variable">f</span><br>  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> 假，说明是(表达式):<br>    跳过当前<span class="hljs-function"><span class="hljs-title">token</span>(()</span><br>    调用<span class="hljs-function"><span class="hljs-title">parserExpr</span>()获得一个表达式<span class="hljs-variable">e</span></span><br><span class="hljs-function">    利用<span class="hljs-variable">e</span>生成因子<span class="hljs-variable">f</span></span><br><span class="hljs-function">    跳过当前<span class="hljs-title">token</span>())</span><br>    返回<span class="hljs-variable">f</span><br></code></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>这里我们需要总结一下：</p><ol><li>递归下降分析方法的主要做法是，对文法每条规则的左部符号（ ‘→’ 左侧的符号），建立一个解析子程序，用以完成该符号所代表成分的分析和识别。</li><li>对于每个符号的分析子程序的功能则是，用该符号对应文法中的规则来匹配输入的token流。</li></ol><p>根据我们上面的例子可以看到，递归下降算法的思想严格依照文法来编写，甚至可以理解为文法的一种“<strong>翻译</strong>”，递归下降正是依托于文法保证了该算法的正确性。</p><p>递归下降分析法作为自顶向下的分析过程，其一级一级的向下分配任务，通过检测当前符号和预期符号 （文法中的规则） 的相符性来选择”分支”进行解析，进而建立结构。</p><p>下面我们进一步真正实现该算法：</p><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><blockquote><p>为了方便举例，我们仍然使用表达式解析作为背景，不过对其中的一些规则进行修改。给一个表达式，解析它的结构，并用输出来检验解析的正确性。表达式规则如下：</p></blockquote><p><img src="https://pic.imgdb.cn/item/65dc7f6d9f345e8d039ecb0b.png"></p><h3 id="解法步骤"><a href="#解法步骤" class="headerlink" title="解法步骤"></a>解法步骤</h3><h4 id="建类"><a href="#建类" class="headerlink" title="建类"></a>建类</h4><p>观察上面在→左面的部分，他们都是我们需要进行分析的语法成分，因此我们需要对他们进行建类，并且构造解析方法。</p><ol><li><p>表达式类 → Expr</p></li><li><p>项类 → Term</p></li><li><p>因子类 → Factor ← Number &amp; Expr</p></li></ol><p>这里考虑到有两种因子，我们应当分开来处理。</p><p><strong>表达式因子</strong>实质就是表达式加括号，而括号本质上是为了区分优先级，但优先级可以由我们的语法树结构来体现，因此为了减少类，可以将这二者统一，都使用表达式Expr来存储信息。</p><p><strong>常数因子</strong>则可以单独用Number来存。</p><p>Expr和Number都属于因子，因此我们可以利用面向对象的知识，创造一个Factor接口(Interface)，然后让Expr和Number实现这个接口。</p><h4 id="实现Lexer"><a href="#实现Lexer" class="headerlink" title="实现Lexer"></a>实现Lexer</h4><p>我们通常将词法分析部分所用的类叫做Lexer，它实现了词法分析功能，并且将分析得到的信息存储到token流中。</p><p>首先梳理一下我们需要的token类型：**+ - * ( ) 数**。</p><p>可以分别对这几个类型的词法单元建立token的标识符，可以建立一个token类来实现这个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span> &#123;<br>  ADD, SUB, MUL, LPAREN, RPAREN, NUM<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Type type;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String content;<br>  <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时，在词法分析部分，lexer需要识别不同的token，注意到，这几个类型的词法单元的开头字符必然不同，因此我们利用这一点来实现词法分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Lexer</span><span class="hljs-params">(String input)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos &lt; input.length()) &#123;<br>        <span class="hljs-keyword">if</span> (input.charAt(pos) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            tokens.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(Token.Type.LPAREN, <span class="hljs-string">&quot;(&quot;</span>));<br>            pos++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.charAt(pos) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            tokens.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(Token.Type.RPAREN, <span class="hljs-string">&quot;)&quot;</span>));<br>            pos++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.charAt(pos) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            tokens.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(Token.Type.ADD, <span class="hljs-string">&quot;+&quot;</span>));<br>            pos++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.charAt(pos) == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            tokens.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(Token.Type.SUB, <span class="hljs-string">&quot;-&quot;</span>));<br>            pos++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.charAt(pos) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            tokens.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(Token.Type.MUL, <span class="hljs-string">&quot;*&quot;</span>));<br>            pos++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> input.charAt(pos);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">while</span> (now &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; now &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                sb.append(now);<br>                pos++;<br>                <span class="hljs-keyword">if</span> (pos &gt;= input.length()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                now = input.charAt(pos);<br>            &#125;<br>            tokens.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(Token.Type.NUM, sb.toString()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就获得了一个经过了词法分析的token流，便可以从中逐一地拿出token方便我们进行语法分析了。</p><h4 id="实现Parser"><a href="#实现Parser" class="headerlink" title="实现Parser"></a>实现Parser</h4><p>这一步我需要进入到递归下降法的真正实现了。但是首先我们需要先看看题目中的文法，它并不能直接的使用递归下降法：</p><p><img src="https://pic.imgdb.cn/item/65dc805a9f345e8d03a17f09.png"></p><p>怎么判断箭头右边走哪一个路线呢？甚至说，就算去掉一个路线：</p><p><img src="https://pic.imgdb.cn/item/65dc80779f345e8d03a1d2a4.png"></p><p>难道是要在表达式的解析开始就再次调用表达式的解析吗？具体的情况就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">parserExpr() &#123;<br>  parserExpr();<br>  <span class="hljs-comment">//.....</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>这样的代码会陷入无限的递归中，不是我们想要的结果。事实上，在编译原理中，有类似规则的文法叫做左递归文法，它是不能用递归下降法解决的。幸运的是，我们可以通过<strong>改写文法</strong>来消除左递归：</p><p><img src="https://pic.imgdb.cn/item/65dc805a9f345e8d03a17f09.png"></p><p>这里，花括号代表可以有0个或多个该部分，这样的改写与我们对原本规则的理解一致，因此是<strong>等价</strong>的。类似的，我们对其他的规则也进行改写。</p><p><img src="https://pic.imgdb.cn/item/65dc81019f345e8d03a371a4.png"></p><p>parser部分的关键则是如何用获得的token判断应当如何调用解析的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Expr <span class="hljs-title function_">parserExpr</span><span class="hljs-params">()</span> &#123;<br>  ArrayList&lt;Term&gt; terms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  ArrayList&lt;Token&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  terms.add(parserTerm());<br>  <span class="hljs-keyword">while</span> (lexer.notEnd()&amp;&amp;(lexer.now().getType() ==<br>  Token.Type.ADD<br>  || lexer.now().getType() == Token.Type.SUB)) &#123;<br>    ops.add(lexer.now());<br>    lexer.move();<br>    terms.add(parserTerm());<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>(terms, ops);<br>&#125;<br><br><span class="hljs-keyword">public</span> Term <span class="hljs-title function_">parserTerm</span><span class="hljs-params">()</span> &#123;<br>  ArrayList&lt;Factor&gt; factors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  factors.add(parserFactor());<br>  <span class="hljs-keyword">while</span> (lexer.notEnd()&amp;&amp;lexer.now().getType() ==<br>        Token.Type.MUL) &#123;<br>    lexer.move();<br>    factors.add(parserFactor());<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Term</span>(factors);<br>&#125;<br><br><span class="hljs-keyword">public</span> Factor <span class="hljs-title function_">parserFactor</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.now().getType() == Token.Type.NUM) &#123;<br>    <span class="hljs-type">Num</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Num</span>(lexer.now().getContent());<br>    lexer.move();<br>    <span class="hljs-keyword">return</span> num;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-comment">// 这里调用move之前lexer.now()是(    </span><br>   lexer.move();    <br>   <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> parserExpr();   <br>   <span class="hljs-comment">// 这里调用move之前lexer.now()是)    </span><br>   lexer.move();   <br>   <span class="hljs-comment">// 调用上面的move之后刚好保证表达式因子的全部成分被跳过。    </span><br>   <span class="hljs-keyword">return</span> expr;  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，lexer.now()获取当前分析的token，lexer.move()则可以移动到下一个token。</p>]]></content>
    
    
    <categories>
      
      <category>面向对象设计与构造</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS假期预习（二）——MIPS知识补充</title>
    <link href="/2024/02/24/OSPre2/"/>
    <url>/2024/02/24/OSPre2/</url>
    
    <content type="html"><![CDATA[<h1 id="OS假期预习（二）——MIPS知识补充"><a href="#OS假期预习（二）——MIPS知识补充" class="headerlink" title="OS假期预习（二）——MIPS知识补充"></a>OS假期预习（二）——MIPS知识补充</h1><p>下面将介绍操作系统实验使用的 CPU 与我们计组的课设 CPU 的不同之处，并对 MIPS 汇编相关知识进行补充。</p><p>操作系统实验使用 MIPS32 4Kc CPU， 这是一款由 MIPS® Technologies 公司开发的使用 MIPS32 指令集的商业处理器核。</p><p>而计组中实现的 CPU 使用 MIPS-C 指令集，MIPS-C 指令集是 MIPS32 指令集的精简版本，也就是相当于计组实现的 CPU 指令集和功能是操作系统实验中使用的一个子集。</p><p>具体谈及操作系统实验中涉及，而计组 CPU 不完整的功能，主要是有两个部分：访存流程、CP0协处理器相关。</p><h2 id="访存流程"><a href="#访存流程" class="headerlink" title="访存流程"></a>访存流程</h2><p>在计组中，我们的 CPU 不存在<strong>虚拟地址</strong>机制，访存指令中的所有地址均是物理地址。物理地址被直接发送到 DM、IM 中，直接获取数据。这简化了 MIPS32 的访存流程，让大家可以更多的关注 CPU 内部计算与控制逻辑。</p><p>而在完整的 MIPS32 访存流程中，汇编指令 <strong>不直接和物理内存打交道</strong>。</p><p>访存指令中的地址，被称作<strong>虚拟地址</strong>，在执行访存操作的时候，虚拟地址会先被送入 <strong>MMU</strong> 进行<strong>地址翻译</strong>、<strong>权限检查</strong>，最终拿到物理地址。</p><p>对于 MMU 检查合法的访存操作，通过 MMU 拿到物理地址之后，相应访存操作才会进一步被实际在物理地址上执行。</p><p>所有的软件（包括 MIPS 汇编、C 语言编写的软件等）访存的地址都是虚拟地址。</p><p>MIPS32 的 MMU 支持基于 <strong>TLB</strong> 的 <strong>页式地址翻译</strong>，而操作系统实验使用了 MIPS32 的这个地址翻译功能。这一部分在计组的 CPU 中并没有涉及。</p><p>这将牵扯出我们OS中的两个知识点：MIPS32 具体访存流程、TLB 在 MIPS32 地址翻译中扮演的角色。具体内容将在我们 Lab2 内存管理中学到，在 pre 中我们仅介绍到此。</p><p>目前，只需要大家牢记，在 MIPS32 指令集中，我们的访存指令不再直接操作物理地址，而是使用虚拟地址以及地址翻译机制，间接管理物理内存。</p><h2 id="CP0协处理器"><a href="#CP0协处理器" class="headerlink" title="CP0协处理器"></a>CP0协处理器</h2><p>计组课程中 CPU 的协处理器 CP0 基本只负责中断与异常的相关处理。</p><p>而 MIPS32 指令集的 CP0 更为复杂，也具有更多功能，整体上 CP0 用于对整个处理器的状态进行维护和控制，包括但不限于对于中断及异常信息的记录、特权管理、地址翻译控制等。</p><p>控制地址翻译的功能将在 Lab2 的实验中具体涉及。</p><h3 id="中断异常"><a href="#中断异常" class="headerlink" title="中断异常"></a>中断异常</h3><p>对于中断及异常的处理，MIPS32 比 MIPS-C 的要复杂一些。实验中使用的部分主要涉及 CP0 的一些寄存器： Cause、EPC、BadVAddr 。</p><p>其中 Cause 与 EPC 寄存器在 MIPS32 与 MIPS-C 中均存在，其定义也是相似的，而 BadVAddr 则不存在于 MIPS-C 中。</p><p><img src="https://pic.imgdb.cn/item/65e0716c9f345e8d033bddf6.png" alt="异常原因寄存器"></p><p>上图是 MIPS32 中定义的 Cause 寄存器，其中保存着 CPU 中哪一些中断或者异常发生了。 15-8 位指示了哪一些中断等待处理，其中 15-10 位来自硬件，9-8 位可以由软件写入。当中断请求发生时，Cause 寄存器对应位置 1。 6-2 位则记录发生的异常号，供软件进行区别。还需要特别注意的是 31位 BD，当这一位为1时，表明发生异常的指令位于延迟槽，软件在处理其异常时需要特别特殊处理。</p><p>EPC 寄存器：存放异常发生的指令对应 PC 地址，软件在完成异常处理之后，可以根据此 PC 返回。</p><p>BadVAddr 寄存器： 在我们前文的访存流程中有提到，若访存操作合法，具体的操作才会被执行。不合法的访存操作则会触发异常，当访存相关的异常被触发时，这个寄存器将会被用来记录触发异常的访存地址供软件进行处理。</p><p>计组课程着重于实现一个简略的硬件 CP0 ，并不关注软件实现的部分，而操作系统课程更多关注配合硬件的软件部分（即操作系统本身）。</p><h3 id="特权管理"><a href="#特权管理" class="headerlink" title="特权管理"></a>特权管理</h3><p>在 MIPS-C 中，处理器只有一个<strong>特权模式</strong>，对于所有指令，均一视同仁的在这个<strong>特权模式</strong>下，所有操作均被允许执行。而 MIPS32 中，则定义了多种特权模式，主要使用的两种状态被叫做<strong>用户态</strong>、<strong>内核态</strong>。</p><p>在内核态下，CPU 可以执行其架构允许的任何操作；可以执行任何指令、启动任何 I&#x2F;O 操作、访问任何内存区域等等。在其他特权模式下， CPU 允许执行的操作收到硬件限制限制。通常，某些特殊指令是不被允许的（具体而言，通常是影响计算机控制或者完成 I&#x2F;O 操作的指令），某些内存区域也无法访问，等等。</p><blockquote><p>内核态即计组实验中所提到的特权态，用户态就是非特权态。操作系统借助 CPU 的这套硬件特权控制机制，实现对并发运行的不同用户程序的隔离，以及对计算机整体安全的保护。</p></blockquote><p>试想若 CPU 不存在这样一种特权控制机制，那么任意用户程序都可视为具有与操作系统同等的地位。这种情况下，用户程序可以完全脱离操作系统的管理与控制，这是不安全的。</p><p>与处理器状态相关的寄存器，主要是 Status 寄存器，它控制处理器整体工作模式。在计组的 CP0 中，也存在一个 Status 寄存器，不过当时只使用了其对中断使能控制的功能。</p><p><img src="https://pic.imgdb.cn/item/65e072369f345e8d033ee424.png" alt="状态寄存器"></p><p>上图是 MIPS32 中定义的 Status 寄存器，其控制整个处理器状态。其完整定义比较复杂，我们只用关注其中部分位即可。Status 寄存器的第 0 位，是全局中断使能位。只有这一位配置为 1 ，处理器才可以响应中断。第 15-8 为中断使能位，分别控制 8 个中断输入的使能。第 4 位 UM 与 第 1 位 EXL 则用于控制处理器的特权模式。当且仅当 UM 为 1 且 EXL 为 0 时，处理器运行在用户态，其它状态下，处理器均运行于内核态。</p><p>计组中，我们 CPU 只能一次运行一个我们编写的 MIPS 汇编程序。而在操作系统中，我们可以通过操作系统配合硬件时钟中断给不同进程分配 CPU 时间，使得 CPU 在执行不同进程间切换，实现多个进程的并发执行。</p><p>对于 MIPS 体系结构来说，实时中断产生时，就会触发中断，将 PC 指向异常处理程序入口。异常处理程序首先保存现场，此后根据 Cause 寄存器中的情况进行异常分发，转到内核的不同异常处理子程序。</p><h2 id="MIPS调用约定"><a href="#MIPS调用约定" class="headerlink" title="MIPS调用约定"></a>MIPS调用约定</h2><p>精选自MIPS Calling Conventions Summary</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><table><thead><tr><th>寄存器编号</th><th>助记符</th><th>用途</th></tr></thead><tbody><tr><td>0</td><td>zero</td><td>值总是为 0</td></tr><tr><td>1</td><td>at</td><td>（汇编暂存寄存器）一般由汇编器作为临时寄存器使用。</td></tr><tr><td>2-3</td><td>v0-v1</td><td>用于存放表达式的值或函数的整形、指针类型返回值。</td></tr><tr><td>4-7</td><td>a0-a3</td><td>用于函数传参。其值在函数调用的过程中不会被保存。若函数参数较多，多出来的参数会采用栈进行传递。</td></tr><tr><td>8-15</td><td>t0-t7</td><td>用于存放表达式的值的临时寄存器; 其值在函数调用的过程中不会被保存。</td></tr><tr><td>16-23</td><td>s0-s7</td><td><strong>保存寄存器; 这些寄存器中的值在经过函数调用后不会被改变。</strong></td></tr><tr><td>24-25</td><td>t8-t9</td><td>用于存放表达式的值的临时寄存器; 其值在函数调用的过程中不会被保存。</td></tr><tr><td>26-27</td><td>k0-k1</td><td>仅在内核态下使用。</td></tr><tr><td>28</td><td>gp</td><td><strong>全局指针和内容指针。</strong></td></tr><tr><td>29</td><td>sp</td><td><strong>栈指针。</strong></td></tr><tr><td>30</td><td>fp或s8</td><td><strong>保存寄存器（同 s0-s7）。也可用作帧指针。</strong></td></tr><tr><td>31</td><td>ra</td><td><strong>函数返回地址。</strong></td></tr></tbody></table><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>每次调用一个函数时，都会为该函数创建一个唯一的栈帧。</p><p>栈帧的结构很重要。它在调用者和被调用者之间形成了一个契约，它定义了参数在调用者和被调用者之间如何传递，一个函数调用的返回值如何从被调用者传递给调用者，并定义了如何共享寄存器。</p><p>通常，函数的栈帧可能包含以下几个部分：</p><ul><li>用于存储传递给此调用的函数参数的空间。</li><li>存储已保存寄存器值的位置（s0 到 s7）。</li><li>一个存储子程序返回地址的地方（ra）。</li><li>一个用于本地数据存储的地方。</li></ul><p><img src="https://pic.imgdb.cn/item/65e073fa9f345e8d0344e178.png" alt="栈帧的结构"></p><p><strong>栈帧的黄色部分，即参数部分</strong>。当前函数 A 调用当前函数的子函数 B 时，会将 B 的参数压入当前函数 A 的栈帧中的参数部分，以实现对函数调用时的传参。此外，还需注意，由于 a0-a3 寄存器也将被用作传参，所以参数部分中的淡黄色部分（arg 0 至 arg 3）只需要保留栈帧空间，并不填入具体参数值。至于参数个数超过的 4 个的子函数，当前函数 A 就需要将多出来的第 4 至第 n-1 个参数压入栈中（arg 4 至 arg n-1），实现对子函数 B 的调用。</p><p><strong>栈帧的浅绿部分，即保留寄存器部分</strong>，前面提到我们会在当前函数被调用后，在当前函数最开始，复制当前函数要使用的任何规定需要保存的寄存器（s0 到 s7）的值压入栈帧的保留寄存器部分。此后，由于我们已经在栈帧中保存了当前函数被调用时寄存器的最初样貌，在函数执行中，函数可以随意读写已保存寄存器。当函数执行完毕，返回前，我们会复原栈中保留寄存器部分到寄存器中，使得函数的调用者（父函数），可以认为在整个调用过程中，保存的寄存器没有发生变化。</p><p><strong>栈帧的深绿部分，即返回地址部分</strong>。返回地址部分用于存储 ra 的值。该值在执行当前函数开始时被复制到栈中，并在当前函数返回之前被复制回 ra 寄存器中。</p><p><strong>栈帧的灰色部分，即填充部分</strong>，其作用在于确保栈帧的总大小总是 8 的倍数。在这里插入它，以确保其上方的局部数据存储部分首地址是双字对齐的。这是为了与 MIPS 64 位体系结构的双字读取指令兼容。</p><p><strong>栈帧的蓝色部分，即局部数据存储部分</strong>。它用来存储函数的局部变量。函数必须为此区域的所有局部变量保留足够的存储空间，包括需要在函数调用前后保留的任何临时寄存器（t0 到 t9）值的空间。</p><h3 id="Leaf-Nonleaf-Subroutine"><a href="#Leaf-Nonleaf-Subroutine" class="headerlink" title="Leaf &amp; Nonleaf Subroutine"></a>Leaf &amp; Nonleaf Subroutine</h3><p>并不是每个函数都需要其栈帧中描述的每个部分。一般的规则是，如果程序不需要其中的一个部分，那么它可以从其栈帧中省略该部分。为了明确这一点，可以区分 3 个不同类别的函数：</p><h4 id="简单叶函数（Simple-Leaf）"><a href="#简单叶函数（Simple-Leaf）" class="headerlink" title="简单叶函数（Simple Leaf）"></a>简单叶函数（Simple Leaf）</h4><p>不调用任何其他子例程，不使用栈上的任何内存空间（因为其不需要内存来保存局部变量或寄存器的值）。这样的函数不需要栈帧，也不需要更改 sp。</p><h4 id="有局部数据的叶函数（Leaf-with-Data）"><a href="#有局部数据的叶函数（Leaf-with-Data）" class="headerlink" title="有局部数据的叶函数（Leaf with Data）"></a>有局部数据的叶函数（Leaf with Data）</h4><p>需要栈空间的叶函数（但不需要、不调用任何其他子例程），其栈帧可用于本地变量或寄存器的值的保存。这样的函数被调用后应当压栈（栈帧大小应该是 8 的倍数）。但是，ra 并不用保存在栈帧中。</p><h4 id="非叶函数（Nonleaf）"><a href="#非叶函数（Nonleaf）" class="headerlink" title="非叶函数（Nonleaf）"></a>非叶函数（Nonleaf）</h4><p>函数内调用了其他函数。一个非叶函数的栈帧包含了上一节所述的大部分结构。</p><h2 id="MIPS-Directives-Macro"><a href="#MIPS-Directives-Macro" class="headerlink" title="MIPS Directives &amp; Macro"></a>MIPS Directives &amp; Macro</h2><h3 id="byte、-half、-word、-ascii、-asciiz"><a href="#byte、-half、-word、-ascii、-asciiz" class="headerlink" title=".byte、.half、.word、.ascii、.asciiz"></a><code>.byte</code>、<code>.half</code>、<code>.word</code>、<code>.ascii</code>、<code>.asciiz</code></h3><p>这类在计组中常见的 directives，别对应着不同数据的类型。</p><h3 id="align"><a href="#align" class="headerlink" title=".align"></a><code>.align</code></h3><p><code>.align</code> 的作用是“使下面的数据进行地址对齐”，下面这段代码使得下面大小为一个字的变量 <code>var</code> 按 4 字节进行对齐（参数 �<em>x</em> 代表以 2�2<em>x</em> 字节对齐）</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">.<span class="hljs-keyword">align</span> <span class="hljs-number">2</span> # <span class="hljs-keyword">align</span> to <span class="hljs-number">4</span>-<span class="hljs-keyword">byte</span> boundary (<span class="hljs-number">2</span>^<span class="hljs-number">2</span>)<br>var: .word <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>该指令允许程序员通过指定一个零对齐，来覆盖<code>.half</code>、<code>.word</code>等的自动对齐特性。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.half</span> 3<br><span class="hljs-string">.align</span> 0 <span class="hljs-comment"># 关闭自动对齐</span><br><span class="hljs-string">.word</span> 100 <span class="hljs-comment"># 使得 word 紧贴着 half</span><br></code></pre></td></tr></table></figure><h3 id="globl、-extern"><a href="#globl、-extern" class="headerlink" title=".globl、.extern"></a><code>.globl</code>、<code>.extern</code></h3><p>在计组中的写的汇编程序往往只有一个文件。但在操作系统课中，存在跨文件的情况，例如跨文件调用函数。</p><ul><li><code>.globl</code>：将符号定义为具有对其他模块可见的全局符号</li><li><code>.extern</code>：要对另一个模块中的全局符号的引用（即外部符号），需要注意的是所有对标签引用都会自动被认为是在引用全局符号，所以我们在对另一模块中的全局标签引用时，没有必要添加 <code>.extern</code>（但对另一模块中的全局变量引用时，需要添加<code>.extern</code>）</li></ul><p>此后在链接时，链接器要将各个目标文件的内容“合为一体”，通过上述方式标记的符号就可以被跨文件引用。</p><p>例如，在未来课程设计的 <code>asm.h</code> 头文件中，我们定义了如下宏：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define FEXPORT(symbol)         \   # 使symbol代指的函数对其他模块可见</span><br>    .globl symbol;              <span class="hljs-string">\</span>   <span class="hljs-comment"># 使标签对链接器可见，使得其它文件中可以调用我们使用宏定义声明的函数。</span><br>    .type symbol, @function;    <span class="hljs-string">\</span><br>    symbol:<br></code></pre></td></tr></table></figure><p>在未来内核实验的 <code>genex.S</code> 汇编文件中，我们通过该宏声明了一个全局函数 <code>ret_from_exception</code>（你可以忽略函数中的内容）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">FEXPORT</span><span class="hljs-params">(ret_from_exception)</span></span><br>    <span class="hljs-comment">/* Do Something */</span><br></code></pre></td></tr></table></figure><p>此时我们可以在未来内核实验的另一文件 <code>env_asm.S</code> 中，直接调用该函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">.text<br><span class="hljs-constructor">LEAF(<span class="hljs-params">env_pop_tf</span>)</span><br>    <span class="hljs-comment">/* Do Something */</span><br>    j       ret_from_exception # 直接调用该函数，默认ret_from_exception为全局标签，无需.extern<br><span class="hljs-constructor">END(<span class="hljs-params">env_pop_tf</span>)</span><br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title=".set"></a><code>.set</code></h3><p>设置汇编器的工作方式。默认情况下，汇编器会尝试通过重新排列指令，来填充分支指令和存取指令造成的空闲时间。了解即可。</p><ul><li><code>.set noreorder</code> 和 <code>.set reorder</code>：告知汇编器是否重新对指令进行顺序进行排序。reorder 模式下汇编器会自动调度指令至延迟槽，noreorder 模式下需要手动填充延迟槽。</li><li><code>.set at</code> 和 <code>.set noat</code>：at 模式下，1 号寄存器（$at）为汇编器保留用于实现扩展指令；noat 模式下，汇编器不会使用 1 号寄存器。</li></ul><h3 id="LEAF、NESTED、END-三个宏"><a href="#LEAF、NESTED、END-三个宏" class="headerlink" title="LEAF、NESTED、END 三个宏"></a><code>LEAF</code>、<code>NESTED</code>、<code>END</code> 三个宏</h3><p>在操作系统实验中，我们将常常会遇到三个和函数有关的宏，是我们人为定义的。</p><h4 id="LEAF"><a href="#LEAF" class="headerlink" title="LEAF"></a><code>LEAF</code></h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">#<span class="hljs-keyword">define</span> LEAF(symbol)                        \<br>    .globl  symbol<span class="hljs-comment">;                         \</span><br>    .<span class="hljs-keyword">align</span>  <span class="hljs-number">2</span><span class="hljs-comment">;                              \</span><br>    .<span class="hljs-keyword">type</span>   symbol<span class="hljs-punctuation">,</span><span class="hljs-title">@function</span><span class="hljs-comment">;               \</span><br>    .ent    symbol<span class="hljs-comment">;                         \</span><br><span class="hljs-symbol">    symbol:</span>                                 \<br>    .frame  sp<span class="hljs-punctuation">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span>ra<br></code></pre></td></tr></table></figure><ul><li>第一行是对 <code>LEAF</code> 宏的定义，后面括号中的 <code>symbol</code> 类似于函数的参数，在宏定义 中的作用类似，编译时在宏中会将 <code>symbol</code> 替换为实际传入的文本，也即我们的函数名。</li><li>第二行中，<code>.globl</code> 的作用是“使标签对链接器可见”，这样即使在其它文件中也可以引用到 <code>symbol</code> 标签，<strong>从而使得其它文件中可以调用我们使用宏定义声明的函数</strong>。</li><li>第三行中，<code>.align 2</code> 的作用是“使下面的数据进行地址对齐”，这一行语句使得下面的 <code>symbol</code> 标签按 4 Byte 进行对齐，<strong>从而使得我们可以使用 <code>jal</code> 指令跳转到这个函数</strong>（末尾拼接两位 0）。</li><li>第四行中，<code>.type</code> 的作用是设置 <code>symbol</code> 标签的类别，在这里我们设置了 <code>symbol</code> 标签为函数标签。</li><li>第五行中，<code>.ent</code> 的作用是标记每个函数的开头，需要与 <code>.end</code> 配对使用。这些标记使得可以在 Debug 时查看调用链</li></ul><p><code>LEAF</code>宏在使用时, 我们可以这样用，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LEAF</span><span class="hljs-params">(msyscall)</span></span><br>    <span class="hljs-comment">// Just use &#x27;syscall&#x27; instruction and return.</span><br>    syscall<br>    jr      ra<br><span class="hljs-function"><span class="hljs-title">END</span><span class="hljs-params">(msyscall)</span></span><br></code></pre></td></tr></table></figure><h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a><code>NESTED</code></h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">#<span class="hljs-keyword">define</span> NESTED(symbol<span class="hljs-punctuation">,</span> framesize<span class="hljs-punctuation">,</span> rpc)      \<br>    .globl  symbol<span class="hljs-comment">;                         \</span><br>    .<span class="hljs-keyword">align</span>  <span class="hljs-number">2</span><span class="hljs-comment">;                              \</span><br>    .<span class="hljs-keyword">type</span>   symbol<span class="hljs-punctuation">,</span><span class="hljs-title">@function</span><span class="hljs-comment">;               \</span><br>    .ent    symbol<span class="hljs-punctuation">,</span><span class="hljs-number">0</span><span class="hljs-comment">;                       \</span><br><span class="hljs-symbol">    symbol:</span>                                 \<br>    .frame  sp<span class="hljs-punctuation">,</span> framesize<span class="hljs-punctuation">,</span> rpc<br></code></pre></td></tr></table></figure><p>通过对比，我们可以发现 <code>LEAF</code> 宏和 <code>NESTED</code> 宏的区别就在于 <strong><code>LEAF</code> 宏定义的函数在被调用时没有分配栈帧的空间记录自己的“运行状态”，<code>NESTED</code> 宏在被调用时分配了栈帧的空间用于记录自己的“运行状态”</strong>。</p><p><code>NESTED</code> 宏在使用时, 我们可以这样用，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">NESTED(handle_int, TF_SIZE, <span class="hljs-built_in">zero</span>)<br>    <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_CAUSE<br>    <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t2</span>, CP0_STATUS<br>    <span class="hljs-keyword">and </span>    <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t2</span><br>    <span class="hljs-keyword">andi </span>   <span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t0</span>, STATUS_IM7<br>    <span class="hljs-keyword">bnez </span>   <span class="hljs-built_in">t1</span>, timer_irq<br><span class="hljs-symbol">timer_irq:</span><br>    li      <span class="hljs-built_in">a0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">j </span>      <span class="hljs-keyword">schedule</span><br><span class="hljs-keyword"></span>END(handle_int)<br></code></pre></td></tr></table></figure><h4 id="END"><a href="#END" class="headerlink" title="END"></a><code>END</code></h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">#define <span class="hljs-keyword">END</span>(<span class="hljs-function"><span class="hljs-keyword">function</span></span>)                       \<br>    .<span class="hljs-keyword">end</span>    <span class="hljs-function"><span class="hljs-keyword">function</span></span>;                       \<br>    .<span class="hljs-built_in">size</span>   <span class="hljs-function"><span class="hljs-keyword">function</span></span>,.-<span class="hljs-function"><span class="hljs-keyword">function</span></span><br></code></pre></td></tr></table></figure><p>第一行是对 <code>END</code> 宏的定义，与上面 <code>LEAF</code> 与 <code>NESTED</code> 类似。</p><p>第二行的 <code>.end</code> 是为了与先前 <code>LEAF</code> 或 <code>NESTED</code> 声明中的 <code>.ent</code> 配对，标记了 <code>symbol</code> 函数的结束。</p><p>第三行的 <code>.size</code> 是标记了 <code>function</code> 符号占用的存储空间大小，将 <code>function</code> 符号占用的空间大小设置为 <code>.-function</code>，<code>.</code> 代表了当前地址，当前位置的地址减去 <code>function</code> 标签处的地址即可计算出符号占用的空间大小。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS假期预习（一）——Linux，Git与Shell脚本</title>
    <link href="/2024/02/23/OSPre1/"/>
    <url>/2024/02/23/OSPre1/</url>
    
    <content type="html"><![CDATA[<h1 id="OS假期预习（一）——Linux，Git与Shell脚本"><a href="#OS假期预习（一）——Linux，Git与Shell脚本" class="headerlink" title="OS假期预习（一）——Linux，Git与Shell脚本"></a>OS假期预习（一）——Linux，Git与Shell脚本</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Linux是什么？"><a href="#Linux是什么？" class="headerlink" title="Linux是什么？"></a>Linux是什么？</h3><p>Linux 操作系统是基于 <strong>Linux 内核</strong>的开源操作系统，Linux 内核在 1991 年由 Linus Torvalds 首次发布，在庞大的社区下不断完善和升级。Linux 系统通常制作成 <strong>Linux 发行版</strong>供用户使用。Linux 发行版包括 Linux 内核，以及相关的软件和库。这些软件和库大多数都是由 <strong>GNU 项目</strong>提供的。</p><p>GNU（GNU is Not Unix 的递归缩写），是一个广泛的自由软件集合，为 Linux 操作系统提供了大量的开源软件。这些开源软件有一些非常出名，可以说是家喻户晓：比如的编译器套件 GCC 和调试器 GDB，编程语言 Pascal，用于科学计算的 R 语言，很多人以之为信仰的 Emacs 编辑器等，都是 GNU 项目的产物。</p><p>实验课程使用的 Linux 发行版叫做 Ubuntu，是目前最为流行的 Linux 发行版之一。</p><h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>使用命令行界面（Command Line Interface，CLI），我们会用一行一行的命令来告诉操作系统我们需要进行什么操作，操作系统也会把执行的结果输出到屏幕上。</p><p>Shell 直译为“壳”，也就是操作系统的“外壳”（相对于操作系统“内核”而言），即用于访问操作系统服务的用户界面。Shell 可以分为命令行界面（CLI Shell）和图形用户界面（GUI Shell，GUI 是 Graphical User Interface 的简称）。我们经常使用的 Windows，macOS，都是 GUI Shell，很多 Linux 发行版也会提供 GUI Shell，但服务器上运行的 Linux 一般都是 CLI Shell。</p><p>使用CLI Shell的主要原因在于：</p><ul><li>节约资源。在很多资源有限的小型服务器或单片机设备上，内存和 CPU 等资源是十分受限的。运行 GUI Shell 本身就是一笔不小的资源开销，这会大大增加系统性能的负担。</li><li>高效自动化操作。举个例子：如果你希望把一个目录下的一千多个文件按序号重命名，在 GUI Shell 下可能很难实现，需要一个一个重命名。但在 CLI Shell 下，你就可以写一个脚本文件，利用循环高效完成这些操作。对于很多复杂操作，GUI 可能不会提供相应的操作方式，但命令行可以完成相当复杂的操作逻辑。</li><li>精准操作。命令行本质上是对操作和返回结果的文本描述。针对一些复杂的操作，我们只需要将命令的集合打包成一个脚本文件，就可以在以后精准复现这些操作。这种性质在传播经验时也非常奏效：相比于手把手教你在图形界面上点来点去，不如直接发你一个命令脚本，你就立刻能够知道每一步都在做什么，而且可以直接运行复现。</li></ul><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>在命令行界面中，用户通过一行一行命令向操作系统发出指示，从而达到人机交互的目的。在 Linux 操作系统中，命令的一般格式为：<code>命令名 [选项] [参数] ...</code>，方括号的意思是可选，意为可以没有，也可以有一个或多个。</p><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><div class="note note-success">            <p>cd 用法：</p><p>cd [选项] 目录 </p><p>作用：切换到某个目录（Change Directory）。</p>          </div><p>终端底部出现了新的一行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cd /<br>git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:/</span>$<br></code></pre></td></tr></table></figure><p>这一行大致理解为：我们进入了 <code>/</code> 这个目录。那么 <code>/</code> 这个目录是什么，上一行的 <code>~</code> 又是什么，</p><p>Linux 文件系统的最顶层是根目录，<code>/</code> 表示的就是根目录，Linux 一切的文件都存放在根目录下。我们刚刚就进行了“切换到根目录”的操作。根目录下放置所有的二级目录，包括 Linux 内核启动需要的 <code>/boot</code> 目录，系统配置文件的 <code>/etc</code> 目录，存放普通用户主目录的目录 <code>/home</code>，系统管理员的用户（即 root 用户）主目录 <code>/root</code>，用户系统资源存放的目录 <code>/usr</code> 等等……如果对每个目录都存放什么内容感兴趣，可以利用搜索引擎搜索，这里就不赘述了。</p><p><code>~</code> 则是当前用户主目录的简写，你可以使用 <code>cd ~</code> 回到当前用户主目录。对于一般用户，主目录是 <code>/home/用户名</code>，对于 root 用户，主目录则是 <code>/root</code>。<code>$</code> 代表当前的用户是普通用户；如果当前用户是系统管理员（root）用户，则此处会显示 <code>#</code>。在下文中，我们统一用 <code>$ xxx</code> 表示你应当在终端中输入命令 <code>xxx</code>，这里 <code>$</code> 是终端中显示的符号。</p><p>假设我们目前处于根目录（即 <code>/</code> 目录），接下来我们试着进入 <code>/etc</code> 这个目录。很容易想到命令是 <code>cd /etc</code>，但输入 <code>cd etc</code> 也能等效地完成任务。可以看出，<code>cd</code> 命令是支持<strong>相对路径</strong>的。当我们输入 <code>cd etc</code> 时，系统会在当前的目录，也就是 <code>/</code> 中寻找 <code>etc</code> 这个目录并切换到那里。</p><p>那我们如何返回上一级目录呢？在 Linux 系统中，<code>.</code> 表示当前目录，<code>..</code> 表示上一级目录，所以我们输入 <code>cd ..</code> 就可以返回到上一级目录了。如果输入 <code>cd .</code>，就代表切换到当前所在的目录，也就是什么都不做。还有一个特别的小技巧：输入 <code>cd -</code> 可以跳转到上一次访问的目录。</p><p>查看目录下的文件，可以使用<code>ls</code>命令。</p><div class="note note-success">            <p>ls<br>用法：ls [选项] [目录]<br>作用：列出目录中的文件。若参数“目录”未给出，则列出当前目录中的文件。<br>选项（常用）：<br>-a              显示隐藏的文件<br>-l              每行只列出一个文件</p>          </div><p>创建一个新的目录，可以使用<code>mkdir</code>命令。</p><div class="note note-success">            <p>mkdir<br>用法：mkdir [选项] 目录<br>作用：创建一个新目录。</p>          </div><p>使用 <code>cd ~</code> 命令回到用户的主目录。这时输入 <code>mkdir newdir</code> 就可以在主目录下创建一个新的目录 <code>newdir</code>。输入 <code>cd newdir</code> 就可以进入刚刚创建的目录。可以注意到，终端已经对当前目录做出了提示，变成了：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:~/newdir</span>$<br></code></pre></td></tr></table></figure><p>我们可以输入 <code>pwd</code> 命令，查看当前目录的绝对路径。</p><div class="note note-success">            <p>pwd<br>用法：pwd [选项]<br>作用：输出当前目录的绝对路径。</p>          </div><p>结果如下所示，这也和刚才提到的 <code>~</code> 的概念相互印证。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:~/newdir</span><span class="hljs-variable">$ </span>pwd<br>/home/git/newdir<br></code></pre></td></tr></table></figure><p>与 <code>mkdir</code> 对应，我们还有删除<strong>空</strong>目录的命令 <code>rmdir</code>，请注意，这个命令只能删除空目录。</p><div class="note note-success">            <p>rmdir<br>用法：rmdir [选项] 目录<br>作用：删除一个空的目录。请注意，只有空的目录才能被删除。</p>          </div><p>退回到用户主目录下，我们可以删除 <code>newdir</code> 这个目录。</p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>在 Linux 的哲学下<strong>一切皆文件</strong>，包括目录、设备等等全部是以文件方式存在于操作系统中的。上一节之所以叫做”目录操作“，是因为所介绍的几个命令是“目录”这种文件独有的命令。这一节叫做“文件操作”，介绍的命令是一般文件（包括目录）都可以操作的命令。例如复制和删除操作，其对象可以是几乎所有文件，也包含目录。</p><p>我们首先介绍如何利用 <code>touch</code> 命令创建一个新的空文件。</p><div class="note note-success">            <p>touch<br>用法：touch [选项] 文件名<br>作用：当文件存在时更新文件的时间戳，当文件不存在时创建新文件。</p>          </div><p>我们主要利用的是后者（创建新文件）的作用。进入用户主目录，输入 <code>touch helloworld.c</code>，就可以创建一个叫做 <code>helloworld.c</code> 的文件。</p><p>那么如何删除一个文件，或者删除一个非空的目录呢？</p><div class="note note-success">            <p>rm<br>用法：rm [选项] 文件<br>作用：删除文件。<br>选项（常用）：<br>-r              递归删除目录及其内容，删除非空目录必须有此选项，否则无法删除。<br>-f              强制删除，不提示用户确认，忽略不存在的目录。<br>-i              逐一提示用户确认每个将要被删除的文件。</p>          </div><blockquote><p>Tips：<code>rm -rf</code> 是十分危险的命令（尤其在 root 用户下），非必要不使用 <code>rm -rf</code> 命令，在执行之前需要再三确认。root 用户具有至高无上的权限，在该用户下执行 <code>rm -rf /</code> 可以删除一切文件，包括 Linux 本身，从而导致系统被毁灭。</p></blockquote><p>常用的文件操作除了新建文件和删除文件，还有复制和移动文件。</p><div class="note note-success">            <p>cp<br>用法：cp [选项] 源文件 目标路径<br>作用：将源文件（也可以是目录）复制为目标路径对应的文件（如果目标路径是文件）或复制到目标路径（如果目标路径是目录）。<br>选项（常用）：<br>-r              递归复制目录及其子目录内的所有内容。</p>          </div><blockquote><p>递归复制指的是当要复制的目录下存在子目录，且子目录中存在子目录或文件的时候，将逐一复制它们。windows的复制默认是递归复制的。</p><p>如果不递归复制，结果得到的目录只包含空的子目录，其子目录下的内容将不会复制。</p></blockquote><p>我们在用户主目录中使用命令 <code>touch test.txt</code> 来创建一个名为 <code>test.txt</code> 的文件，然后使用 <code>mkdir dir</code> 创建一个名为 <code>dir</code> 的目录。接下来使用 <code>cp test.txt dir/</code> 来进行复制操作。我们先用前面提到过的 <code>ls</code> 命令看看当前目录下的 <code>test.txt</code> 是否还存在，然后切换到 <code>dir</code> 目录，使用 <code>ls</code> 命令，可以看到 <code>test.txt</code> 这个文件。</p><div class="note note-success">            <p>mv<br>用法：mv [选项] 源文件 目标路径<br>作用：将源文件（也可以是目录）移动为目标路径对应的文件（如果目标路径是文件）或移动到目标路径（如果目标路径是目录）。<br>选项（常用）：<br>-r              递归移动目录及其子目录内的所有内容。</p>          </div><p><code>mv</code> 命令的另外一个作用就是重命名文件。原理上很好理解，也就是把一个文件以不同的名字移动到当前目录下，这和重命名是等价的。举个例子，我们在 <code>dir</code> 下使用 <code>mv test.txt test2.txt</code> 就可以把 <code>test.txt</code> 重命名为 <code>test2.txt</code> 了。</p><p>对于两个纯文本文件来说，我们还可以使用 <code>diff</code> 命令进行比较的操作。</p><div class="note note-success">            <p>diff<br>用法：diff [选项] 文件1 文件2<br>选项（常用）：<br>-b              不检查空白字符的不同。<br>-B              不检查空行。<br>-q              仅显示有无差异，不显示详细信息。</p>          </div><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>在 Windows 或 macOS 操作系统中，文件管理器提供了搜索的功能，以便我们查找文件。那么在 Linux 下如何进行查找操作呢？我们引入两个命令：<code>find</code> 和 <code>grep</code>。</p><div class="note note-success">            <p>find<br>用法：find [路径] &lt;选项&gt;<br>作用：在给定路径下递归地查找文件，输出符合要求的文件的路径。如果没有给定路径，则在当前目录下查找。<br>选项（常用）：<br>-name &lt;文件名&gt;             指定需要查找的文件名。</p>          </div><p>使用 <code>find</code> 命令并加上 <code>-name</code> 选项可以在当前目录下递归地查找符合参数所示文件名的文件，并将文件的路径输出至屏幕上。</p><p><code>grep</code> 命令则有所不同。<code>find</code> 是根据文件的属性（文件名、修改日期等）查找文件，而 <code>grep</code> 则是匹配文件内的内容查找文件和文件中的匹配位置。</p><div class="note note-success">            <p>grep<br>用法：grep [选项] PATTERN FILE<br>（PATTERN是匹配字符串，FILE是文件或目录的路径）<br>作用：输出匹配PATTERN的文件和相关的行。<br>选项（常用）：<br>-a              不忽略二进制数据进行搜索。<br>-i              忽略大小写差异。<br>-r              从目录中递归查找。<br>-n              显示行号。</p>          </div><p>当你需要在整个项目目录中查找某个函数名、变量名等特定文本的时候，<code>grep</code> 将是你手头一个强有力的工具。</p><p>前面讲到 <code>ls</code> 命令的功能是列出文件。在我们的 Linux 系统中有一个比 <code>ls</code> 更“高级”的命令，叫做 <code>tree</code>，它可以直接输出一个目录下的文件树。这个命令一般不是 Linux 发行版预装的，但我们已经为你安装好了，直接使用即可。</p><div class="note note-success">            <p>tree<br>用法: tree [选项] [目录名]<br>选项(常用)：<br>-a              列出全部文件（包含隐藏文件）。<br>-d              只列出目录。</p>          </div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>连接终端后，我们所处的目录是 <code>~</code> 目录，也就是用户主目录。我们可以使用 <code>ls</code> 命令列出一个目录下都有什么内容，可以用 <code>cd</code> 进入到一个目录（输入绝对路径和相对路径都可以），可以用 <code>pwd</code> 显示当前目录的绝对路径。我们可以用 <code>mkdir</code> 创建一个目录，用 <code>rmdir</code> 删除一个空目录。我们可以使用 <code>touch</code> 新建文件，<code>rm</code> 删除文件，<code>cp</code> 复制文件，<code>mv</code> 移动或者重命名文件。</p><p>如果想要查看一个命令的详尽说明，就需要使用 Linux 下的帮助命令——<code>man</code> 命令，通过 <code>man</code> 命令可以查看 Linux 中的命令帮助、配置文件帮助和编程帮助等信息。</p><div class="note note-success">            <p>man<br>用法：man [选项] 命令<br>作用：查看命令的详细说明手册。</p>          </div><h3 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h3><ul><li>Ctrl+C 终止当前程序的执行。当程序卡死或者你不想让它继续执行了，可以输入 Ctrl+C 终止程序。请注意，Ctrl+C 在 Windows 中是复制的意思，但在 Linux CLI 的环境下就是结束进程的意思。所以在使用终端模拟器（比如使用浏览器或 XShell 等）连接终端时，复制终端中显示的内容时记得不要按 Ctrl+C，而是老老实实右键复制，以免误杀进程。</li><li>Ctrl+Z 挂起当前程序。暂停程序，放到后台。Ctrl+Z 挂起程序后会显示该程序挂起编号，若想要恢复该程序可以使用 <code>fg [job_spec]</code>即可，<code>job_spec</code> 即为挂起编号，不输入时默认为最近挂起进程。</li><li>Ctrl+D 终止输入（若正在使用 Shell，则退出当前 Shell）。在标准输入中输入 Ctrl+D 也意味着输入了一个 EOF。</li><li>Ctrl+L 清屏。相当于命令 <code>clear</code>。</li></ul><p>特别提示，Ctrl+S 在终端中的作用是暂停该终端。有的同学在进行编辑的时候会误触此组合键导致终端“卡死”，此时使用 Ctrl+Q 组合键即可让终端继续运行。</p><blockquote><p>Tips：在多数 Shell 中，四个方向键也是有各自特定的功能的：Left 和 Right 可以控制光标的位置，Up 和 Down 可以切换最近使用过的命令。</p></blockquote><h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><p>下面介绍的若干 Linux 下的实用工具，它们都是在 Linux 下开发工作中非常重要的工具，可以说是不可或缺。</p><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>GCC（GNU Compiler Collection，GNU 编译器套件）包含了著名的 C 语言编译器 gcc（GNU project C and C++ compiler）。</p><div class="note note-success">            <p>gcc<br>用法：gcc [选项] 源代码文件<br>作用：编译源代码文件。</p>          </div><p>首先我们在用户主目录下创建一个文件 <code>hello.c</code>，使用 Vim 打开这个文件。进入编辑模式，输入以下内容，保存退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来在当前目录下使用 <code>gcc</code> 命令进行编译。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello.c<br></code></pre></td></tr></table></figure><p>此时我们没有看到相关输出，说明编译过程成功完成。在当前目录下出现了 <code>a.out</code> 这个文件（这个文件名是 gcc 编译器默认的可执行程序的文件名）。</p><p>既然 gcc 为我们编译出了一个可执行文件，那么我们就可以执行这个文件。执行 <code>a.out</code> 的命令是：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>我们知道，<code>./</code> 是“当前目录下”的意思。为什么要加上一个 <code>./</code> 呢，难道不是多此一举吗？实际上在 Linux 中，<code>./</code> 表示被执行的文件在当前目录，Linux 会在当前目录中查找可执行文件。如果不加 <code>./</code>，那么 Linux 就会在“系统 <code>PATH</code>”中寻找。然而 <code>a.out</code> 并不在系统 <code>PATH</code> 中，所以 Shell 就会报错<code>a.out: command not found</code>。</p><blockquote><p>系统 <code>PATH</code>：<code>PATH</code> 是一个系统变量，记录了若干目录。如果待运行的程序不在当前目录，操作系统便可以去依次搜索 <code>PATH</code> 变量中记录的目录，如果在这些目录中找到待运行的程序，操作系统便可以运行这个程序。</p></blockquote><p>运行 <code>a.out</code> 之后，我们就可以看到终端输出了 <code>Hello, world!</code>。</p><h3 id="make-Makefile"><a href="#make-Makefile" class="headerlink" title="make &amp; Makefile"></a>make &amp; Makefile</h3><p>GNU 项目中有一个叫做“make”的工具，是最常用的 C 语言项目构建工具。我们都知道，“make”是制作的意思，而 make 构建工具的作用本质上就是“制作出一个文件”。当我们开发了一个较大的项目，make 工具就可以将这些文件编译链接成可执行文件。当然 make 工具进行编译和链接的操作是需要人工指导的，这个“指导文件”就是 Makefile。make 工具可以根据时间戳自动判断项目的哪些部分是需要重新编译的，每次只重新编译必要的部分。make 工具是基于 Shell 命令运行的，所以只要项目的编译器可以通过 Shell 命令调用，make 都可以对项目进行构建。</p><p>为了能够清晰地了解 make 的基本概念，我们来使用 Makefile 指导编译一个最简单的项目——也就是刚刚的 Hello World 项目。</p><p>不使用 make 工具，我们可以使用下面的命令来对 hello.c 进行编译：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -o hello hello.c<br></code></pre></td></tr></table></figure><p>如果使用 make 工具来构建，我们就需要在当前目录下创建并编辑 Makefile 文件（文件名就叫做 <code>Makefile</code>）。Makefile 的基本格式如下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target</span>: dependencies<br>    <span class="hljs-keyword">command</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">command</span> <span class="hljs-number">2</span><br>    ...<br>    <span class="hljs-keyword">command</span> n<br></code></pre></td></tr></table></figure><p>其中，<code>target</code> 是我们构建（Build）的目标，可以是真的目标文件、可执行文件，也可以是一个标签（详见参考教程）。而 <code>dependencies</code> 是构建该目标所需的其它文件或其他目标。之后是构建出该目标所需执行的命令。有一点尤为需要注意：每一个命令（command）之前必须有一个制表符（tab）。这里必须使用制表符而不能是空格，否则 make 会报错。</p><p>我们通过在 Makefile 中书写这些显式规则来告诉 make 工具文件间的依赖关系：如果想要构建 <code>target</code>，那么首先要准备好 <code>dependencies</code>，接着执行 <code>command</code> 中的命令，以得到 <code>target</code>。在书写完恰当的规则之后，只需要在 shell 中输入 <code>make target</code>（<code>target</code> 是目标名），即可执行相应的命令、生成相应的目标。</p><p>因此，我们的简易的 Makefile 可以写成如下的样子，之后执行 <code>make hello</code> 或是 <code>make</code>，即可产生 <code>hello</code> 这个可执行文件，使用 <code>./hello</code> 就可以执行它。值得注意的是，当执行 <code>make</code> 指令而不附加其他参数时，默认构建第一个目标。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">all:</span> hello<br><br><span class="hljs-symbol">hello:</span> hello.c<br>    gcc -o hello hello.c<br></code></pre></td></tr></table></figure><h3 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h3><p>ctags 是一个方便代码阅读的工具，我们用到的功能是代码跳转功能。利用 ctags，我们可以在 Vim 下进行更便捷的开发。</p><p>在使用之前我们需要修改 Vim 的配置文件，使其支持 ctags 的相关功能。打开 <code>~/.vimrc</code> 文件（如果没有则新建），添加下面两行并保存。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">tags</span>=tags<br><span class="hljs-built_in">set</span> autochdir<br></code></pre></td></tr></table></figure><p>我们修改 <code>hello.c</code> 文件，如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ctags_test.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span> p;<br>    p.a = <span class="hljs-number">1</span>;<br>    p.b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建一个文件 <code>ctags_test.h</code>，输入如下内容：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct Pair &#123;<br>    int a<span class="hljs-comment">;</span><br>    int b<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我们保存并退出 Vim，执行命令 <code>ctags -R *</code>，就会发现在该目录下出现了新的文件 <code>tags</code> ——这是 ctags 为我们创建的符号名索引文件。此时我们就能使用 ctags 的功能了。</p><p>使用 Vim 打开 <code>hello.c</code> 文件，将光标移动到 <code>a</code> 或 <code>b</code> 上，按下 Ctrl+]，就可以跳转到结构体中 <code>a</code>或 <code>b</code> 的定义处。再按下 Ctrl+O就可以返回跳转前的位置。</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>对于我们来说，Linux 终端就是我们眼前的黑框框。Linux 是一个优秀的多用户多进程操作系统，用户经常需要同时运行多个程序并同时观察它们的输出。然而我们的终端看起来只能同时显示一个程序，并不能同时观察多个程序的运行。一个简单的解决方案就是同时打开多个终端，让一个用户同时多次登录 Linux 计算机（Linux 允许这样做）。但这样做有时在窗口切换时会产生麻烦。</p><p>另外还有一个问题：当我们的终端和 Linux 计算机断开连接时，终端前台正在运行的进程会被杀死。所以我们在终端中等待程序运行时就需要一直保持着终端的连接，这对于长时间运行程序的服务器来说是不现实的，运维人员不能总是在前台看着程序不断输出。</p><p>为了解决这两个问题，我们引入“终端复用神器” <strong>tmux</strong>（Terminal multiplexer）。它实现了终端窗口和进程分离，同时也可以在窗口中同时显示多个进程的运行。</p><p>窗格、窗口、会话是 tmux 的三个基本概念，一个会话可以包含多个窗口，一个窗口可以分割为多个窗格。突然断开连接或主动分离（Detach）后 tmux 仍会保持程序的运行，通过重新连接会话可以直接在之前的环境继续工作。</p><p>看到了 tmux 的运行效果，我们立刻会问，如何进入 tmux，实现分屏操作呢？</p><p>我们在 Shell 下直接输入命令 <code>tmux</code>，可以看到终端底部出现一行绿色，这时就已经进入了 tmux 的新会话。tmux 的操作由一系列快捷键组成，下面对重要的快捷键进行介绍。</p><ul><li>Ctrl+B Shift+Num 5（同时按下 Ctrl 和 B，然后松开这两个键，紧接着立刻输入“%”，下面同理），将窗口左右分屏。</li><li>Ctrl+B Shift+’ ，将窗口上下分屏。</li><li>重复以上两个快捷键，可以将目前活动的窗格继续分屏。</li><li>Ctrl+B Up &#x2F; Down &#x2F; Left &#x2F; Right 根据按键方向切换到某个窗格。</li><li>Ctrl+B Space，切换窗格布局（上下变成左右，左右变成上下）。</li><li>Ctrl+B X，关闭当前正在使用的窗格（根据提示按 Y 确认关闭）。</li><li>Ctrl+B D，分离（Detach）当前会话，回到 Shell 的终端环境。此时程序仍然保持在 tmux 会话中的状态。</li></ul><p>当我们使用 Ctrl+B D 分离了会话或者意外断开了连接，我们该如何恢复到之前的会话中呢？</p><p>我们首先使用 <code>tmux ls</code> 命令查看当前都有哪些会话。记住会话名（会话名是冒号左边的内容，默认情况下是一个数字），使用 <code>tmux a -t 会话名</code> 恢复到原来的会话。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h3><p>Git 是一个先进的<strong>版本控制系统</strong>。试想一个几百人同时开发一个大项目的场景：有人想在某个版本进行测试，也有人想要在这个版本的基础上进行新功能的开发而不影响测试人员，还有人想进行另外一个功能的开发……在迭代许多版本之后，代码的管理就变得十分复杂了。复杂主要包括两个方面：时间上的复杂（版本不断更新，新功能出现问题需要回退等等）和空间上的复杂（不同人开发不同的部分）。为了解决这些问题，就出现了版本控制系统。</p><h3 id="三种储存位置"><a href="#三种储存位置" class="headerlink" title="三种储存位置"></a>三种储存位置</h3><p>Git 中的三种储存状态分别是：工作区（Working Directory）、暂存区（Staging Area）和储存库（Repository）。</p><p>一般来说，一个项目在 Git 中是以目录的形式存在的，这个目录包含了<strong>工作区</strong>（<code>.git</code> 子目录之外的内容）和<strong>储存库</strong>（<code>.git</code> 子目录）。工作区可以理解为“目前正在编辑的版本”，储存库储存在一个隐藏目录 <code>.git</code> 中（因为它以 <code>.</code> 开头，所以是隐藏的），用来存放提交过的所有版本的内容及其联系。<strong>暂存区</strong>存放了已经确定修改但尚未提交的文件。暂存区的信息理论上也储存在 <code>.git</code> 目录中，但是在用途上和储存库有区别，因此和储存库的概念区分开来。</p><h3 id="四种储存状态"><a href="#四种储存状态" class="headerlink" title="四种储存状态"></a>四种储存状态</h3><p>一个文件，在 Git 目录中有以下四种状态：</p><ul><li>未跟踪（Untracked）：一个文件在储存库的版本信息中没有被记录过。比如在储存库中新建了一个文件，这个文件现在就是未跟踪的状态；在一个非空目录下使用 <code>git init</code> 来初始化一个空储存库，此时这个目录下的所有文件都处于未跟踪的状态。</li><li>未修改（Unmodified）：一个文件在跟踪之后一直没有改动过，或者改动已经被提交（即工作区的内容和储存库中的内容相同），则处于未修改状态。当我们修改这个文件时，则会使这个文件变成已修改状态。</li><li>已修改（Modified）：一个文件已经被修改（即工作区的内容和储存库中的内容不同），但还没有加入（<code>git add</code>) 到暂存区中。</li><li>已暂存（Staged）：一个文件已被加入暂存区。加入暂存区意味着将一个已修改的文件加入下次提交（<code>git commit</code>）需要存入储存库的文件清单中。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a><code>git init</code></h4><p><code>git init</code> 会自动把当前目录变成一个空的 Git 仓库，这样就可以对当前目录下的内容进行版本管理了。</p><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a><code>git clone</code></h4><p><code>git init</code> 创建一个新的储存库，而 <code>git clone &lt;URL&gt;</code> 则是“克隆”一个已有的储存库到当前目录下。通常我们会从一个互联网地址（即 URL，统一资源定位符）进行克隆，所以一般这种操作可以理解为“下载”。</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h4><p>这个命令可以查看当前分支的状态，以及当前工作区的变动和暂存区的内容，便于我们对工作区的概况进行掌握。</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h4><p>使用这个命令，可以把一个新文件或者已经修改过的文件加入暂存区中。在你完成一部分实验内容之后，可以使用 <code>git add .</code> 将你的所有修改加入暂存区，也可以使用 <code>git add &lt;filename&gt;</code> 来将指定的文件加入暂存区。</p><h4 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a><code>git restore</code></h4><p>我们在修改一个文件之后，可能想要放弃这个修改。当这个文件还没有通过 <code>git add</code> 加入暂存区时，我们可以使用 <code>git restore &lt;filename&gt;</code> 来撤销对这个文件的修改，使其退回到上一个 commit 的状态。如果这个文件已经加入了暂存区，我们可以通过 <code>git restore --staged &lt;filename&gt;</code> 来取消暂存。</p><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h4><p>这个命令涉及到分支的知识，分支的概念在这里不会详细介绍，可以参考 <a href="https://git-scm.com/book/zh/v2">Pro Git</a>。在实验课程中，可能会涉及在各个 Lab 中进行切换。这时使用 <code>git checkout lab&lt;x&gt;</code> 可以切换到相应的分支。</p><p>请注意，在切换时，需要保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）。</p><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h4><p>使用 <code>git commit -m &lt;message&gt;</code> 这个命令将暂存区的修改提交到储存库中。当 message 参数有空格时需要把 message 用引号括起来。在提交时，要求给出一段说明性文字。这段文字可以任意填写，但建议按照提交内容填写，以保证多人协作时的可读性。本实验不会涉及多人协作，所以方便自己开发即可。</p><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><code>git push</code></h4><p>这个命令将本地的 commit 推送到一个远程仓库。在课程实验中，这个命令可以将你的 commit 推送到 GitLab。</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><code>git pull</code></h4><p>这个命令将远程新建的分支下载到本地，并且将远端的更改合并到当前的分支。在利用评测机进行实验分支的初始化之后，可以在开发机中使用这个命令来将新的分支下载到本地。</p><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>所谓 Shell 脚本，其实就是一条一条命令组合起来，放到一个文件中，并且可以直接运行这个文件。</p><p>Shell 脚本和 Windows 批处理文件是十分类似的，只不过在 Linux 下，脚本语言编程是用户的必备技能，也是高效操作所必需的技能；而在 Windows 下的批处理脚本则对于普通用户来说可有可无，因为他们只需操作图形界面就可以完成日常生活中的绝大多数操作。</p><h3 id="Shell脚本的执行"><a href="#Shell脚本的执行" class="headerlink" title="Shell脚本的执行"></a>Shell脚本的执行</h3><p>在 Windows 中，批处理文件的扩展名是 <code>.bat</code>，类似地，在 Linux 中，脚本文件的文件名在最后一般会加上 <code>.sh</code> 后缀。实际上 Linux 中没有扩展名的概念，所以加不加 <code>.sh</code> 对运行是没有影响的。但为了区分于其他文件，一般约定脚本文件的文件名都以 <code>.sh</code> 结尾。</p><p>执行 Shell 脚本很容易：<code>./文件名</code>（文件名包含 <code>.sh</code>，因为这是文件名的一部分。再次强调，Linux 中没有扩展名的概念）即可运行。</p><p>需要注意的是，被执行的脚本文件必须有“执行”权限。在 Linux 系统中，每个文件对于拥有者、用户组和其他用户都分别有“读”、“写”、“执行”的权限。我们使用 <code>touch</code> 命令创建的文件默认是没有“执行”权限的，需要手动添加。若发现 Shell 脚本执行时出现了“Permission denied”的错误，多半是因为没有添加“执行”权限。我们可以使用下面的命令手动添加“执行”权限。</p><div class="note note-success">            <p>chmod +x 文件名</p>          </div><p>后文中提到的 Shell 语法均指的是 Bash Shell 语法。</p><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world!"></a>Hello, world!</h4><p>首先用 <code>touch</code> 命令创建一个新文件 <code>hello.sh</code>，使用 Vim 输入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#My first Shell script!</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><p>保存退出，修改权限，运行。我们可以看到终端输出了 <code>Hello, world!</code>。下面对程序进行逐行解释。</p><p>第一行：指定脚本的默认运行程序（即解释器）。在这里指定为 bash，这是我们最常使用的脚本运行程序。</p><blockquote><p>其中，<code>#!</code> 出现在脚本文件的第一行的前两个字符，被称为 Shebang。当文件中存在 Shebang 的情况下，程序加载器会分析 Shebang 后面的内容，并且将这些内容作为脚本文件的解释器。</p></blockquote><p>第二行：注释。注释以 <code>#</code> 开头。</p><p>第三行：输出。将 <code>echo</code> 命令后面的字符串输出。像本章开头所说的，Shell 脚本是命令和组合，其实 <code>echo</code> 也是一个命令。不信你把这一行在终端中直接运行一下，看看发生了什么，也可以使用 <code>man</code> 命令查询一下 <code>echo</code> 命令是做什么的。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>一般的脚本语言都涉及到变量的操作，那么 Shell 脚本中是如何定义和使用变量的呢？</p><p>Shell 是弱类型语言，定义变量时无需指定类型。定义变量（变量名为 <code>var_name</code>，值为 <code>value</code>）的方式是：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">var_name</span>=value<br></code></pre></td></tr></table></figure><p>请注意，等号两边<strong>不允许有空格</strong>。</p><p>使用 <code>$var_name</code> 可以获取变量的值。在使用时，建议在变量名的两端加一个花括号（形如 <code>$&#123;var_name&#125;</code>），以帮助解释器识别变量的边界，避免歧义。</p><p>下面我们用定义和使用变量的形式，重新编写上面的 Hello, world 程序，将 <code>hello.sh</code> 的内容修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>str=&quot;Hello, world!&quot;<br>echo $str<br></code></pre></td></tr></table></figure><p>保存退出，运行，达到了同样的效果。</p><h4 id="脚本参数——特殊的变量"><a href="#脚本参数——特殊的变量" class="headerlink" title="脚本参数——特殊的变量"></a>脚本参数——特殊的变量</h4><p>之前学习命令的时候，我们发现很多命令都需要传入参数和选项。在 Shell 脚本中，传递参数是完全支持的，这也大大提高了 Shell 脚本的通用性和便捷性。下面我们简单讲解如何传递参数。</p><p>参数在 Shell 脚本中体现为特殊的变量。在执行语句中，参数以空格分隔，每一个参数在脚本中都是一个字符串变量。第一个参数映射到变量名 <code>1</code>，第二个参数映射到变量名 <code>2</code>，以此类推……</p><p>我们用一个实例来说明参数的传递。我们将 <code>hello.sh</code> 的内容修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>str=&quot;Hello, $1 and $2!&quot;<br>echo $str<br></code></pre></td></tr></table></figure><p>输入如下命令运行，看看控制台输出了什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./hello.sh world OS</span><br></code></pre></td></tr></table></figure><p>请在双引号中引用变量。如果将上述的双引号改成单引号，则会原文输出引号内的内容，你可以尝试一下。</p><p>需要补充的是，对于传递的参数，不仅有 <code>$1</code>、<code>$2</code> 这样的特殊变量，还提供了其他的特殊变量：</p><ul><li><code>$#</code> 传递的参数个数；</li><li><code>$*</code>一个字符串，内容是传递的全部参数。</li></ul><h4 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h4><p>如果我们想对大批量的文件进行复杂操作，我们一般需要用到条件控制和循环控制。这也是自动化操作的精髓所在。下面我们对 <code>if</code> 和 <code>while</code> 关键字进行简单讲解。</p><p><code>if</code> 语句块的格式如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> condition1<br>then<br>    <span class="hljs-keyword">command</span>11<br>    <span class="hljs-keyword">command</span>12<br>    <span class="hljs-string">......</span><br>elif condition2<br>then<br>    <span class="hljs-keyword">command</span>21<br>    <span class="hljs-keyword">command</span>22<br>    <span class="hljs-string">......</span><br>else<br>    <span class="hljs-keyword">command</span>31<br>    <span class="hljs-keyword">command</span>32<br>    <span class="hljs-string">......</span><br>fi<br></code></pre></td></tr></table></figure><p>其中，<code>fi</code> 是“if”的倒写，代表 <code>if</code> 语句块的结束；<code>elif</code> 意为“else if”。<code>elif</code> 和 <code>else</code> 可以按需省略。下面举例说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>if (( $1 &gt; $2 ))<br>then<br>        echo &quot;first &gt; second&quot;<br>elif (( $1 &lt; $2 ))<br>then<br>        echo &quot;first &lt; second&quot;<br>elif (( $1 == $2 ))<br>then<br>        echo &quot;first == second&quot;<br>else<br>        echo &quot;I don&#x27;t know...&quot;<br>fi<br></code></pre></td></tr></table></figure><p>其中 <code>(())</code> 是用于比较<strong>整数</strong>之间大小的表达方式。传入字符串或浮点数，则是未定义的行为。可以试着传入不同的参数，看看程序输出了什么。</p><p><code>while</code> 语句块的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>    command1<br>    command2<br>    ...<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>其中 <code>done</code> 表示“do”语句块的结束。下面举例说明。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>mkdir files<br>cd files<br>i=1<br>while (($i &lt;= $1))<br>do<br>        touch &quot;file$i.txt&quot;<br>        let i=i+1 # or i=$((i+1))<br>done<br></code></pre></td></tr></table></figure><p>这里，<code>let</code> 是为变量赋值的命令，与之等价地，也可以使用 <code>i=$((i+1))</code>。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>Shell 脚本也支持<strong>函数</strong>。函数的定义方式如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">fun_name</span>() &#123;<br>    body...<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int_value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>function</code> 和 <code>()</code> 可以省略其中一个。其中返回语句是可选的，函数可以不返回值。<code>int_value</code> 是一个[0,255][0,255]之间的整数，返回其他值是未定义的行为，一般会返回一个错误的结果。</p><p>函数的调用方法如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">fun_name</span></span> param1 param2 ... paramN<br></code></pre></td></tr></table></figure><p>其中第 N 个参数在函数体内使用 <code>$N</code> 来获取，且不需要在函数定义开头声明。值得注意的是，当 N&gt;&#x3D;10 时，需要用 <code>$&#123;N&#125;</code> 来获取参数，否则 <code>$</code> 只会带第一位数字。如果函数有返回值，则在函数调用的后面需要使用 <code>$?</code> 获取返回值。下面用一个例子说明函数是如何定义和调用的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>function fun1() &#123;<br>        echo &quot;Hello, world!&quot;<br>&#125;<br>function fun2() &#123;<br>        echo &quot;I&#x27;ve got &quot;$1&quot; and &quot;$2&quot;!&quot;<br>&#125;<br>function fun3() &#123;<br>        echo &quot;I&#x27;m computing first + second!&quot;<br>        return $(($1 + $2))<br>&#125;<br>fun1<br>fun2 2 3<br>fun3 4 5<br>echo &quot;The sum is &quot;$?&quot;.&quot;<br></code></pre></td></tr></table></figure><p>其中，<code>$(($1 + $2))</code> 的意思是先计算 <code>$1 + $2</code> 的值。</p><h3 id="sed——用命令编辑和输出文本"><a href="#sed——用命令编辑和输出文本" class="headerlink" title="sed——用命令编辑和输出文本"></a>sed——用命令编辑和输出文本</h3><p>我们已经初步了解到 Shell 脚本的强大功能。但我们目前对于文本的编辑功能仅仅学习了 Vim 等工具的使用。有人可能会想到，可以通过 Shell 脚本（即一条条的命令）对文本文件的内容进行编辑和输出吗？当然可以！sed 是通过命令编辑和输出文本的工具，通过掌握 <code>sed</code> 命令的使用，我们就可以实现文本内容编辑和选择输出的自动化。</p><div class="note note-success">            <p>sed<br>sed [选项] ‘命令’ 输入文本<br>选项（常用）：<br>-n：安静模式，只显示经过sed处理的内容。否则显示输入文本的所有内容。<br>-i：直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。<br>命令（常用）：<br>&lt;行号&gt;a&lt;内容&gt;： 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一行之后新增。使用$表示最后一行。后面的命令同理。<br>&lt;行号&gt;c&lt;内容&gt;：取代。用内容取代相应行的文本。<br>&lt;行号&gt;i&lt;内容&gt;：插入。在当前行的上面插入一行文本。<br>&lt;行号&gt;d：删除当前行的内容。<br>&lt;行号&gt;p：输出选择的内容。通常与选项-n一起使用。<br>s&#x2F;<re>&#x2F;<string>：将<re>（正则表达式）匹配的内容替换为<string>。</p>          </div><blockquote><p>sed 中正则表达式的相关语法可以查阅 <a href="https://www.gnu.org/software/sed/manual/html_node/Regular-Expressions.html">sed 文档</a>。sed 等工具中的正则表达式语法和 Java 等语言中不完全相同，请注意区分。</p></blockquote><p>不加 <code>-i</code> 选项时，只在控制台显示编辑后的文件内容，而不修改文件本身。下面举几个使用例子，以便更好地理解 <code>sed</code> 命令的使用方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -n &#x27;3p&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出 my.txt 的第三行</span><br>sed &#x27;2d&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 my.txt 文件的第二行</span><br>sed &#x27;2,$d&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 my.txt 文件的第二行到最后一行</span><br>sed &#x27;s/str1/str2/g&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在整行范围内把 str1 替换为 str2。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有 g 标记，则只有每行第一个匹配的 str1 被替换成 str2</span><br>sed -e &#x27;4astr &#x27; -e &#x27;s/str/aaa/&#x27; my.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-e 选项允许在同一行里执行多条命令。例子的第一条是第四行后添加一个 str，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个命令是将 str 替换为 aaa。命令的执行顺序对结果有影响。</span><br></code></pre></td></tr></table></figure><blockquote><p>除了 <code>sed</code> 命令，还有更强大的 <code>awk</code> 命令，但使用也更加复杂。</p></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>很多命令都有控制台输出。如果想要把这些命令的输出写到文件中，应该怎么办呢？答案是使用重定向。Linux 定义了三种流：</p><ul><li>标准输入：<code>stdin</code>，由 0 表示。</li><li>标准输出：<code>stdout</code>，由 1 表示。</li><li>标准错误：<code>stderr</code>，由 2 表示。</li></ul><p>默认情况下，这些流使用的设备是控制台，也就是我们可以在控制台上看到命令的输出。在命令后使用<code>&gt;</code>符号可以将输出重定向。举个例子：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span> / &gt; lsoutput.txt<br></code></pre></td></tr></table></figure><p>这个命令就是将根目录下的文件名输出到当前目录的 <code>lsoutput.txt</code> 文件中，<strong>覆盖文件的原有内容</strong>，如果想在文件后追加命令的输出，使用 <code>&gt;&gt;</code> 符号而不是<code>&gt;</code>。由于输出被重定向到文件，所以我们在控制台中看不到输出了。这就是输出重定向的基本用法。</p><p>我们在控制台中单独运行 <code>gcc</code> 命令，什么参数也不加。由于没有输入文件，显然编译器是无法正确运行的。所以我们可以看到 gcc 产生了一个 fatal error：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> gcc<br>gcc: fatal error: <span class="hljs-keyword">no</span> input <span class="hljs-keyword">files</span><br>compilation terminated.<br></code></pre></td></tr></table></figure><p>试试看使用命令 <code>gcc &gt; gccerr</code>，看看发生了什么？我们发现控制台仍然输出了错误，而 <code>gccerr</code> 中没有任何内容。似乎重定向不好用了。这是为什么呢？</p><p>实际上，<code>&gt;</code> 是 <code>1&gt;</code> 的简写。在我们刚才提到的三种流中，1 指的是标准输出，而不包括标准错误输出。<code>gcc</code> 输出的编译错误消息属于标准错误输出。如果想要将错误输出到文件，需要使用 <code>2&gt;</code>，也就是将错误输出重定向到文件。试试使用 <code>gcc 2&gt; gccerr</code>，看看是否达到了预期效果。</p><p>同理，我们也可以对输入进行重定向。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道符号<code>|</code>可以对命令进行连接。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">command</span>1 | <span class="hljs-keyword">command</span>2 | <span class="hljs-keyword">command</span>3 | <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>以上内容是将 <code>command1</code> 的输出传给 <code>command2</code> 的输入，<code>command2</code> 的输出传给 <code>command3</code> 的输入，以此类推。</p><p><code>cat</code> 命令将文件内容输出到标准输出，<code>grep</code> 命令支持从标准输入读取文本。所以这两个命令就可以用管道进行连接。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> hello.txt | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令的作用就是将 <code>hello.txt</code> 文件输出，输出的内容传入 <code>grep</code> 命令，<code>grep</code> 命令在这些内容中查找 <code>Hello</code> 字符串。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道“原地”哈希题</title>
    <link href="/2024/02/17/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/"/>
    <url>/2024/02/17/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="两道“原地”哈希题"><a href="#两道“原地”哈希题" class="headerlink" title="两道“原地”哈希题"></a>两道“原地”哈希题</h1><h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h2><p>题目链接：<a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由题目可知数组 nums 中的 n 个数都在 [1, n] 的范围内，因为是数字的个数和位置个数应该一一对应如果有数字出现了两次，就意味着 [1,n] 中有数字没有出现过。</p><p>解题突破口就是，将每一个数放在对应的位置。如果位置和值不相等，就是出现两次的数。</p><p>由于数组的下标范围是 [0, n-1]，我们需要将数 i 放在数组中下标为 i-1 的位置。如果 nums[i] 恰好出现了一次，那么将 nums[i] 放在数组中下标为 nums[i]−1 的位置即可； 如果 nums[i] 出现了两次，那么我们希望其中的一个 nums[i] 放在数组下标中为 nums[i]−1 的位置，另一个 nums[i] 放置在任意「不冲突」的位置 x。</p><p><img src="https://pic.imgdb.cn/item/65d05b919f345e8d03533744.jpg"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>遍历数组；<ul><li>当遍历到位置 i 时，看 nums[i] 和 nums[i]−1，是否相同；</li><li>如果相同这开始从下一个数字开始比较；</li><li>如果不同则应该把 nums[i]−1 放在对应的位置上，因此我们交换 num[i] 和 nums[nums[i]−1] 即可，直到待交换的两个元素相等为止；</li></ul></li><li>遍历数组，找到数组中下标和值不一样的数字就是 重复出现两次的数 加入到resul 中即可；</li><li>返回结果 result。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-comment">/* 原地啊交换数组 */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>            <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i] - <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">/* 找到数组中下标和值不一样的数字就是 重复出现两次的数 */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span> != i) result.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>题目链接：<a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针的一个应用</title>
    <link href="/2024/01/30/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2024/01/30/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode上的一个双指针题的解法与简化"><a href="#Leetcode上的一个双指针题的解法与简化" class="headerlink" title="Leetcode上的一个双指针题的解法与简化"></a>Leetcode上的一个双指针题的解法与简化</h1><h2 id="题目：80-删除有序数组中的重复项-II"><a href="#题目：80-删除有序数组中的重复项-II" class="headerlink" title="题目：80. 删除有序数组中的重复项 II"></a>题目：80. 删除有序数组中的重复项 II</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/</a></p><p>给你一个有序数组<code>nums</code>，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong>，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>读完题目之后，我们应该注意到：nums数组是有序的！这意味着：相同元素必然连续。</p><p>我们可以设置快慢两个指针：<code>fast</code>和<code>slow</code>，运用for循环进行遍历，判断哪些元素应该保留，哪些应该剔除。</p><p>具体而言，<code>slow</code>指针表示处理出的数组的长度，fast指针表示已经检查过的数组的长度。即<code>nums[fast]</code>表示待检查的第一个元素，<code>nums[slow − 1]</code>为上一个应该被保留的元素所移动到的指定位置。</p><p>因为本题要求相同元素最多出现两次，所以我们需要检查上上个应该被保留的元素<code>nums[slow − 2]</code>是否和当前待检查元素<code>nums[fast]</code>相同。当且仅当<code>nums[slow − 2] == nums[fast]</code>时，当前待检查元素<code>nums[fast]</code>不应该被保留（因为此时必然有<code>nums[slow − 2] == nums[slow − 1] == nums[fast]</code>）。</p><p>最后，slow即为处理好的数组的长度。</p><p>特别地，数组的前两个数必然可以被保留，因此对于长度不超过2的数组，我们无需进行任何处理，对于长度超过2的数组，我们直接将双指针的初始值设为2即可。</p><p>于是便有了这样的解答：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 特殊判断，如果nums长度小于2，直接输出长度n即可</span><br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">2</span>, fast = <span class="hljs-number">2</span>; <span class="hljs-comment">// 因为上面已经做过特殊判别，所以这里快慢指针从2开始</span><br>        <span class="hljs-keyword">while</span> (fast &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[slow - <span class="hljs-number">2</span>] != nums[fast]) &#123; <span class="hljs-comment">// 因为题目要求最多两个数相同，所以这么判断</span><br>            <span class="hljs-comment">// 如果nums[slow - 2] == nums[fast]，代表已经有两个数相等，此时nums[fast]</span><br>            <span class="hljs-comment">// 对应的数值不能放进结果之中。反之，如果nums[slow - 2] != nums[fast]，</span><br>            <span class="hljs-comment">// 那么nums[fast]可以放进nums[slow]中，并且slow++，记录结果的长度。</span><br>                nums[slow] = nums[fast]; <br>                slow++;<br>            &#125;<br>            fast++; <span class="hljs-comment">// 不管怎么样，快指针都是要向前遍历各个元素的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> slow; <span class="hljs-comment">// 返回结果的长度，即slow</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>基于上面显式的双指针法，我们可以进一步抽象简化。</p><p>首先应该考虑，我们使用双指针的目的是什么？其实是方便指向我们要使用的数字。所以指针对应的数值才是主角。</p><p>在下面的题解中，我们应该尽量少使用指针，让数值自己出来比较：</p><p>联想到C++的for循环语法：<code>for (int num : nums)</code>，可以让num自身当右指针；</p><p>可以再令一个i代表左指针。</p><p>结合上面的思想，我们可以得到下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123; <span class="hljs-comment">// num当右指针</span><br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">2</span> || nums[i - <span class="hljs-number">2</span>] &lt; num) &#123; <span class="hljs-comment">// i &lt; 2是特殊判断，nums[i - 2] &lt; num</span><br>            <span class="hljs-comment">// 是因为题目要求相同元素不能超过两个。之所以可以用小于号判断，是因为数组是有序的</span><br>                nums[i] = num; <span class="hljs-comment">// 相当于上面官方解法的nums[slow] = nums[fast];</span><br>                i++; <span class="hljs-comment">// 相当于上面官方解法的slow++;，即左指针移动</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 输出长度，即相当于上面题解的slow</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果每个元素最多出现K次，你要怎么修改上面的代码？</p><p>很简单，改成<code>if (i &lt; k || nums[i - k] &lt; num)</code>就好了！</p><p>（这能不能看作这类问题的通解呢？）</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尺取法及应用 - POJ 3061</title>
    <link href="/2024/01/29/%E5%B0%BA%E5%8F%96%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20-%20POJ3061/"/>
    <url>/2024/01/29/%E5%B0%BA%E5%8F%96%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20-%20POJ3061/</url>
    
    <content type="html"><![CDATA[<h1 id="尺取法及其应用-POJ-3061"><a href="#尺取法及其应用-POJ-3061" class="headerlink" title="尺取法及其应用 - POJ 3061"></a>尺取法及其应用 - POJ 3061</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>返回推进区间的开头和结尾，求满足条件的最小区间的方法称为尺取法。</strong>，顾名思义，就是像一把尺子（固定某一条件），不断向右（左）移动，不断更新所求答案。一般用来求满足条件的最小区间。</p><p>主要实现方法为：</p><ol><li>初始化左右端点</li><li>不断扩大右端点，直至满足条件</li><li>如果直至终点也无法满足条件，则终止，否则更新结果</li><li>扩大左端点（右移1），跳回步骤2</li></ol><p>这种方法只有一个疑问点，就是R不往回移动，其结果一定是对的吗？</p><p>考虑一下，L一直向右移动，R其实没必要向左动了。R只有在不满足条件的时候才向右，否则停在原位。</p><p>此时凭L的移动，已经能找出所有可行的区间了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例题链接：<a href="http://poj.org/problem?id=3061">http://poj.org/problem?id=3061</a></p><p>找到最短的序列长度，使得序列元素和大于S。</p><p>在这道题中，序列都是正数，如果一个区间其和大于等于S，那么不需要在向后推进右端点了，因为其和也肯定大于等于S但长度更长。</p><p>所以，<strong>当区间和小于S时右端点向右移动，和大于等于S时，左端点向右移动以进一步找到最短的区间</strong>。</p><p>如果右端点移动到区间末尾其和还不大于等于S，结束区间的枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> t,n,s;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-comment">//加速流</span><br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        cin&gt;&gt;n&gt;&gt;s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            cin&gt;&gt;a[i];<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>,ans=n+<span class="hljs-number">1</span>;   <span class="hljs-comment">//l，r:左右端点  ans初始值设为n+1</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(r&lt;n&amp;&amp;sum&lt;s)<br>                sum+=a[r++];<br>            <span class="hljs-keyword">if</span>(sum&lt;s)         <span class="hljs-comment">//如果所有数的和都小于s，直接跳出循环</span><br>                <span class="hljs-keyword">break</span>;<br>            ans=<span class="hljs-built_in">min</span>(ans,r-l); <span class="hljs-comment">//此时r一定小于n</span><br>            sum-=a[l++];      <span class="hljs-comment">//去掉最左端点，继续前进</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans==n+<span class="hljs-number">1</span>)<br>            cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>网上说还可以结合前缀和来思考解法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章 超标量处理器概览</title>
    <link href="/2024/01/16/%E7%AC%AC1%E7%AB%A0%20%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%A7%88/"/>
    <url>/2024/01/16/%E7%AC%AC1%E7%AB%A0%20%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-超标量处理器概览"><a href="#第1章-超标量处理器概览" class="headerlink" title="第1章 超标量处理器概览"></a>第1章 超标量处理器概览</h1><h2 id="1-1-为什么需要超标量"><a href="#1-1-为什么需要超标量" class="headerlink" title="1.1 为什么需要超标量"></a>1.1 为什么需要超标量</h2><p>程序执行时间  &#x3D;  $Instructions * CPI * f$。其中:$Instructions$指的是指令个数，$CPI$(Cycles  per  Instrution)指的是执行每条指令所需的周期数，$f$指的是每周期所需要的时间，亦即时钟频率。</p><h3 id="加快处理器执行程序的速度"><a href="#加快处理器执行程序的速度" class="headerlink" title="加快处理器执行程序的速度"></a>加快处理器执行程序的速度</h3><p>可以考虑以下三点：</p><ul><li><p>减少程序中指令的数量。指令的数量对已经编写好的固定程序是定值。</p></li><li><p>减少CPI，即增大IPC（Instructions per Cycle，每周期执行指令的个数）。</p><p>普通流水线处理器的IPC最大为1。要想每周期执行多于一条指令，就需要使用超标量（Superscalar）处理器。</p><p>处理器采用何种架构进行实现也成为微结构（Microarchitecture）。</p></li><li><p>减少周期时间（cycle time），即加大频率。</p><ul><li>精巧的电路设计，更深的流水线</li><li>优秀的EDA工具</li><li>硅工艺</li></ul></li></ul><p>实际中IPC与运行频率是互相制约的。</p><p>超长指令字（Very Long Instruction Word，VLIW）也是一种每周期可以执行多条指令的处理器架构。</p><ul><li>超标量处理器依靠硬件自身决定哪些指令可被并行地执行，VLIW处理器依靠编译器和程序员自身来决定。</li><li>VLIW在硬件实现上简单，在功能专一的专用处理器领域得到应用，如DSP。</li></ul><h3 id="处理器设计需要折中（tradeoff）"><a href="#处理器设计需要折中（tradeoff）" class="headerlink" title="处理器设计需要折中（tradeoff）"></a>处理器设计需要折中（tradeoff）</h3><ul><li>分支预测<ul><li>精确的分支预测算法需要复杂的硬件资源，无法在一个周期内完成</li><li>分支预测无法在一个周期内完成，那么处理器就不能连续地取指令，造成性能下降</li></ul></li><li>load&#x2F;store指令<ul><li>完全乱序执行可获得较大的IPC。</li><li>相关性检查变得复杂，需要更复杂的恢复机制。</li></ul></li><li>Checkpoint的个数与硬件的面积</li><li>发射队列（issue queue）的个数与仲裁（select）电路的复杂度</li><li>每周期可同时执行的指令个数（issue width）和寄存器堆（register file）的端口个数</li></ul><p>超标量处理器设计没有一个确定的设计原则，需要根据应用领域和场合确定设计的思路。</p><h2 id="1-2-普通处理器的流水线"><a href="#1-2-普通处理器的流水线" class="headerlink" title="1.2 普通处理器的流水线"></a>1.2 普通处理器的流水线</h2><h3 id="1-2-1-流水线概述"><a href="#1-2-1-流水线概述" class="headerlink" title="1.2.1 流水线概述"></a>1.2.1 流水线概述</h3><blockquote><p> 这里假设处理器的性能与处理器的频率直接相关。</p><p>在现实中，频率并不是决定处理器性能的唯一因素。</p></blockquote><p>当处理器没有使用流水线时，周期时间为D，消耗的硬件面积为G。</p><p>对于一个 $n$ 级流水线，周期时间变为 $\frac{D}{n} + S$，其中S表示流水线寄存器的延迟；消耗的硬件面积为 $G + n * L$，其中L为每个流水线寄存器及其附属的控制逻辑所消耗的硬件面积。</p><p> $n$ 级流水线处理器的性能（Performance） &#x3D; $\frac{1}{\frac{D}{n}+S}$；总共消耗的硬件面积（Cost） &#x3D;  $G + n * L$。</p><p>获得同样的性能，消耗的硬件面积越小越好，用公式表示为：</p><p>$$<br>\frac{Cost}{Performance} &#x3D; \frac{G + n * L}{\frac{1}{\frac{D}{n}+S}} &#x3D; \frac{GD}{n} + nSL + LD + GS<br>$$<br>对上式求导可得到函数的极值点，由此可以得到最优化的流水线级数n。</p><p>现实设计中根据实际需求得到理想的流水级级数。</p><h3 id="1-2-2-流水线的划分"><a href="#1-2-2-流水线的划分" class="headerlink" title="1.2.2 流水线的划分"></a>1.2.2 流水线的划分</h3><ol><li><p>每个阶段所需要的时间近似相等</p><p>最长的流水段所需要的时间决定了整个处理器的周期时间</p></li><li><p>每个阶段的操作都会被重复地执行</p></li><li><p>每个阶段的操作都和其他的流水段相互独立、互不相干</p><p>最难满足，也是影响执行效率的关键因素</p></li></ol><p>不同的指令集，流水线实现的难易程度是不同的。</p><p>对于一般的精简指令集（RISC）来说，如MIPS和ARM，由于指令的长度相等，并且每条指令所完成的任务比较规整，所以容易用流水线来实现。</p><p>经典RISC处理器的流水线如下图。</p><p><img src="https://pic.imgdb.cn/item/65a936b8871b83018a804e8d.png"></p><p>该MIPS处理器的设计在大二的计组实验中已经学习。</p><p>但是，每个流水段所需要的时间相差很多，因此需要对各个流水段进行平衡。</p><h4 id="合：将两个或多个流水段合并成一个流水段"><a href="#合：将两个或多个流水段合并成一个流水段" class="headerlink" title="合：将两个或多个流水段合并成一个流水段"></a>合：将两个或多个流水段合并成一个流水段</h4><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a807070.png"></p><p>适用于对性能要求不高的低功耗嵌入式处理器。每个流水段所耗费的时间均衡，但整体的运行频率下降。</p><h4 id="拆：将一个流水段拆成更小的阶段"><a href="#拆：将一个流水段拆成更小的阶段" class="headerlink" title="拆：将一个流水段拆成更小的阶段"></a>拆：将一个流水段拆成更小的阶段</h4><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a8071cc.png"></p><p>可以获得比较高的主频，适合高性能处理器。</p><ul><li>导致硬件消耗的增大</li><li>寄存器堆的端口数要随之增加，以支持多个流水段同时读写</li><li>存储器（如D-Cache）的端口数量要随之增加</li><li>处理器的功耗随之增大</li><li>神流水线导致预测失败时的惩罚（mis-prediction penalty）增大</li></ul><p>一定范围内增加处理器的流水线深度可以提高性能。</p><h3 id="1-2-3-指令间的相关性"><a href="#1-2-3-指令间的相关性" class="headerlink" title="1.2.3 指令间的相关性"></a>1.2.3 指令间的相关性</h3><h4 id="先写后读（RAW）"><a href="#先写后读（RAW）" class="headerlink" title="先写后读（RAW）"></a>先写后读（RAW）</h4><p>Read After Write，也称true dependence，这种相关性是无法回避的。<br>$$<br>A: R_1 &#x3D; R_2 + R_3\<br>B: R_5 &#x3D; R_1 + R_4<br>$$<br>B的操作数$R_1$来自A的结果，所以要等待A将结果计算出来，B才能继续运行。</p><h4 id="先读后写（WAR）"><a href="#先读后写（WAR）" class="headerlink" title="先读后写（WAR）"></a>先读后写（WAR）</h4><p>也称anti-dependence。<br>$$<br>A: R_1 &#x3D; R_2 + R_3\<br>B: R_2 &#x3D; R_5 + R_4<br>$$<br>A读取$R_2$之前，B不能把结果写入到$R_2$。</p><p>这种相关性是可以避免的，只需要B将的结果写入到其他寄存器。</p><h4 id="先写后写（WAW）"><a href="#先写后写（WAW）" class="headerlink" title="先写后写（WAW）"></a>先写后写（WAW）</h4><p>也称output dependence。<br>$$<br>A: R_1 &#x3D; R_2 + R_3\<br>B: R_1 &#x3D; R_5 + R_4<br>$$<br>这种相关性是可以避免的，只需要B将结果写入到其他寄存器。</p><h4 id="控制相关性"><a href="#控制相关性" class="headerlink" title="控制相关性"></a>控制相关性</h4><p>由分支指令引起。只有当分支指令的结果被计算出来的时候，才可以知道从哪里获得后续的指令来执行。</p><p>分支指令需要一段时间才能获得结果，在这段时间内只能按照预测的方式来取指令。</p><h4 id="存储器地址的相关性"><a href="#存储器地址的相关性" class="headerlink" title="存储器地址的相关性"></a>存储器地址的相关性</h4><p>RAW，WAR，WAW三个相关性不仅对寄存器之间的关系适用，对于存储器地址之间的关系也同样适用。</p><p>如<code>sw r1, 0(r5)</code>和<code>lw r2, 0(r6)</code>两条指令，当r5与r6的值相等时，这两条指令存在RAW的相关性。</p><p>这种类型的相关性需要将load&#x2F;store指令所携带的地址计算出来才可以判别。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>指令之间的各种相关性，使得他们在处理器中无法完全地乱序执行。</p><p>对于普通的处理器来说，WAW和WAR并不会引起问题，RAW可以通过旁路（bypass）的方式来解决。</p><p>对于超标量处理器来说，三种相关性都会阻碍指令的乱序执行，都需要在处理器中进行特殊的处理。</p><h2 id="1-3-超标量处理器的流水线"><a href="#1-3-超标量处理器的流水线" class="headerlink" title="1.3 超标量处理器的流水线"></a>1.3 超标量处理器的流水线</h2><p>超标量处理器的执行方式：顺序执行（in-order）和乱序执行（out-of-order）。</p><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a8072c3.png"></p><ul><li><p>Frontend：流水线的取指令（Fetch）和解码（Decode）阶段，很难实现（也没有意义）乱序执行。</p></li><li><p>Issue：将指令送到对应的功能单元（Function Unit，FU）中执行</p><p>这里可以实现乱序执行，只要指令的源操作数准备好了，就可以将其先于其他指令运行。</p></li><li><p>Write back：将指令的结果写到目的寄存器中。</p><p>在处理器内部适用寄存器重命名，将指令集中定义的逻辑寄存器（Architecture Register File，ARF）动态地转化为芯片内部实际使用的物理寄存器（Physical Register File，PRF），从而实现乱序地写回寄存器。</p></li><li><p>Commit：一条指令被允许更改处理器的状态（Architecture state，如D-Cache等）</p><p>为了保证程序按照原来的意图执行，并且实现精确的异常，这个阶段需要顺序执行，才能够保证从处理器外部看起来，程序是串行执行的。</p></li></ul><h3 id="1-3-1-顺序执行"><a href="#1-3-1-顺序执行" class="headerlink" title="1.3.1 顺序执行"></a>1.3.1 顺序执行</h3><p><img src="https://pic.imgdb.cn/item/65a936c0871b83018a807407.png"></p><p>若每周期可从I-Cache中取出两条指令来执行，则称为2-way的超标量处理器。</p><p>发射（Issue）：指令解码之后，读取寄存器而得到操作数，根据自身的类型，将指令送到对应的FU中执行。</p><p>所有FU要经过同样周期数的流水线，保证流水线的写回（Write back）阶段是顺序执行的。</p><h4 id="Scoreboard"><a href="#Scoreboard" class="headerlink" title="Scoreboard"></a>Scoreboard</h4><p>Scoreboard记录流水线中每条指令的执行情况。典型情况下需要记录的信息如下。</p><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a806f71.png"></p><ul><li>P：Pending，指令的结果还没有写回到逻辑寄存器中。</li><li>F：一条指令在哪个FU中执行，在将指令结果进行旁路的时候会使用这个信息。</li><li>Result Position：记录一条指令到达FU中流水线的哪个阶段，3表示到达FU流水线的第一个流水段，1表示到达FU流水线的最后一个阶段，0表示到达写回阶段。</li></ul><p>程序在顺序执行的超标量流水线中的执行情况如下图所示。</p><p><img src="https://pic.imgdb.cn/item/65a93779871b83018a83fb42.png"></p><p>很多指令在流水线都会由于前面指令的阻塞而不能够继续执行。例如上图的指令F，它与前面的指令都是不相关的，但是这条指令只有等到前面所有的指令都已经发射了，它才可以送到FU中执行，这样就降低了处理器的性能。</p><p>在所有的处理器中，RAW相关性都是不能绕开的。</p><p>但是对于WAW和WAR，由于顺序执行的处理器只有一个统一的写回阶段，而且这个阶段位于流水线的最后一级，所以这两种相关性都不会对流水线产生影响。</p><h3 id="1-3-2-乱序执行"><a href="#1-3-2-乱序执行" class="headerlink" title="1.3.2 乱序执行"></a>1.3.2 乱序执行</h3><p>一旦某条指令的操作数准备好了，就可以将其送入FU中执行。</p><p><img src="https://pic.imgdb.cn/item/65a93779871b83018a83fde8.png"></p><p>为了在乱序执行时解决WAW和WAR这两种相关性，需要对寄存器进行重命名（register renaming），可以在解码（Decode）阶段完成，也可以单独使用一个流水段来完成。</p><p>处理器中需要增加物理寄存器堆（Physical Register File，PRF）配合对指令集中定义的寄存器（Architecture Register File，ARF）进行重命名，PRF中寄存器的数量要多于ARF。</p><p>指令在发射阶段被储存在一个缓存中，这个缓存称为发射队列（Issue Queue，IQ）。一旦操作数准备好了，就可以从发射队列中离开，送到对应的FU中执行。</p><p>发射阶段是流水线从顺序执行到乱序执行的分界点。</p><p>由于每个FU执行周期数都不相同，所以指令在写回阶段是乱序的。一条指令只要计算完毕，就会把结果写到PRF中。</p><p>分支预测失败（mis-prediction）和异常（exception）的存在使得PRF的结果未必都会写到ARF中，因此也将PRF称为Future File。</p><h4 id="重排序缓存和提交阶段"><a href="#重排序缓存和提交阶段" class="headerlink" title="重排序缓存和提交阶段"></a>重排序缓存和提交阶段</h4><p>为了保证程序的串行结果，指令需要按照程序中规定的顺序更新处理器的状态，需要使用重排序缓存（ROB）的部件来配合。使用ROB来实现程序对处理器状态的顺序更新，这个阶段称为提交（Commit）阶段。</p><p>一条指令在这个阶段会将它的结果从PRF搬移到ARF中，同时重排序缓存也会配合完成对异常的处理。</p><h4 id="退休"><a href="#退休" class="headerlink" title="退休"></a>退休</h4><p>如果不存在异常，那么指令就可以顺利地离开流水线，并对处理器的状态进行更改，此时称这条指令退休（retire）了。</p><p>一条指令一旦退休，就不可能回到之前的状态了。一条指令在退休之前，都可以从流水线中被清除。</p><h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>如果在写回阶段就将store指令的结果写到存储器中，那么一旦由于分支预测失败或是异常等原因，需要将这条store指令从流水线中抹掉时，就没有办法恢复存储器的状态。</p><p>使用一个缓存（Store Buffer，SB）来存储store指令没有退休以前的结果。store指令在写回阶段会将他的结果写到SB中，只有一条store指令真正retire之后，才可以把它的值从SB写到存储器中。</p><p>load指令除了从D-Cache中寻找数据，还需要从Store Buffer中进行查找。</p><p>程序在乱序执行的超标量流水线中的执行情况如下图所示。</p><p><img src="https://pic.imgdb.cn/item/65a93779871b83018a83fa52.png"></p><p>i表示发射阶段；解码和寄存器重命名位于同一个流水段；r表示计算完成，在ROB中等待retire；C表示一条指令经过了提交阶段，离开流水线而退休了，这个过程是按照程序中规定的顺序（in-order）执行的。</p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P7 - 流水线CPU设计文档</title>
    <link href="/2023/12/06/P7%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/12/06/P7%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P7-流水线CPU设计文档"><a href="#P7-流水线CPU设计文档" class="headerlink" title="P7 流水线CPU设计文档"></a>P7 流水线CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li><p>设计的处理器为32位五级流水线处理器</p></li><li><p>处理器支持的指令集为</p><blockquote><p>add, sub, and, or, slt, sltu, lui<br>addi, andi, ori<br>lb, lh, lw, sb, sh, sw<br>mult, multu, div, divu, mfhi, mflo, mthi, mtlo<br>beq, bne, jal, jr,</p><p><strong>mfc0,</strong> <strong>mtc0,</strong> <strong>eret,</strong> <strong>syscall</strong></p></blockquote></li><li><p>在 P6 基础上新增了 <code>mfc0, mtc0, eret, syscall</code> 四条新指令</p></li><li><p><code>eret</code> 具有跳转的功能但是没有延迟槽，保证 <code>eret</code> 的后续指令不被执行</p></li><li><p><code>syscall</code> 指令行为与 MARS 不同，无需实现特定的输入输出功能，只需直接产生异常并进入内核态</p></li></ul><p>CPU整体架构参考了《数字设计与计算机体系结构》图7-58。</p><p><img src="https://pic.imgdb.cn/item/654cc27dc458853aef789452.png" alt="整体架构"></p><p>mips微系统的架构图如下图所示：</p><p><img src="https://pic.imgdb.cn/item/655dfd95c458853aef0dbd97.png"></p><h2 id="F级：取指令（Fetch）"><a href="#F级：取指令（Fetch）" class="headerlink" title="F级：取指令（Fetch）"></a>F级：取指令（Fetch）</h2><p>本级的输入为来自D级的<code>next_pc</code>，用于更新下一个PC的值。</p><p>本级的输出为<code>F_PC</code>和<code>F_Instr</code>，分别对应从F级指令的PC和F级指令的内容，均需要参与流水。</p><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><p>只负责PC的存储与更新，F_instr来自<code>mips_txt.v</code>的交互。</p><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>PC写使能信号，高电平有效</td></tr><tr><td>next_pc[31:0]</td><td>I</td><td>待更新的指令地址</td></tr><tr><td>pc[31:0]</td><td>O</td><td>当前指令地址</td></tr></tbody></table><h4 id="与mips-txt-v交互"><a href="#与mips-txt-v交互" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog">ifu F_IFU(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.enable</span>(IFU_WE),<br>    <span class="hljs-variable">.next_pc</span>(next_PC),<br>    <span class="hljs-variable">.pc</span>(F_PC)<br>);<br><br><span class="hljs-keyword">assign</span> F_Instr = i_inst_rdata;<br><span class="hljs-keyword">assign</span> i_inst_addr = F_PC;<br></code></pre></td></tr></table></figure><h3 id="F-D级流水线寄存器"><a href="#F-D级流水线寄存器" class="headerlink" title="F&#x2F;D级流水线寄存器"></a>F&#x2F;D级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>F_pc[31:0]</td><td>I</td><td>F级PC</td></tr><tr><td>F_instr[31:0]</td><td>I</td><td>时钟信号</td></tr><tr><td>D_pc[31:0]</td><td>O</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>O</td><td>32位的指令值</td></tr></tbody></table><h2 id="D级：译码（Decode）"><a href="#D级：译码（Decode）" class="headerlink" title="D级：译码（Decode）"></a>D级：译码（Decode）</h2><p>本级的输入为来自F级的<code>F_PC</code>和<code>F_Instr</code>。</p><p>本级的输出为<code>D_gpr_rs</code>, <code>D_gpr_rt</code>, <code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>和<code>next_pc</code>。</p><p>本级涉及到来自E级、M级、W级的转发，其中来自W级的转发通过<strong>GRF内部转发</strong>的方式实现。</p><p><code>$rs</code>和<code>$rt</code>的值在本级转发成<code>D_fwd_gprrs</code>和<code>D_fwd_gprrt</code>，和<code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>参与流水。</p><p>本级需要对<strong>此级指令</strong>的$$Tuse$$和此时<strong>E级</strong>指令与<strong>M级指令</strong>的$Tnew$进行比较，从而确定是否执行阻塞。</p><blockquote><p>$Tuse$和$Tnew$:</p><ul><li><p>$Tuse$表示这条指令位于D级的时候，再经过多少个时钟周期就必须要使用相应的数据。</p><ul><li>每个指令的$Tuse$是固定不变的</li><li>一个指令可以有两个$Tuse$值</li></ul></li><li><p>$Tnew$表示位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。</p><ul><li>$Tnew$是一个动态值，每个指令处于流水线不同阶段有不同的$Tnew$值</li><li>一个指令在一个时刻至多有一个$Tnew$值（一个指令至多写一个寄存器）</li></ul></li><li><p>当$Tuse$ &gt;&#x3D; $Tnew$，说明需要的数据可以及时算出，可以通过<strong>转发</strong>来解决</p><p>当$Tuse$ &lt; $Tnew$，说明需要的数据不能及时算出，必须<strong>阻塞</strong>流水线解决</p></li></ul></blockquote><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><blockquote><ul><li>如果不需要写寄存器，只需要把A3Sel设为0即可。</li><li>此处<strong>WPC</strong>和<strong>WD</strong>均来自<strong>W级</strong>。</li></ul></blockquote><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa8</td><td>WD为<strong>当前流水线层级的PC</strong> + 8</td></tr></tbody></table><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_pc[31:0]</td><td>I</td><td>当前F级PC的值</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>当前D级PC的值</td></tr><tr><td>PCSel[1:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>branch</td><td>I</td><td>branch类型指令<strong>是否达到跳转条件</strong>，高电平有效</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即D_Instr[25:0]</td></tr><tr><td>offset[15:0]</td><td>I</td><td>branch类型指令的偏移量，即D_Instr[15:0]</td></tr><tr><td>ra[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器保存的地址值</td></tr><tr><td>next_pc[31:0]</td><td>O</td><td>下一指令的PC</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- GPR[rs]</td></tr></tbody></table><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>gpr_rs[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器中的值</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rt</code>寄存器中的值</td></tr><tr><td>CMPOp[1:0]</td><td>I</td><td>指定比较数据的方式</td></tr><tr><td>flag</td><td>O</td><td>是否满足所设条件，高电平有效</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>CMPOp</th><th>操作</th></tr></thead><tbody><tr><td>CMP_beq</td><td>beq指令: 若<code>GPR[rs] == GPR[rt]</code>，则flag置1，否则置0</td></tr></tbody></table><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="D-E级流水线寄存器"><a href="#D-E级流水线寄存器" class="headerlink" title="D&#x2F;E级流水线寄存器"></a>D&#x2F;E级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>D_extres[31:0]</td><td>I</td><td>16位立即数扩展的结果</td></tr><tr><td>D_gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>D_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>E_pc[31:0]</td><td>O</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>E_gpr_rs[31:0]</td><td>O</td><td>GPR[rs]</td></tr><tr><td>E_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="E级：执行（Execute）"><a href="#E级：执行（Execute）" class="headerlink" title="E级：执行（Execute）"></a>E级：执行（Execute）</h2><p>本级的输入为<code>D_PC</code>, <code>D_Instr</code>, <code>D_extres</code>, <code>D_gpr_rs</code>, <code>D_gpr_rt</code>。</p><p>本级的输出为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>, <code>E_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>D_fwd_gprrt</code>，和<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>参与流水。</p><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><p>详见<code>def.v</code>文件中的定义。</p><h3 id="E-MDU（乘除槽）"><a href="#E-MDU（乘除槽）" class="headerlink" title="E_MDU（乘除槽）"></a>E_MDU（乘除槽）</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>MDUOp[2:0]</td><td>I</td><td>指定乘除槽进行的操作</td></tr><tr><td>gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>start</td><td>I</td><td>指定乘除槽是否开始计算，高电平有效</td></tr><tr><td>busy</td><td>O</td><td>乘除槽是否处于运算过程中</td></tr><tr><td>HI[31:0]</td><td>O</td><td>32位HI寄存器值结果</td></tr><tr><td>LO[31:0]</td><td>O</td><td>32位LO寄存器值结果</td></tr></tbody></table><h4 id="控制信号-5"><a href="#控制信号-5" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>MDUOp</th><th>功能</th></tr></thead><tbody><tr><td><code>MDU_mult</code></td><td>乘法运算</td></tr><tr><td><code>MDU_div</code></td><td>除法运算</td></tr><tr><td><code>MDU_multu</code></td><td>无符号乘法运算</td></tr><tr><td><code>MDU_divu</code></td><td>无符号除法运算</td></tr><tr><td><code>MDU_mfhi</code></td><td><code>mfhi</code>指令</td></tr><tr><td><code>MDU_mflo</code></td><td><code>mflo</code>指令</td></tr><tr><td><code>MDU_mthi</code></td><td><code>mthi</code>指令，把<code>gpr_rs</code>的值赋给HI寄存器中</td></tr><tr><td><code>MDU_mtlo</code></td><td><code>mtlo</code>指令，把<code>gpr_rs</code>的值赋给LO寄存器中</td></tr></tbody></table><h3 id="E-M级流水线寄存器"><a href="#E-M级流水线寄存器" class="headerlink" title="E&#x2F;M级流水线寄存器"></a>E&#x2F;M级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>E_pc[31:0]</td><td>I</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>E_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>E_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>M_pc[31:0]</td><td>O</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>M_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="M级：存储器（Memory）"><a href="#M级：存储器（Memory）" class="headerlink" title="M级：存储器（Memory）"></a>M级：存储器（Memory）</h2><p>本级的输入为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>。</p><p>本级的输出为<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>, <code>M_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>M_fwd_gprrt</code>。</p><p>本机参与流水的有<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>。</p><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><p>本次实验只需要调用调用<code>mips_txt.v</code>中的接口即可，无需自行实现DM。</p><p>使用<code>fromRAM</code>模块处理DM返回的数据，使其符合写入寄存器的要求。</p><p>使用<code>toRAM</code>模块处理写入DM的数据，支持按照字、半字、字节的模式储存进DM。</p><h4 id="M-fromRAM"><a href="#M-fromRAM" class="headerlink" title="M_fromRAM"></a>M_fromRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行写操作的地址</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>m_data_rdata[31:0]</td><td>I</td><td>从<code>mips_txt.v</code>中的DM读出的数据</td></tr><tr><td>RD</td><td>O</td><td>处理后的正确的读取数据</td></tr></tbody></table><h4 id="M-toRAM"><a href="#M-toRAM" class="headerlink" title="M_toRAM"></a>M_toRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行读操作的地址</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>读取的待处理的寄存器数据</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>MemWrite</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>m_data_byteen[3:0]</td><td>O</td><td>控制写入数据在DM中的位置</td></tr><tr><td>m_data_wdata[31:0]</td><td>O</td><td>处理后的正确的待写入数据</td></tr></tbody></table><h4 id="控制信号-6"><a href="#控制信号-6" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h4 id="与mips-txt-v交互-1"><a href="#与mips-txt-v交互-1" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] M_dmrd;<br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> m_data_addr = M_aluans;<br><br>toRAM M_Store(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.gpr_rt</span>(M_fwd_gprrt),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.MemWrite</span>(M_MemWrite),<br>    <span class="hljs-variable">.m_data_byteen</span>(m_data_byteen),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_data_wdata)<br>);<br><br>fromRAM M_Load(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.m_data_rdata</span>(m_data_rdata),<br>    <span class="hljs-variable">.RD</span>(M_dmrd)<br>);<br><br><span class="hljs-keyword">assign</span> w_grf_wdata = W_grfWD;<br><span class="hljs-keyword">assign</span> w_inst_addr = W_PC;<br><span class="hljs-keyword">assign</span> w_grf_addr = W_A3Sel;<br></code></pre></td></tr></table></figure><h3 id="CP0协处理器"><a href="#CP0协处理器" class="headerlink" title="CP0协处理器"></a>CP0协处理器</h3><p>考虑到宏观PC的处理，将CP0置于M级较为合理。</p><p>将**异常码<code>ExcCode</code>、是否处于延迟槽中的判断信号<code>BDIn</code><strong>和</strong>当前<code>PC</code>**（如果时取指地址异常则传递错误的PC值）一直跟着流水线到达M级直至提交至CP0，由CP0综合判断分析是否响应该异常。</p><p>如果需要响应该异常，则CP0输出Req信号置为1，此时FD、DE、DM、MW寄存器响应Req信号，清空Instr，将PC值设为<code>0x00004180</code>，然后向F级NPC的NPC也被置为<code>0x00004180</code>，下一条指令从<code>0x00004180</code>开始执行。</p><p>当外设和系统外部输入中断信号时，CP0同样也会确认是否响应该中断，然后把Req置为1，执行相同的操作。</p><p>当系统外部输入中断信号时，CP0还会输出一个<code>IntResponse</code>信号指示是否响应外部中断信号，如果响应则系统会相应去写<code>0x00007f20</code>地址，从而时外部中断信号停止。</p><blockquote><p><strong>宏观PC</strong>表示整个 CPU “宏观”运行指令所对应的PC地址。</p><p>所谓“宏观”指令，表示该指令之前的所有指令序列对CPU的更新已完成，该指令及其之后的指令序列对 CPU 的更新未完成。</p></blockquote><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>CP0Add[4:0]</td><td>I</td><td>CP0中寄存器的地址</td></tr><tr><td>CP0In[31:0]</td><td>I</td><td>写入寄存器的32位数据</td></tr><tr><td>VPC[31:0]</td><td>I</td><td>受害PC</td></tr><tr><td>BDIn</td><td>I</td><td>是否为延迟槽内指令，高电平有效</td></tr><tr><td>ExcCodeIn[4:0]</td><td>I</td><td>异常码</td></tr><tr><td>HWInt[5:0]</td><td>I</td><td>外部硬件中断信号</td></tr><tr><td>EXLClr</td><td>I</td><td>将SR的Exl置0，高电平有效</td></tr><tr><td>CP0Out[31:0]</td><td>O</td><td>输出地址为<code>CP0Add</code>的寄存器的值</td></tr><tr><td>EPCOut[31:0]</td><td>O</td><td>输出当前<code>EPC</code>的值</td></tr><tr><td>Req</td><td>O</td><td>是否响应中断请求</td></tr><tr><td>IntResponse</td><td>O</td><td>是否响应<code>中断发生器</code>的中断请求</td></tr></tbody></table><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><table><thead><tr><th>寄存器</th><th>编号</th><th>功能</th></tr></thead><tbody><tr><td>SR</td><td>12</td><td>配置异常的功能</td></tr><tr><td>Cause</td><td>13</td><td>记录异常发生的原因和情况</td></tr><tr><td>EPC</td><td>14</td><td>记录异常处理结束后需要返回的 PC</td></tr></tbody></table><h4 id="功能域"><a href="#功能域" class="headerlink" title="功能域"></a>功能域</h4><table><thead><tr><th align="left">寄存器</th><th align="left">功能域</th><th align="left">位域</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">SR（State Register）</td><td align="left">IM（Interrupt Mask）</td><td align="left">15:10</td><td align="left">分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 <code>mtc0</code> 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr><td align="left">SR（State Register）</td><td align="left">EXL（Exception Level）</td><td align="left">1</td><td align="left">任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr><td align="left">SR（State Register）</td><td align="left">IE（Interrupt Enable）</td><td align="left">0</td><td align="left">全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。</td></tr><tr><td align="left">Cause</td><td align="left">BD（Branch Delay）</td><td align="left">31</td><td align="left">当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr><td align="left">Cause</td><td align="left">IP（Interrupt Pending）</td><td align="left">15:10</td><td align="left">为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr><td align="left">Cause</td><td align="left">ExcCode</td><td align="left">6:2</td><td align="left">异常编码，记录当前发生的是什么异常。</td></tr><tr><td align="left">EPC</td><td align="left">-</td><td align="left">-</td><td align="left">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><h4 id="异常码"><a href="#异常码" class="headerlink" title="异常码"></a>异常码</h4><table><tbody><tr>    <th width="120">异常与中断码</th>    <th width="145">助记符与名称</th>    <th>指令与指令类型</th>    <th>描述</th></tr><tr>    <td align="center">0</td>    <td align="center"><code>Int</code><br>（外部中断）</td>    <td align="center">所有指令</td>    <td>中断请求，来源于计时器与外部中断。</td></tr><tr>    <td rowspan="7" align="center">4</td>    <td rowspan="2" align="center"><code>AdEL</code><br>（取指异常）</td>    <td rowspan="2" align="center">所有指令</td>    <td>PC 地址未字对齐。</td></tr><tr>    <td>PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr>    <td rowspan="5" align="center"><code>AdEL</code><br>（取数异常）</td>    <td align="center"><code>lw</code></td>    <td>取数地址未与 4 字节对齐。</td></tr><tr>    <td align="center"><code>lh</code></td>    <td>取数地址未与 2 字节对齐。</td></tr><tr>    <td align="center"><code>lh</code>, <code>lb</code></td>    <td>取 Timer 寄存器的值。</td></tr><tr>    <td align="center">load 型指令</td>    <td>计算地址时加法溢出。</td></tr><tr>    <td align="center">load 型指令</td>    <td>取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr>    <td rowspan="6" align="center">5</td>    <td rowspan="6" align="center"><code>AdES</code><br>（存数异常）</td>    <td align="center"><code>sw</code></td>    <td>存数地址未 4 字节对齐。</td></tr><tr>    <td align="center"><code>sh</code></td>    <td>存数地址未 2 字节对齐。</td></tr><tr>    <td align="center"><code>sh</code>, <code>sb</code></td>    <td>存 Timer 寄存器的值。</td></tr><tr>    <td align="center">store 型指令</td>    <td>计算地址加法溢出。</td></tr><tr>    <td align="center">store 型指令</td>    <td>向计时器的 Count 寄存器存值。</td></tr><tr>    <td align="center">store 型指令</td>    <td>存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr>    <td align="center">8</td>    <td align="center"><code>Syscall</code><br>（系统调用）</td>    <td align="center"><code>syscall</code></td>    <td>系统调用。</td></tr><tr>    <td align="center">10</td>    <td align="center"><code>RI</code>（未知指令）</td>    <td align="center">-</td>    <td>未知的指令码。</td></tr><tr>    <td align="center">12</td>    <td align="center"><code>Ov</code>（溢出异常）</td>    <td align="center"><code>add</code>, <code>addi</code>, <code>sub</code></td>    <td>算术溢出。</td></tr></tbody></table><h3 id="M-W级流水线寄存器"><a href="#M-W级流水线寄存器" class="headerlink" title="M&#x2F;W级流水线寄存器"></a>M&#x2F;W级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>M_pc[31:0]</td><td>I</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>M_dmrd[31:0]</td><td>I</td><td>从DM中读取的值</td></tr><tr><td>W_pc[31:0]</td><td>O</td><td>W级PC</td></tr><tr><td>W_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>W_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>W_dmrd[31:0]</td><td>O</td><td>从DM中读取的值</td></tr></tbody></table><h2 id="W级：写回（Writeback）"><a href="#W级：写回（Writeback）" class="headerlink" title="W级：写回（Writeback）"></a>W级：写回（Writeback）</h2><p>本级与D级是重合的，需要处理向E级和M级的转发。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>采用<strong>暴力转发</strong>的方式。由AT法的分析，不阻塞就意味着一定能够在使用该寄存器的值之前获得最新的且正确的值。因此采用暴力转发总能得到一个正确的值去覆盖原先错误的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// D级转发</span><br><span class="hljs-keyword">assign</span> D_fwd_gprrs = (D_rs == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rs == E_A3Sel) ? E_grfWD :<br>                    (D_rs == M_A3Sel) ? M_grfWD : D_gpr_rs;<br><br><span class="hljs-keyword">assign</span> D_fwd_gprrt = (D_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rt == E_A3Sel) ? E_grfWD :<br>                    (D_rt == M_A3Sel) ? M_grfWD : D_gpr_rt;<br><br><br><span class="hljs-comment">// E级转发</span><br><span class="hljs-keyword">assign</span> E_grfWD = (E_WDSel == `WDSel_PCa8) ? (E_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>; <span class="hljs-comment">// 不能对功能部件输出进行转发</span><br><span class="hljs-keyword">assign</span> E_fwd_gprrs = (E_rs == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rs == M_A3Sel) ? M_grfWD :<br>                    (E_rs == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rs;<br><br><span class="hljs-keyword">assign</span> E_fwd_gprrt = (E_rt == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rt == M_A3Sel) ? M_grfWD :<br>                    (E_rt == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rt;<br><br><br><span class="hljs-comment">// M级转发</span><br><span class="hljs-keyword">assign</span> M_grfWD = (M_WDSel == `WDSel_aluans) ? M_aluans :<br>                (M_WDSel == `WDSel_mduans) ? M_mduans :<br>                (M_WDSel == `WDSel_PCa8) ? (M_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br><span class="hljs-keyword">assign</span> M_fwd_gprrt = (M_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">5&#x27;d0</span>) :<br>                    (M_rt == W_A3Sel) ? W_grfWD :<br>                    M_gpr_rt;<br><br><br><span class="hljs-comment">// W级转发</span><br><span class="hljs-keyword">assign</span> W_grfWD = (W_WDSel == `WDSel_aluans) ? W_aluans :<br>                (W_WDSel == `WDSel_dmrd) ? W_dmrd :<br>                (W_WDSel == `WDSel_mduans) ? W_mduans :<br>                (W_WDSel == `WDSel_PCa8) ? (W_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>使用组合逻辑，判断每一级中指令的$Tuse$和$Tnew$。</p><p>如果有$Tuse$ &lt; $Tnew$，就执行阻塞。<strong>只可能在D级进行阻塞</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// stall_handle.v</span><br><span class="hljs-keyword">assign</span> D_Tuse_rs = (D_branch | D_j2r) ? <span class="hljs-number">3&#x27;d0</span> :<br>                (D_ic | D_rc | D_load | (D_store &amp;&amp; !D_shift_s) | D_mt | D_md) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> D_Tuse_rt = (D_branch) ? <span class="hljs-number">3&#x27;d0</span> :<br>                    (D_rc | D_md) ? <span class="hljs-number">3&#x27;d1</span> :<br>                    (D_store | D_mtc0) ? <span class="hljs-number">3&#x27;d2</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> E_Tnew = (E_rc | E_ic | E_mf) ? <span class="hljs-number">3&#x27;d1</span> :<br>                (E_load | E_mfc0) ? <span class="hljs-number">3&#x27;d2</span> :<br>                <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> E_stall_rs = (E_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> E_stall_rt = (E_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> M_Tnew = (M_load | M_mfc0) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> M_stall_rs = (M_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> M_stall_rt = (M_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rt);<br><span class="hljs-keyword">assign</span> M_stall_eret = D_eret &amp;&amp; ((E_mtc0 &amp;&amp; E_rd == <span class="hljs-number">5&#x27;d14</span>) || (M_mtc0 &amp;&amp; M_rd == <span class="hljs-number">5&#x27;d14</span>));<br><br><span class="hljs-keyword">assign</span> E_stall_mdu = ((D_mf | D_mt | D_md) &amp;&amp; (E_MDU_busy | E_MDU_start));<br><br><br><span class="hljs-comment">// mips.v</span><br><span class="hljs-keyword">wire</span> stall;<br><span class="hljs-keyword">assign</span> FD_WE = !stall; <span class="hljs-comment">//冻结FD寄存器</span><br><span class="hljs-keyword">assign</span> IFU_WE = !stall; <span class="hljs-comment">//冻结PC</span><br><span class="hljs-keyword">assign</span> DE_flush = stall; <span class="hljs-comment">//清空DE寄存器</span><br><br><span class="hljs-keyword">assign</span> DE_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> EM_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> MW_WE = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">assign</span> FD_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> EM_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> MW_flush = <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h2 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h2><p>系统桥是处理CPU与外设（两个计时器）之间信息交互的通道。</p><p>CPU中store类指令需要储存的数据经过BE处理后会通过m_data_addr, m_data_byteen, m_data_wdata三个信号输出到桥中，桥会根据写使能m_data_byteen和地址m_data_addr来判断到底<strong>写的是内存还是外设</strong>，然后给出正确的写使能。</p><p>load类指令则是全部把地址传递给每个外设和DM中，然后桥根据地址选择从应该反馈给CPU从哪里读出来的数据，然后DE在处理读出的数据，反馈正确的结果。</p><table><thead><tr><th align="center">条目</th><th align="center">地址或地址范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">数据存储器</td><td align="center">0x0000_0000∼0x0000_2FFF</td><td align="center"></td></tr><tr><td align="center">指令存储器</td><td align="center">0x0000_3000∼0x0000_6FFF</td><td align="center"></td></tr><tr><td align="center">PC 初始值</td><td align="center">0x0000_3000</td><td align="center"></td></tr><tr><td align="center">异常处理程序入口地址</td><td align="center">0x0000_4180</td><td align="center"></td></tr><tr><td align="center">计时器 0 寄存器地址</td><td align="center">0x0000_7F00∼0x0000_7F0B</td><td align="center">计时器 0 的 3 个寄存器</td></tr><tr><td align="center">计时器 1 寄存器地址</td><td align="center">0x0000_7F10∼0x0000_7F1B</td><td align="center">计时器 1 的 3 个寄存器</td></tr><tr><td align="center">中断发生器响应地址</td><td align="center">0x0000_7F20∼0x0000_7F23</td><td align="center"></td></tr></tbody></table><p>Bridge的端口列表如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> bridge(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_rdata,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_addr,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_wdata,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] m_temp_data_byteen,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_out,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_out,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_addr,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_wdata,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] m_data_byteen,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_rdata,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_addr,<br>    <span class="hljs-keyword">output</span> TC0_WE,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_addr,<br>    <span class="hljs-keyword">output</span> TC1_WE,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_in<br>    );<br></code></pre></td></tr></table></figure><h2 id="MIPS微系统实现"><a href="#MIPS微系统实现" class="headerlink" title="MIPS微系统实现"></a>MIPS微系统实现</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// mips.v</span><br><br><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,                    <span class="hljs-comment">// 时钟信号</span><br>    <span class="hljs-keyword">input</span> reset,                  <span class="hljs-comment">// 同步复位信号</span><br>    <span class="hljs-keyword">input</span> interrupt,              <span class="hljs-comment">// 外部中断信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] macroscopic_pc, <span class="hljs-comment">// 宏观 PC</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_addr,    <span class="hljs-comment">// IM 读取地址（取指 PC）</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_rdata,   <span class="hljs-comment">// IM 读取数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_addr,    <span class="hljs-comment">// DM 读写地址</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_rdata,   <span class="hljs-comment">// DM 读取数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_wdata,   <span class="hljs-comment">// DM 待写入数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_data_byteen,  <span class="hljs-comment">// DM 字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_int_addr,     <span class="hljs-comment">// 中断发生器待写入地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_int_byteen,   <span class="hljs-comment">// 中断发生器字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_inst_addr,    <span class="hljs-comment">// M 级 PC</span><br><br>    <span class="hljs-keyword">output</span> w_grf_we,              <span class="hljs-comment">// GRF 写使能信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span> :<span class="hljs-number">0</span>] w_grf_addr,     <span class="hljs-comment">// GRF 待写入寄存器编号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_grf_wdata,    <span class="hljs-comment">// GRF 待写入数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_inst_addr     <span class="hljs-comment">// W 级 PC</span><br>    );<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_addr;<br><span class="hljs-keyword">wire</span> TC0_WE;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_in;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_out;<br><span class="hljs-keyword">wire</span> TC0_IRQ;<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_addr;<br><span class="hljs-keyword">wire</span> TC1_WE;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_in;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_out;<br><span class="hljs-keyword">wire</span> TC1_IRQ;<br><br>TC TC0(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.Addr</span>(TC0_addr[<span class="hljs-number">31</span>:<span class="hljs-number">2</span>]),<br>    <span class="hljs-variable">.WE</span>(TC0_WE),<br>    <span class="hljs-variable">.Din</span>(TC0_in),<br>    <span class="hljs-variable">.Dout</span>(TC0_out),<br>    <span class="hljs-variable">.IRQ</span>(TC0_IRQ)<br>);<br><br>TC TC1(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.Addr</span>(TC1_addr[<span class="hljs-number">31</span>:<span class="hljs-number">2</span>]),<br>    <span class="hljs-variable">.WE</span>(TC1_WE),<br>    <span class="hljs-variable">.Din</span>(TC1_in),<br>    <span class="hljs-variable">.Dout</span>(TC1_out),<br>    <span class="hljs-variable">.IRQ</span>(TC1_IRQ)<br>);<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_addr;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_rdata;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_wdata;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] m_temp_data_byteen;<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] HWInt;<br><span class="hljs-keyword">wire</span> HWIntResponse;<br><span class="hljs-keyword">assign</span> HWInt = &#123;<span class="hljs-number">3&#x27;b000</span>, interrupt, TC1_IRQ, TC0_IRQ&#125;;<br><br>cpu CPU(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.HWInt</span>(HWInt),<br>    <span class="hljs-variable">.macroscopic_pc</span>(macroscopic_pc),<br>    <span class="hljs-variable">.i_inst_rdata</span>(i_inst_rdata),<br>    <span class="hljs-variable">.m_data_rdata</span>(m_temp_data_rdata),<br>    <span class="hljs-variable">.i_inst_addr</span>(i_inst_addr),<br>    <span class="hljs-variable">.m_data_addr</span>(m_temp_data_addr),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_temp_data_wdata),<br>    <span class="hljs-variable">.m_data_byteen</span>(m_temp_data_byteen),<br>    <span class="hljs-variable">.m_inst_addr</span>(m_inst_addr),<br>    <span class="hljs-variable">.w_grf_we</span>(w_grf_we),<br>    <span class="hljs-variable">.w_grf_addr</span>(w_grf_addr),<br>    <span class="hljs-variable">.w_grf_wdata</span>(w_grf_wdata),<br>    <span class="hljs-variable">.w_inst_addr</span>(w_inst_addr),<br>    <span class="hljs-variable">.HWIntResponse</span>(HWIntResponse)<br>);<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bridge_m_data_addr;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] bridge_m_data_byteen;<br><br>bridge Bridge(<br>    <span class="hljs-variable">.m_data_rdata</span>(m_data_rdata),<br>    <span class="hljs-variable">.m_temp_data_addr</span>(m_temp_data_addr),<br>    <span class="hljs-variable">.m_temp_data_wdata</span>(m_temp_data_wdata),<br>    <span class="hljs-variable">.m_temp_data_byteen</span>(m_temp_data_byteen),<br>    <span class="hljs-variable">.TC0_out</span>(TC0_out),<br>    <span class="hljs-variable">.TC1_out</span>(TC1_out),<br>    <span class="hljs-variable">.m_data_addr</span>(bridge_m_data_addr),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_data_wdata),<br>    <span class="hljs-variable">.m_data_byteen</span>(bridge_m_data_byteen),<br>    <span class="hljs-variable">.m_temp_data_rdata</span>(m_temp_data_rdata),<br>    <span class="hljs-variable">.TC0_addr</span>(TC0_addr),<br>    <span class="hljs-variable">.TC0_WE</span>(TC0_WE),<br>    <span class="hljs-variable">.TC0_in</span>(TC0_in),<br>    <span class="hljs-variable">.TC1_addr</span>(TC1_addr),<br>    <span class="hljs-variable">.TC1_WE</span>(TC1_WE),<br>    <span class="hljs-variable">.TC1_in</span>(TC1_in)<br>);<br><br><span class="hljs-keyword">assign</span> m_data_addr = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">32&#x27;h0000_7f20</span> : bridge_m_data_addr;<br><span class="hljs-keyword">assign</span> m_data_byteen = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">4&#x27;b0001</span> : bridge_m_data_byteen;<br><br><span class="hljs-keyword">assign</span> m_int_addr = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">32&#x27;h0000_7f20</span> : bridge_m_data_addr;<br><span class="hljs-keyword">assign</span> m_int_byteen = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">4&#x27;b0001</span> : bridge_m_data_byteen;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>对特定的异常和中断编写程序进行测试。</p><h3 id="取值异常"><a href="#取值异常" class="headerlink" title="取值异常"></a>取值异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br><br>li $28, 0<br>li $29, 0<br><br># jr PC mod 4 not 0<br>la $1, label1<br>la $2, label1<br>addiu $1, $1, 1<br>jr $1<br>nop<br>label1:<br><br># jr PC &lt; 0x3000<br>li $1, 0x2996<br>la $2, label2<br>jr $1<br>nop<br>label2:<br><br># jr PC &gt; 0x4ffc<br>li $1, 0x4fff<br>la $2, label3<br>jr $1<br>nop<br>label3:<br><br>end:j end<br><br>.ktext 0x4180<br>mfc0 $12, $12<br>mfc0 $13, $13<br>mfc0 $14, $14<br>mtc0 $2, $14<br>eret<br>ori $1, $0, 0<br></code></pre></td></tr></table></figure><h3 id="存取地址异常"><a href="#存取地址异常" class="headerlink" title="存取地址异常"></a>存取地址异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text <br>ori$28, $0, 0x0000<br>ori$29, $0, 0x0f00<br>mtc0$0, $12<br><br>lui$8, 0x7fff<br>ori$8, $8, 0xffff<br><br>lui$9, 0x8000<br>ori$9, $9, 0x0000<br><br>lw$10, 1($8)# 测试对 lw 地址上界溢出的处理<br>lh$10, 1($8)# 测试对 lh 地址上界溢出的处理<br>lb$10, 1($8)# 测试对 lb 地址上界溢出的处理<br>lw$10,-1($9)# 测试对 lw 地址下界溢出的处理<br>lh$10,-1($9)# 测试对 lh 地址下界溢出的处理<br>lb$10,-1($9)# 测试对 lb 地址下界溢出的处理<br><br>sw$10, 1($8)# 测试对 sw 地址上界溢出的处理<br>sh$10, 1($8)# 测试对 sh 地址上界溢出的处理<br>sb$10, 1($8)# 测试对 sb 地址上界溢出的处理<br>sw$10,-1($9)# 测试对 sw 地址下界溢出的处理<br>sh$10,-1($9)# 测试对 sh 地址下界溢出的处理<br>sb$10,-1($9)# 测试对 sb 地址下界溢出的处理<br><br>end:j end<br><br><br>.ktext 0x4180<br>mfc0 $12, $12<br>mfc0 $13, $13<br>mfc0 $14, $14<br>addi $14, $14, 4<br>mtc0 $14, $14<br>eret<br>ori $1, $0, 0<br></code></pre></td></tr></table></figure><h3 id="计算溢出"><a href="#计算溢出" class="headerlink" title="计算溢出"></a>计算溢出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text <br>ori$28, $0, 0x0000<br>ori$29, $0, 0x0f00<br>mtc0$0, $12<br><br>lui$8, 0x7fff<br>ori$8, $8, 0xffff<br><br>lui$9, 0x8000<br>ori$9, $9, 0x0000<br><br>ori$10, 0x0001<br>lui$11, 0xffff<br>ori$11, $11, 0xffff<br><br>add$12, $10, $8# 测试 add 上界溢出的情况<br>add$12, $11, $9# 测试 add 下界溢出的情况<br>addi$12, $8, 1# 测试 addi 上界溢出的情况<br>addi$12, $9, -1# 测试 addi 下界溢出的情况<br>sub$12, $8, $11# 测试 sub 上界溢出的情况<br>sub$12, $9, $10# 测试 sub 下界溢出的情况<br></code></pre></td></tr></table></figure><h3 id="计时器功能"><a href="#计时器功能" class="headerlink" title="计时器功能"></a>计时器功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br>li $12, 0x0c01<br>mtc0 $12, $12<br><br>li $1, 500<br>li $2, 9<br><br>sw $1, 0x7f04($0)<br>sw $2, 0x7f00($0)<br>li $1, 1000<br>sw $1, 0x7f14($0)<br>sw $2, 0x7f10($0)<br><br>lw $1, 0x7f00($0)<br>lw $1, 0x7f04($0)<br>lw $1, 0x7f10($0)<br>lw $1, 0x7f14($0)<br><br>li $1, 0<br>li $2, 0<br><br>for:<br>ori $3, $3, 0<br>beq $1, $0, for<br>nop<br>beq $2, $0, for<br>nop<br><br>lw $1, 0x7f00($0)<br>lw $1, 0x7f04($0)<br>lw $1, 0x7f10($0)<br>lw $1, 0x7f14($0)<br><br>end:j end<br><br>.ktext 0x4180<br>mfc0 $13, $13<br>li $15, 0x7fffffff<br>and $13, $13, $15<br>li $14, 1024<br>beq $13, $14, timer0<br>nop<br>li $14, 2048<br>beq $13, $14, timer1<br>nop<br>eret<br><br>timer0:<br>li $1, 1<br>sw $0, 0x7f00($0)<br>eret<br><br>timer1:<br>li $2, 2<br>sw $0, 0x7f10($0)<br>eret<br></code></pre></td></tr></table></figure><h3 id="延迟槽异常"><a href="#延迟槽异常" class="headerlink" title="延迟槽异常"></a>延迟槽异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text <br>ori$28, $0, 0x0000<br>ori$29, $0, 0x0f00<br>mtc0$0, $12<br><br>jnxt1<br>lw$0, 1($0)# 测试延迟槽内 lw 地址不对齐异常<br>nxt1:<br>jnxt2<br>sw$0, 1($0)# 测试延迟槽内 sw 地址不对齐异常<br>nxt2:<br>lui$8, 0x7fff<br>ori$8, $8, 0xffff<br>jend<br>addi$10, $8, 1# 测试延迟槽内 addi 溢出异常<br>end:j end<br>nop<br></code></pre></td></tr></table></figure><h3 id="未知指令-系统调用"><a href="#未知指令-系统调用" class="headerlink" title="未知指令&#x2F;系统调用"></a>未知指令&#x2F;系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lui      $s0,0x8000<br>lui      $s1,0x7fff<br>ori      $s1,$s1,0xffff<br>syscall<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br>addi    $10,$s1,10<br>sw      $10,0x1002($0)<br>sh      $10,0x1001($0)<br>mult    $10,$10<br>lw      $10,0x1002($0)<br>lh      $10,0x1001($0)<br>mult    $10,$10<br>lh      $10,0x1001($0)<br>sub     $10,$s0,$s1<br>addi    $10,$s1,10<br>sw      $10,0x1002($0)<br>sh      $10,0x1001($0)<br>mult    $10,$10<br>sw      $10,0x1002($0)<br>sh      $10,0x1001($0)<br>lw      $10,0x1002($0)<br>lh      $10,0x1001($0)<br>lhu     $10,0x1001($0) # 未知指令<br>mult    $10,$10<br>sh      $10,0x1001($0)<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br>mult    $10,$10<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br>j label_1<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br></code></pre></td></tr></table></figure><h3 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ori $1,$1,0x7001<br>mtc0 $1,$12<br><br>#pc地址未对齐<br>ori $2,$2,0x300a<br>#jr $2<br>#add $2,$2,$2#顺便延迟槽<br>#pc地址超范围<br>#jr $2<br>#ori $3,$3,0x0003<br><br>#lw、lh没有字对齐<br>lw $2,0($3)<br>lh $2,1($0)<br>#lh、lb取Timer寄存器的值<br>ori $4,$4,0x7f00<br>lw $5,0($4)#应该没错<br>lh $5,0($4)<br>lb $5,20($4)<br>#计算地址加法溢出<br>lui $6,65535<br>ori $6,$6,65535<br>lw $7,1($6)<br>#取数地址超出范围<br>ori $7,0x7f0c<br>lw $7,0($7)<br><br>#sw、sh没有字对齐<br>sw $2,0($3)<br>sh $2,1($0)<br>#sh、sb取Timer寄存器的值<br>sw $5,0($4)#应该没错<br>sh $5,0($4)<br>sb $5,20($4)<br>#计算地址加法溢出<br>lui $6,65535<br>ori $6,$6,65535<br>sw $7,1($6)<br>#向计时器Count寄存器存值<br>sw $7,-4($7)<br>#存数地址超出范围<br>sw $7,100($7)<br><br>#syscall<br>syscall<br><br>#RI<br>nor $2,$3,$4<br><br>#算术溢出<br>addi $1,$0,1<br>sub $8,$0,$1<br>add $9,$8,$6#不应溢出<br>sub $9,$6,$8#溢出<br>add $9,$6,$7#溢出<br>sub $9,$0,$6<br>addi $9,$9,-100#溢出<br><br><br>end:<br>beq $0,$0,end#死循环<br>nop<br><br>#异常处理程序<br>.ktext 0x4180<br>mfc0 $k0,$12<br>mfc0 $k0,$13<br>mfc0 $k0,$14<br>addi $k0,$k0,4<br>mtc0 $k0,$14<br>eret<br>add $2,$2,$2#应当没有延迟槽<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>鼠标和键盘的输入信号都会转化为不同的系统中断信号，CPU根据中断信号的值可以执行对应的汇编指令。</p></li><li><p>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>依旧可以实现，无非是需要更改一下CPU中当出现异常或中断时要跳转到的异常处理程序地址，之后由用户提供的程序依旧可以对中断和异常进行处理。但入口常常变动会导致该CPU的适用性降低，换个执行指令段需要换个入口。</p></li><li><p>为何与外设通信需要 Bridge？</p><p>使得CPU不需要关心具体的数据从何而来，只需要知道地址即可。假如每个外设都要针对CPU做单独处理，那么时间与经济成本实在是过于昂贵且没必要了。</p></li><li><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>相同之处：在允许计数的情况下，都是从初值寄存器中获取初数值到计数值寄存器中开始计数，两种模式都受控制寄存器的控制<br>区别之处：模式0在计数结束后，会一直提供中断信号，直到IM或者EN被修改使其禁止中断或停止计数，模式1在计数结束后，只会提供一周期的中断信号，然后自动再次赋初值开始计数，知道IM或者EN被修改行为才会被改变</p><p>模式0的状态转移图如下：</p><pre><code class=" mermaid">stateDiagram[*] --&gt; IDLEIDLE --&gt; IDLE:resetIDLE --&gt; LOAD:ctrl[0] = 1LOAD --&gt; CNTCNT --&gt; CNT:ctrl[0] &amp;&amp; count &gt; 1CNT --&gt; INT:ctrl[0] &amp;&amp; count &lt;= 1INT --&gt; IDLE:ctrl[0] = 0 &amp;&amp; Int = 1CNT --&gt; IDLE:!ctrl[0]</code></pre><p>模式1的状态转移图如下：</p><pre><code class=" mermaid">stateDiagram[*] --&gt; IDLEIDLE --&gt; IDLE:resetIDLE --&gt; LOAD:ctrl[0] = 1LOAD --&gt; CNTCNT --&gt; CNT:ctrl[0] &amp;&amp; count &gt; 1CNT --&gt; INT:ctrl[0] &amp;&amp; count &lt;= 1INT --&gt; IDLE:Int = 0CNT --&gt; IDLE:ctrl[0] == 0</code></pre></li><li><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>会导致宏观PC突然为0，这显然是不合理的。在清空流水线的时候，应该保留PC信息。</p></li><li><p>为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><p>如果 <code>jalr $31 $31 </code>的延迟槽内发生异常或需要响应中断，由于此时 <code>$31</code> 寄存器的值已经被 <code>jalr</code> 改变，但是处理异常结束后，会再次执行 <code>jalr</code> 指令，从而就会跳转到不正确的 <code>PC</code> 地址。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P6 - 流水线CPU设计文档</title>
    <link href="/2023/11/28/P6%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/28/P6%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P6-流水线CPU设计文档"><a href="#P6-流水线CPU设计文档" class="headerlink" title="P6 流水线CPU设计文档"></a>P6 流水线CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li><p>设计的处理器为32位五级流水线处理器</p></li><li><p>处理器支持的指令集为</p><blockquote><p>add, sub, and, or, slt, sltu, lui<br>addi, andi, ori<br>lb, lh, lw, sb, sh, sw<br>mult, multu, div, divu, mfhi, mflo, mthi, mtlo<br>beq, bne, jal, jr</p></blockquote></li><li><p>所有运算类指令均暂不考虑因溢出而产生的异常</p></li></ul><p>整体架构参考了《数字设计与计算机体系结构》图7-58。</p><p><img src="https://pic.imgdb.cn/item/654cc27dc458853aef789452.png" alt="整体架构"></p><h2 id="F级：取指令（Fetch）"><a href="#F级：取指令（Fetch）" class="headerlink" title="F级：取指令（Fetch）"></a>F级：取指令（Fetch）</h2><p>本级的输入为来自D级的<code>next_pc</code>，用于更新下一个PC的值。</p><p>本级的输出为<code>F_PC</code>和<code>F_Instr</code>，分别对应从F级指令的PC和F级指令的内容，均需要参与流水。</p><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><p>只负责PC的存储与更新，F_instr来自<code>mips_txt.v</code>的交互。</p><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>PC写使能信号，高电平有效</td></tr><tr><td>next_pc[31:0]</td><td>I</td><td>待更新的指令地址</td></tr><tr><td>pc[31:0]</td><td>O</td><td>当前指令地址</td></tr></tbody></table><h4 id="与mips-txt-v交互"><a href="#与mips-txt-v交互" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog">ifu F_IFU(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.enable</span>(IFU_WE),<br>    <span class="hljs-variable">.next_pc</span>(next_PC),<br>    <span class="hljs-variable">.pc</span>(F_PC)<br>);<br><br><span class="hljs-keyword">assign</span> F_Instr = i_inst_rdata;<br><span class="hljs-keyword">assign</span> i_inst_addr = F_PC;<br></code></pre></td></tr></table></figure><h3 id="F-D级流水线寄存器"><a href="#F-D级流水线寄存器" class="headerlink" title="F&#x2F;D级流水线寄存器"></a>F&#x2F;D级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>F_pc[31:0]</td><td>I</td><td>F级PC</td></tr><tr><td>F_instr[31:0]</td><td>I</td><td>时钟信号</td></tr><tr><td>D_pc[31:0]</td><td>O</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>O</td><td>32位的指令值</td></tr></tbody></table><h2 id="D级：译码（Decode）"><a href="#D级：译码（Decode）" class="headerlink" title="D级：译码（Decode）"></a>D级：译码（Decode）</h2><p>本级的输入为来自F级的<code>F_PC</code>和<code>F_Instr</code>。</p><p>本级的输出为<code>D_gpr_rs</code>, <code>D_gpr_rt</code>, <code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>和<code>next_pc</code>。</p><p>本级涉及到来自E级、M级、W级的转发，其中来自W级的转发通过<strong>GRF内部转发</strong>的方式实现。</p><p><code>$rs</code>和<code>$rt</code>的值在本级转发成<code>D_fwd_gprrs</code>和<code>D_fwd_gprrt</code>，和<code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>参与流水。</p><p>本级需要对<strong>此级指令</strong>的$$Tuse$$和此时<strong>E级</strong>指令与<strong>M级指令</strong>的$Tnew$进行比较，从而确定是否执行阻塞。</p><blockquote><p>$Tuse$和$Tnew$:</p><ul><li><p>$Tuse$表示这条指令位于D级的时候，再经过多少个时钟周期就必须要使用相应的数据。</p><ul><li>每个指令的$Tuse$是固定不变的</li><li>一个指令可以有两个$Tuse$值</li></ul></li><li><p>$Tnew$表示位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。</p><ul><li>$Tnew$是一个动态值，每个指令处于流水线不同阶段有不同的$Tnew$值</li><li>一个指令在一个时刻至多有一个$Tnew$值（一个指令至多写一个寄存器）</li></ul></li><li><p>当$Tuse$ &gt;&#x3D; $Tnew$，说明需要的数据可以及时算出，可以通过<strong>转发</strong>来解决</p><p>当$Tuse$ &lt; $Tnew$，说明需要的数据不能及时算出，必须<strong>阻塞</strong>流水线解决</p></li></ul></blockquote><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><blockquote><ul><li>如果不需要写寄存器，只需要把A3Sel设为0即可。</li><li>此处<strong>WPC</strong>和<strong>WD</strong>均来自<strong>W级</strong>。</li></ul></blockquote><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa8</td><td>WD为<strong>当前流水线层级的PC</strong> + 8</td></tr></tbody></table><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_pc[31:0]</td><td>I</td><td>当前F级PC的值</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>当前D级PC的值</td></tr><tr><td>PCSel[1:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>branch</td><td>I</td><td>branch类型指令<strong>是否达到跳转条件</strong>，高电平有效</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即D_Instr[25:0]</td></tr><tr><td>offset[15:0]</td><td>I</td><td>branch类型指令的偏移量，即D_Instr[15:0]</td></tr><tr><td>ra[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器保存的地址值</td></tr><tr><td>next_pc[31:0]</td><td>O</td><td>下一指令的PC</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- GPR[rs]</td></tr></tbody></table><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>gpr_rs[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器中的值</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rt</code>寄存器中的值</td></tr><tr><td>CMPOp[1:0]</td><td>I</td><td>指定比较数据的方式</td></tr><tr><td>flag</td><td>O</td><td>是否满足所设条件，高电平有效</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>CMPOp</th><th>操作</th></tr></thead><tbody><tr><td>CMP_beq</td><td>beq指令: 若<code>GPR[rs] == GPR[rt]</code>，则flag置1，否则置0</td></tr></tbody></table><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="D-E级流水线寄存器"><a href="#D-E级流水线寄存器" class="headerlink" title="D&#x2F;E级流水线寄存器"></a>D&#x2F;E级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>D_extres[31:0]</td><td>I</td><td>16位立即数扩展的结果</td></tr><tr><td>D_gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>D_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>E_pc[31:0]</td><td>O</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>E_gpr_rs[31:0]</td><td>O</td><td>GPR[rs]</td></tr><tr><td>E_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="E级：执行（Execute）"><a href="#E级：执行（Execute）" class="headerlink" title="E级：执行（Execute）"></a>E级：执行（Execute）</h2><p>本级的输入为<code>D_PC</code>, <code>D_Instr</code>, <code>D_extres</code>, <code>D_gpr_rs</code>, <code>D_gpr_rt</code>。</p><p>本级的输出为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>, <code>E_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>D_fwd_gprrt</code>，和<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>参与流水。</p><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><p>详见<code>def.v</code>文件中的定义。</p><h3 id="E-MDU（乘除槽）"><a href="#E-MDU（乘除槽）" class="headerlink" title="E_MDU（乘除槽）"></a>E_MDU（乘除槽）</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>MDUOp[2:0]</td><td>I</td><td>指定乘除槽进行的操作</td></tr><tr><td>gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>start</td><td>I</td><td>指定乘除槽是否开始计算，高电平有效</td></tr><tr><td>busy</td><td>O</td><td>乘除槽是否处于运算过程中</td></tr><tr><td>HI[31:0]</td><td>O</td><td>32位HI寄存器值结果</td></tr><tr><td>LO[31:0]</td><td>O</td><td>32位LO寄存器值结果</td></tr></tbody></table><h4 id="控制信号-5"><a href="#控制信号-5" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>MDUOp</th><th>功能</th></tr></thead><tbody><tr><td><code>MDU_mult</code></td><td>乘法运算</td></tr><tr><td><code>MDU_div</code></td><td>除法运算</td></tr><tr><td><code>MDU_multu</code></td><td>无符号乘法运算</td></tr><tr><td><code>MDU_divu</code></td><td>无符号除法运算</td></tr><tr><td><code>MDU_mfhi</code></td><td><code>mfhi</code>指令</td></tr><tr><td><code>MDU_mflo</code></td><td><code>mflo</code>指令</td></tr><tr><td><code>MDU_mthi</code></td><td><code>mthi</code>指令，把<code>gpr_rs</code>的值赋给HI寄存器中</td></tr><tr><td><code>MDU_mtlo</code></td><td><code>mtlo</code>指令，把<code>gpr_rs</code>的值赋给LO寄存器中</td></tr></tbody></table><h3 id="E-M级流水线寄存器"><a href="#E-M级流水线寄存器" class="headerlink" title="E&#x2F;M级流水线寄存器"></a>E&#x2F;M级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>E_pc[31:0]</td><td>I</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>E_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>E_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>M_pc[31:0]</td><td>O</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>M_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="M级：存储器（Memory）"><a href="#M级：存储器（Memory）" class="headerlink" title="M级：存储器（Memory）"></a>M级：存储器（Memory）</h2><p>本级的输入为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>。</p><p>本级的输出为<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>, <code>M_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>M_fwd_gprrt</code>。</p><p>本机参与流水的有<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>。</p><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><p>本次实验只需要调用调用<code>mips_txt.v</code>中的接口即可，无需自行实现DM。</p><p>使用<code>fromRAM</code>模块处理DM返回的数据，使其符合写入寄存器的要求。</p><p>使用<code>toRAM</code>模块处理写入DM的数据，支持按照字、半字、字节的模式储存进DM。</p><h4 id="M-fromRAM"><a href="#M-fromRAM" class="headerlink" title="M_fromRAM"></a>M_fromRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行写操作的地址</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>m_data_rdata[31:0]</td><td>I</td><td>从<code>mips_txt.v</code>中的DM读出的数据</td></tr><tr><td>RD</td><td>O</td><td>处理后的正确的读取数据</td></tr></tbody></table><h4 id="M-toRAM"><a href="#M-toRAM" class="headerlink" title="M_toRAM"></a>M_toRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行读操作的地址</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>读取的待处理的寄存器数据</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>MemWrite</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>m_data_byteen[3:0]</td><td>O</td><td>控制写入数据在DM中的位置</td></tr><tr><td>m_data_wdata[31:0]</td><td>O</td><td>处理后的正确的待写入数据</td></tr></tbody></table><h4 id="控制信号-6"><a href="#控制信号-6" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h4 id="与mips-txt-v交互-1"><a href="#与mips-txt-v交互-1" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] M_dmrd;<br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> m_data_addr = M_aluans;<br><br>toRAM M_Store(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.gpr_rt</span>(M_fwd_gprrt),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.MemWrite</span>(M_MemWrite),<br>    <span class="hljs-variable">.m_data_byteen</span>(m_data_byteen),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_data_wdata)<br>);<br><br>fromRAM M_Load(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.m_data_rdata</span>(m_data_rdata),<br>    <span class="hljs-variable">.RD</span>(M_dmrd)<br>);<br><br><span class="hljs-keyword">assign</span> w_grf_wdata = W_grfWD;<br><span class="hljs-keyword">assign</span> w_inst_addr = W_PC;<br><span class="hljs-keyword">assign</span> w_grf_addr = W_A3Sel;<br></code></pre></td></tr></table></figure><h3 id="M-W级流水线寄存器"><a href="#M-W级流水线寄存器" class="headerlink" title="M&#x2F;W级流水线寄存器"></a>M&#x2F;W级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>M_pc[31:0]</td><td>I</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>M_dmrd[31:0]</td><td>I</td><td>从DM中读取的值</td></tr><tr><td>W_pc[31:0]</td><td>O</td><td>W级PC</td></tr><tr><td>W_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>W_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>W_dmrd[31:0]</td><td>O</td><td>从DM中读取的值</td></tr></tbody></table><h2 id="W级：写回（Writeback）"><a href="#W级：写回（Writeback）" class="headerlink" title="W级：写回（Writeback）"></a>W级：写回（Writeback）</h2><p>本级与D级是重合的，需要处理向E级和M级的转发。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>采用<strong>暴力转发</strong>的方式。由AT法的分析，不阻塞就意味着一定能够在使用该寄存器的值之前获得最新的且正确的值。因此采用暴力转发总能得到一个正确的值去覆盖原先错误的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// D级转发</span><br><span class="hljs-keyword">assign</span> D_fwd_gprrs = (D_rs == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rs == E_A3Sel) ? E_grfWD :<br>                    (D_rs == M_A3Sel) ? M_grfWD : D_gpr_rs;<br><br><span class="hljs-keyword">assign</span> D_fwd_gprrt = (D_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rt == E_A3Sel) ? E_grfWD :<br>                    (D_rt == M_A3Sel) ? M_grfWD : D_gpr_rt;<br><br><br><span class="hljs-comment">// E级转发</span><br><span class="hljs-keyword">assign</span> E_grfWD = (E_WDSel == `WDSel_PCa8) ? (E_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>; <span class="hljs-comment">// 不能对功能部件输出进行转发</span><br><span class="hljs-keyword">assign</span> E_fwd_gprrs = (E_rs == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rs == M_A3Sel) ? M_grfWD :<br>                    (E_rs == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rs;<br><br><span class="hljs-keyword">assign</span> E_fwd_gprrt = (E_rt == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rt == M_A3Sel) ? M_grfWD :<br>                    (E_rt == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rt;<br><br><br><span class="hljs-comment">// M级转发</span><br><span class="hljs-keyword">assign</span> M_grfWD = (M_WDSel == `WDSel_aluans) ? M_aluans :<br>                (M_WDSel == `WDSel_mduans) ? M_mduans :<br>                (M_WDSel == `WDSel_PCa8) ? (M_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br><span class="hljs-keyword">assign</span> M_fwd_gprrt = (M_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">5&#x27;d0</span>) :<br>                    (M_rt == W_A3Sel) ? W_grfWD :<br>                    M_gpr_rt;<br><br><br><span class="hljs-comment">// W级转发</span><br><span class="hljs-keyword">assign</span> W_grfWD = (W_WDSel == `WDSel_aluans) ? W_aluans :<br>                (W_WDSel == `WDSel_dmrd) ? W_dmrd :<br>                (W_WDSel == `WDSel_mduans) ? W_mduans :<br>                (W_WDSel == `WDSel_PCa8) ? (W_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>使用组合逻辑，判断每一级中指令的$Tuse$和$Tnew$。</p><p>如果有$Tuse$ &lt; $Tnew$，就执行阻塞。<strong>只可能在D级进行阻塞</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// stall_handle.v</span><br><span class="hljs-keyword">assign</span> D_Tuse_rs = (D_branch | D_j2r) ? <span class="hljs-number">3&#x27;d0</span> :<br>                (D_ic | D_rc | D_load | D_store | D_mt | D_md) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> D_Tuse_rt = (D_branch) ? <span class="hljs-number">3&#x27;d0</span> :<br>                    (D_rc | D_md) ? <span class="hljs-number">3&#x27;d1</span> :<br>                    (D_store) ? <span class="hljs-number">3&#x27;d2</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> E_Tnew = (E_rc | E_ic | E_mf) ? <span class="hljs-number">3&#x27;d1</span> :<br>                (E_load) ? <span class="hljs-number">3&#x27;d2</span> :<br>                <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> E_stall_rs = (E_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> E_stall_rt = (E_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> M_Tnew = (M_load) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> M_stall_rs = (M_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> M_stall_rt = (M_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt | E_stall_mdu;<br><br><br><span class="hljs-comment">// mips.v</span><br><span class="hljs-keyword">wire</span> stall;<br><span class="hljs-keyword">assign</span> FD_WE = !stall; <span class="hljs-comment">//冻结FD寄存器</span><br><span class="hljs-keyword">assign</span> IFU_WE = !stall; <span class="hljs-comment">//冻结PC</span><br><span class="hljs-keyword">assign</span> DE_flush = stall; <span class="hljs-comment">//清空DE寄存器</span><br><br><span class="hljs-keyword">assign</span> DE_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> EM_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> MW_WE = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">assign</span> FD_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> EM_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> MW_flush = <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>改进了P5的随机数据生成器，添加了延迟槽。</p><p>一个测试数据如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t4</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t5</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">jal </span>out<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span>,$<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-built_in">a1</span>,end<br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a2</span>,<span class="hljs-number">111</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-built_in">ra</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>为什么需要有单独的乘除法部件而不是整合进ALU？为何需要有独立的HI、LO寄存器？</p><p>乘除法的延迟远大于ALU，若整合进ALU，根据木桶原理，CPU整体周期将大幅增加。增加HI和LO寄存器可以让乘除法指令和其它指令并行执行，需要结果时再取出即可。</p></li><li><p>真实的流水线CPU是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p><p>乘法通常有若干个较小的组合逻辑的乘法单元组成，然后每个周期计算特定的几位，依次累加起来，于是会在几个周期后得到正确的最终结果；</p><p>除法通常使用试商法，通常也是使用组合逻辑在一个周期内计算4位左右的商，经过8个周期正好可以计算结束。</p></li><li><p>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p><p>当Busy信号或Start信号为 1 时，<code>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</code> 等乘除法相关的指令均被阻塞在 D 流水级。</p></li><li><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p><p>使用字节使能大幅度提高M级的效率，控制器提供控制信号，存储器决定最终存储地址，使得每个模块的功能更加清晰。</p></li><li><p>请思考，我们在按字节读和按字节写时，实际从DM获得的数据和向DM写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p><p>不是，读取到的是DM所在字的数据。只实现按字使能，就不得不先读取值再进行更改，这样数据通路就延长了，导致效率下降。</p><p>访问类型只占一个字节时，比如C语言中的<code>char</code>类型，按字节访问内存相对于按字访问内存性能上更有优势。</p></li><li><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p><p>将指令集按照一定的规则进行分类。P6完全沿用了 P5 的分类方法，新增的指令对应的特点都没有脱离这些分类，因此对于每条指令而言，只需译码后将其加入对应的分类。相同的类别在译码上有共同的结果，可以避免偶然错误。转发部分完全不用改，暂停部分只需添加一个因乘除块而导致的暂停。</p></li><li><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>P6比P5增加了乘除槽的冲突，在进行乘除指令后紧接着立即执行mfhi或mflo会造成数据冲突。此时应进行阻塞，直到乘除指令执行完成为止。</p><p>构造样例如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t0</span>,<span class="hljs-number">0x0123</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t2</span>,<span class="hljs-number">0xffff</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t0</span>,<span class="hljs-number">0x9576</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t1</span>,<span class="hljs-number">0xa312</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s1</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s1</span><br><span class="hljs-keyword">multu </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s1</span><br></code></pre></td></tr></table></figure></li><li><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</p><p>新增冲突只有一条，所以构造上述测试样例足够。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P5 - 流水线CPU设计文档</title>
    <link href="/2023/11/13/P5-%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/13/P5-%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P5-流水线CPU设计文档"><a href="#P5-流水线CPU设计文档" class="headerlink" title="P5 流水线CPU设计文档"></a>P5 流水线CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li>设计的处理器为32位五级流水线处理器</li><li>处理器支持的指令集为<code>add, sub, ori, lw, sw, beq, lui, addi, nop，j，jal，jr，lb，sb，lh，sh</code>等</li><li><code>add, sub</code>按无符号加减法处理，不考虑溢出</li></ul><p>整体架构参考了《数字设计与计算机体系结构》图7-58。</p><p><img src="https://pic.imgdb.cn/item/654cc27dc458853aef789452.png" alt="整体架构"></p><h2 id="F级：取指令（Fetch）"><a href="#F级：取指令（Fetch）" class="headerlink" title="F级：取指令（Fetch）"></a>F级：取指令（Fetch）</h2><p>本级的输入为来自D级的<code>next_pc</code>，用于更新下一个PC的值。</p><p>本级的输出为<code>F_PC</code>和<code>F_Instr</code>，分别对应从F级指令的PC和F级指令的内容，均需要参与流水。</p><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>PC写使能信号，高电平有效</td></tr><tr><td>next_pc[31:0]</td><td>I</td><td>待更新的指令地址</td></tr><tr><td>pc[31:0]</td><td>O</td><td>当前指令地址</td></tr><tr><td>instr[31:0]</td><td>O</td><td>当前PC对应的32位指令</td></tr></tbody></table><h3 id="F-D级流水线寄存器"><a href="#F-D级流水线寄存器" class="headerlink" title="F&#x2F;D级流水线寄存器"></a>F&#x2F;D级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>F_pc[31:0]</td><td>I</td><td>F级PC</td></tr><tr><td>F_instr[31:0]</td><td>I</td><td>时钟信号</td></tr><tr><td>D_pc[31:0]</td><td>O</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>O</td><td>32位的指令值</td></tr></tbody></table><h2 id="D级：译码（Decode）"><a href="#D级：译码（Decode）" class="headerlink" title="D级：译码（Decode）"></a>D级：译码（Decode）</h2><p>本级的输入为来自F级的<code>F_PC</code>和<code>F_Instr</code>。</p><p>本级的输出为<code>D_gpr_rs</code>, <code>D_gpr_rt</code>, <code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>和<code>next_pc</code>。</p><p>本级涉及到来自E级、M级、W级的转发，其中来自W级的转发通过<strong>GRF内部转发</strong>的方式实现。</p><p><code>$rs</code>和<code>$rt</code>的值在本级转发成<code>D_fwd_gprrs</code>和<code>D_fwd_gprrt</code>，和<code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>参与流水。</p><p>本级需要对<strong>此级指令</strong>的$$Tuse$$和此时<strong>E级</strong>指令与<strong>M级指令</strong>的$Tnew$进行比较，从而确定是否执行阻塞。</p><blockquote><p>$Tuse$和$Tnew$:</p><ul><li><p>$Tuse$表示这条指令位于D级的时候，再经过多少个时钟周期就必须要使用相应的数据。</p><ul><li>每个指令的$Tuse$是固定不变的</li><li>一个指令可以有两个$Tuse$值</li></ul></li><li><p>$Tnew$表示位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。</p><ul><li>$Tnew$是一个动态值，每个指令处于流水线不同阶段有不同的$Tnew$值</li><li>一个指令在一个时刻至多有一个$Tnew$值（一个指令至多写一个寄存器）</li></ul></li><li><p>当$Tuse$ &gt;&#x3D; $Tnew$，说明需要的数据可以及时算出，可以通过<strong>转发</strong>来解决</p><p>当$Tuse$ &lt; $Tnew$，说明需要的数据不能及时算出，必须<strong>阻塞</strong>流水线解决</p></li></ul></blockquote><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><blockquote><ul><li>如果不需要写寄存器，只需要把A3Sel设为0即可。</li><li>此处<strong>WPC</strong>和<strong>WD</strong>均来自<strong>W级</strong>。</li></ul></blockquote><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa8</td><td>WD为<strong>当前流水线层级的PC</strong> + 8</td></tr></tbody></table><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_pc[31:0]</td><td>I</td><td>当前F级PC的值</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>当前D级PC的值</td></tr><tr><td>PCSel[1:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>branch</td><td>I</td><td>branch类型指令<strong>是否达到跳转条件</strong>，高电平有效</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即D_Instr[25:0]</td></tr><tr><td>offset[15:0]</td><td>I</td><td>branch类型指令的偏移量，即D_Instr[15:0]</td></tr><tr><td>ra[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器保存的地址值</td></tr><tr><td>next_pc[31:0]</td><td>O</td><td>下一指令的PC</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- GPR[rs]</td></tr></tbody></table><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>gpr_rs[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器中的值</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rt</code>寄存器中的值</td></tr><tr><td>CMPOp[1:0]</td><td>I</td><td>指定比较数据的方式</td></tr><tr><td>flag</td><td>O</td><td>是否满足所设条件，高电平有效</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>CMPOp</th><th>操作</th></tr></thead><tbody><tr><td>CMP_beq</td><td>beq指令: 若<code>GPR[rs] == GPR[rt]</code>，则flag置1，否则置0</td></tr></tbody></table><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="D-E级流水线寄存器"><a href="#D-E级流水线寄存器" class="headerlink" title="D&#x2F;E级流水线寄存器"></a>D&#x2F;E级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>D_extres[31:0]</td><td>I</td><td>16位立即数扩展的结果</td></tr><tr><td>D_gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>D_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>E_pc[31:0]</td><td>O</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>E_gpr_rs[31:0]</td><td>O</td><td>GPR[rs]</td></tr><tr><td>E_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="E级：执行（Execute）"><a href="#E级：执行（Execute）" class="headerlink" title="E级：执行（Execute）"></a>E级：执行（Execute）</h2><p>本级的输入为<code>D_PC</code>, <code>D_Instr</code>, <code>D_extres</code>, <code>D_gpr_rs</code>, <code>D_gpr_rt</code>。</p><p>本级的输出为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>, <code>E_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>D_fwd_gprrt</code>，和<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>参与流水。</p><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>ALUOp</th><th>操作</th></tr></thead><tbody><tr><td>ALU_add</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_sub</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_or</td><td>result &#x3D; A | B</td></tr><tr><td>ALU_lui</td><td>result &#x3D; B | 10<sup>16</sup></td></tr></tbody></table><h3 id="E-M级流水线寄存器"><a href="#E-M级流水线寄存器" class="headerlink" title="E&#x2F;M级流水线寄存器"></a>E&#x2F;M级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>E_pc[31:0]</td><td>I</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>E_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>E_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>M_pc[31:0]</td><td>O</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>M_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="M级：存储器（Memory）"><a href="#M级：存储器（Memory）" class="headerlink" title="M级：存储器（Memory）"></a>M级：存储器（Memory）</h2><p>本级的输入为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>。</p><p>本级的输出为<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>, <code>M_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>M_fwd_gprrt</code>。</p><p>本机参与流水的有<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>。</p><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>WE</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>A[31:0]</td><td>I</td><td>需要进行读&#x2F;写操作的地址</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位写入RAM的数据</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定DM进行的读&#x2F;写操作方式</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入DM时对应的指令PC值</td></tr><tr><td>RD[31:0]</td><td>O</td><td>32位从RAM读出的输出数据</td></tr></tbody></table><h4 id="控制信号-5"><a href="#控制信号-5" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h3 id="M-W级流水线寄存器"><a href="#M-W级流水线寄存器" class="headerlink" title="M&#x2F;W级流水线寄存器"></a>M&#x2F;W级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>M_pc[31:0]</td><td>I</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>M_dmrd[31:0]</td><td>I</td><td>从DM中读取的值</td></tr><tr><td>W_pc[31:0]</td><td>O</td><td>W级PC</td></tr><tr><td>W_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>W_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>W_dmrd[31:0]</td><td>O</td><td>从DM中读取的值</td></tr></tbody></table><h2 id="W级：写回（Writeback）"><a href="#W级：写回（Writeback）" class="headerlink" title="W级：写回（Writeback）"></a>W级：写回（Writeback）</h2><p>本级与D级是重合的，需要处理向E级和M级的转发。</p><h2 id="控制信号-6"><a href="#控制信号-6" class="headerlink" title="控制信号"></a>控制信号</h2><p>采用分布式译码的方式，在每一级对指令译码生成控制信号</p><table><thead><tr><th align="center"></th><th align="center">opcode</th><th align="center">funct</th><th align="center">A3Sel</th><th align="center">ALUOp</th><th align="center">ALUBSel</th><th align="center">WDSel</th><th align="center">MemWrite</th><th align="center">PCSel</th><th align="center">EXTOp</th><th align="center">DMOp</th></tr></thead><tbody><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td><td align="center">rd</td><td align="center">ALU_add</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td><td align="center">rd</td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_or</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center"></td><td align="center"></td><td align="center">PCSel_branch</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_lui</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">j</td><td align="center">000010</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jal</td><td align="center">000011</td><td align="center"><strong>undefined</strong></td><td align="center">ra</td><td align="center"></td><td align="center"></td><td align="center">WDSel_PCa4</td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jr</td><td align="center">001000</td><td align="center">001000</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_jr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lb</td><td align="center">100000</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">sb</td><td align="center">101000</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">lh</td><td align="center">100001</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr><tr><td align="center">sh</td><td align="center">101001</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr></tbody></table><blockquote><p> A3Sel一列缺省值为5’d0，PCSel一列缺省值为PCSel_PCa8</p></blockquote><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>采用<strong>暴力转发</strong>的方式。由AT法的分析，不阻塞就意味着一定能够在使用该寄存器的值之前获得最新的且正确的值。因此采用暴力转发总能得到一个正确的值去覆盖原先错误的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// D级转发</span><br><span class="hljs-keyword">assign</span> D_fwd_gprrs = (D_rs == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rs == E_A3Sel) ? E_grfWD :<br>                    (D_rs == M_A3Sel) ? M_grfWD : D_gpr_rs;<br><br><span class="hljs-keyword">assign</span> D_fwd_gprrt = (D_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rt == E_A3Sel) ? E_grfWD :<br>                    (D_rt == M_A3Sel) ? M_grfWD : D_gpr_rt;<br><br><br><span class="hljs-comment">// GRF内部转发</span><br><span class="hljs-keyword">assign</span> RD1 = (A1 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A1 == A3) ? WD : registers[A1];<br><span class="hljs-keyword">assign</span> RD2 = (A2 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A2 == A3) ? WD : registers[A2];<br><br><br><span class="hljs-comment">// E级转发</span><br><span class="hljs-keyword">assign</span> E_grfWD = (E_WDSel == `WDSel_PCa8) ? (E_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>; <span class="hljs-comment">// 不能对功能部件输出进行转发</span><br><span class="hljs-keyword">assign</span> E_fwd_gprrs = (E_rs == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rs == M_A3Sel) ? M_grfWD :<br>                    (E_rs == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rs;<br><br><span class="hljs-keyword">assign</span> E_fwd_gprrt = (E_rt == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rt == M_A3Sel) ? M_grfWD :<br>                    (E_rt == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rt;<br><br><br><span class="hljs-comment">// M级转发</span><br><span class="hljs-keyword">assign</span> M_grfWD = (M_WDSel == `WDSel_aluans) ? M_aluans :<br>                (M_WDSel == `WDSel_PCa8) ? (M_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br><span class="hljs-keyword">assign</span> M_fwd_gprrt = (M_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">5&#x27;d0</span>) :<br>                    (M_rt == W_A3Sel) ? W_grfWD :<br>                    M_gpr_rt;<br><br><br><span class="hljs-comment">// W级转发</span><br><span class="hljs-keyword">assign</span> W_grfWD = (W_WDSel == `WDSel_aluans) ? W_aluans :<br>                (W_WDSel == `WDSel_dmrd) ? W_dmrd :<br>                (W_WDSel == `WDSel_PCa8) ? (W_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>使用组合逻辑，判断每一级中指令的$Tuse$和$Tnew$。</p><p>如果有$Tuse$ &lt; $Tnew$，就执行阻塞。<strong>只可能在D级进行阻塞</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// stall_handle.v</span><br><span class="hljs-keyword">assign</span> D_Tuse_rs = (D_branch | D_j2r) ? <span class="hljs-number">3&#x27;d0</span> :<br>                (D_ic | D_rc | D_load | D_store) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> D_Tuse_rt = (D_branch) ? <span class="hljs-number">3&#x27;d0</span> :<br>                    (D_rc) ? <span class="hljs-number">3&#x27;d1</span> :<br>                    (D_store) ? <span class="hljs-number">3&#x27;d2</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> E_Tnew = (E_rc | E_ic) ? <span class="hljs-number">3&#x27;d1</span> :<br>                (E_load) ? <span class="hljs-number">3&#x27;d2</span> :<br>                <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> E_stall_rs = (E_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> E_stall_rt = (E_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> M_Tnew = (M_load) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> M_stall_rs = (M_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> M_stall_rt = (M_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt;<br><br><br><span class="hljs-comment">// mips.v</span><br><span class="hljs-keyword">wire</span> stall;<br><span class="hljs-keyword">assign</span> FD_WE = !stall; <span class="hljs-comment">//冻结FD寄存器</span><br><span class="hljs-keyword">assign</span> IFU_WE = !stall; <span class="hljs-comment">//冻结PC</span><br><span class="hljs-keyword">assign</span> DE_flush = stall; <span class="hljs-comment">//清空DE寄存器</span><br><br><span class="hljs-keyword">assign</span> DE_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> EM_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> MW_WE = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">assign</span> FD_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> EM_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> MW_flush = <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>改进了P4的随机数据生成器，添加了延迟槽。</p><p>一个测试数据如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t4</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t5</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">jal </span>out<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span>,$<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-built_in">a1</span>,end<br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a2</span>,<span class="hljs-number">111</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-built_in">ra</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p><p>branch类型的$Tuse$为0，很可能产生$Tnew$ &gt; $Tuse$，从而产生堵塞</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-number">8</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">9</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x2</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">8</span>, $<span class="hljs-number">9</span>, L1<br></code></pre></td></tr></table></figure></li><li><p>因为延迟槽的存在，对于jal等需要将指令地址写入寄存器的指令，要写回PC + 8，请思考为什么这样设计？</p><p>jal的后一条指令处于延迟槽中，无论判断结果如何，都将执行分支或跳转指令的下一条指令。</p><p>如果写回PC + 4，那么执行<code>jr $ra</code>时，将会跳回到延迟槽的指令，导致其被重复执行。</p></li><li><p>我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如DM、ALU），请思考为什么？</p><p>会造成关键路径变长，使得流水线各部分延迟不均衡，产生“木桶效应”使流水线性能严重下降。</p><p>假设有DM到ALU输入的转发，那么修改之后，E级的周期将从原来的<code>ALU延迟</code>变为<code>ALU延迟 + DM延迟</code>，降低了时间频率。</p></li><li><p>我们为什么要使用 GPR 内部转发？该如何实现？</p><p>使得W级将要写入的数据及时反馈到GRF的输出端口，在一个时间周期内完成写和读，解决“写后读”冲突。</p><p>实现方法为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> RD1 = (A1 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A1 == A3) ? WD : registers[A1];<br><span class="hljs-keyword">assign</span> RD2 = (A2 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A2 == A3) ? WD : registers[A2];<br></code></pre></td></tr></table></figure></li><li><p>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p><p>见“转发”部分。</p></li><li><p>在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p><p>增加的指令主要分为三种类型：<strong>计算、跳转、存储</strong>。</p><p>计算指令的处理步骤</p><ul><li>修改ALU支持新的运算，感觉用<code>always @(*)</code>块比用<code>assign</code>写起来方便，善用<code>function</code>模块</li><li>$Tuse$和$Tnew$与<code>calc_rc</code>（R型计算指令）保持一致</li></ul><p>跳转指令的处理步骤</p><ul><li>前几个P遇到过的跳转类指令有<code>条件跳转+无条件链接</code>，<code>条件跳转+条件链接</code>，<code>条件跳转+（无）条件链接+不跳转时清空延迟槽</code></li><li>条件跳转：只增加CMP中的判断方法</li><li>链接：无条件链接直接将A3Sel设为31，与jal类似；对于有条件链接，将CMP中的flag信号进行流水，在controller里判断<code>A3Sel = (link &amp;&amp; flag) ? 31 : 0</code>，每一级根据这个信号判断写入操作，生成控制信号时可以视作<code>branch</code>和<code>jr</code>的“混合体”。</li><li>清空延迟槽，从CMP中引出信号，置1则表示<strong>发生比较</strong>且<strong>未达到跳转条件</strong>，信号名为<code>flush_flag</code>，然后<code>assign FD_flush = (flush_flag &amp;&amp; !stall)</code>。stall有效说明此时传入CMP的值的最新版本暂未计算出来，无法转发。</li></ul><p>存储指令的处理步骤</p><ul><li>前几个P遇到过的存储指令常常涉及到<code>条件存储</code>的问题，到M级才知道需要写什么</li><li>如果D级要读寄存器，而且条件存储的指令可能要写相同编号的寄存器，那么就阻塞一个周期</li></ul><p>修改通路的时候记得配合<code>def.v</code>相关宏定义的修改。</p></li><li><p>确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p><p>我采用的是分布式译码器。</p><p>该架构的<strong>优势</strong>在于不需要将控制信号流水传递，只需要流水传递指令，在每一级再译码即可。这样做降低了流水线需要传递的信号量，也避免了因为忘记流水某个信号而产生的错误。</p><p>但是，分布式译码需要在每一级都实例化一个控制器，每级都有端口闲置造成浪费，同时会增加后续流水级的逻辑复杂度。从实际应用的角度来看，使用多个控制器会增长关键路径，降低了流水线运行效率，原因与问题3相类似。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>462OJ搭建分享-输出结果评判</title>
    <link href="/2023/11/07/462OJ%E6%90%AD%E5%BB%BA%E5%88%86%E4%BA%AB-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%AF%84%E5%88%A4/"/>
    <url>/2023/11/07/462OJ%E6%90%AD%E5%BB%BA%E5%88%86%E4%BA%AB-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%AF%84%E5%88%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有幸和zlr同学、lpf同学合作开发了462OJ1<sup>st</sup>项目。</p><p>作为一款OJ，最重要的功能就是评判用户程序的输出与期望输出是否一致。这当中就涉及到了两个需求：</p><ul><li>生成期望输出</li><li>将期望输出与用户输出进行比较</li></ul><p>这里就简单分享一下项目中，这两个需求是怎么实现的。</p><p><del>与另外两个人的工作相比，这个工作是最简单的</del></p><h1 id="生成期望输出"><a href="#生成期望输出" class="headerlink" title="生成期望输出"></a>生成期望输出</h1><p>项目当中使用了<code>Toby Shi</code>学长的魔改版Mars，通过命令行执行得到期望输出。</p><p>可以利用python的os库实现这一功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">command = <span class="hljs-string">&quot;java -jar mars.jar temp.asm mc CompactLargeText coL1 ig&quot;</span> <br><span class="hljs-comment"># test.asm包含随机生成的测试点源码</span><br><span class="hljs-keyword">with</span> os.popen(command) <span class="hljs-keyword">as</span> f:<br>     answer = f.readlines()<br></code></pre></td></tr></table></figure><p>os.popen(command)：这种调用方式是通过管道的方式来实现，函数返回一个file对象，里面的内容是脚本输出的内容，可简单理解为echo输出的内容。</p><p>当然，有时候生成的随机数据点会存在一些问题，此时Mars的输出就会带有<code>Error</code>，此时我们就在answer里捕捉Error即可。</p><p>与此同时，也可以利用Mars生成相应的机器码，供<code>.v</code>文件执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">command = <span class="hljs-string">&quot;java -jar mars.jar a mc CompactLargeText dump .text HexText tempcode.txt temp.asm&quot;</span><br>f = os.popen(command)<br>f.close()<br></code></pre></td></tr></table></figure><h1 id="比较输出"><a href="#比较输出" class="headerlink" title="比较输出"></a>比较输出</h1><p>这里用到了python中的<code>difflib</code>库。</p><p><del>我才知道difflib是标准库</del></p><p>difflib可以对比文本之间的差异，并且支持输出可读性比较强的HTML文档，与Linux下的diff命令相似。</p><table><thead><tr><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>splitlines()</td><td>按照行(’\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符</td></tr><tr><td>d.compare(a,b)</td><td>比较两个行序列，并生成delta（一系列行）</td></tr><tr><td>difflib.HtmlDiff()</td><td>可以用于创建一个完整HTML文件，该文件显示具有行间和行内更改突出的文本的逐行比较</td></tr><tr><td>d.make_file(text1,text2)</td><td>比较两个字符串列表并返回一个字符串，该字符串是一个完整的HTML文件，其中包含一个表格，显示逐行差异，突出显示行间和行内更改</td></tr><tr><td>difflib.SequenceMatcher(None, s1, s2).ratio()</td><td>None参数是一个函数，用来去掉不需要比较的字符。<br>s1,s2参数为两个需要计算相似度的字符串。<br>函数返回值是0~1之间的一个浮点数，如果为1则认为完全相等</td></tr></tbody></table><p>最终的文本当中会出现一系列标识符，他们的含义如下。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>‘-’</td><td>包含在第一个系列行中，但不包含第二个</td></tr><tr><td>‘+’</td><td>包含在第二个系列行中，但不包含第一个</td></tr><tr><td>’ ’</td><td>两个系列行一致</td></tr><tr><td>‘?’</td><td>存在增量差异</td></tr><tr><td>‘^’</td><td>存在差异字符</td></tr></tbody></table><h2 id="实现文本对比"><a href="#实现文本对比" class="headerlink" title="实现文本对比"></a>实现文本对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> difflib<br>text1 = <span class="hljs-string">&#x27;&#x27;&#x27;  1. Beautiful is better than ugly.</span><br><span class="hljs-string">       2. Explicit is better than implicit.</span><br><span class="hljs-string">       3. Simple is better than complex.</span><br><span class="hljs-string">       4. Complex is better than complicated.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br>text2 = <span class="hljs-string">&#x27;&#x27;&#x27;  1. Beautiful is better than ugly.</span><br><span class="hljs-string">       3.   Simple is better than complex.</span><br><span class="hljs-string">       4. Complicated is better than complex.</span><br><span class="hljs-string">       5. Flat is better than nested.</span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br><br>d = difflib.Differ()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">list</span>(d.compare(text1,text2))))<br></code></pre></td></tr></table></figure><h2 id="使用html对比"><a href="#使用html对比" class="headerlink" title="使用html对比"></a>使用html对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> difflib<br>text1 = <span class="hljs-string">&#x27;&#x27;&#x27;  </span><br><span class="hljs-string">       1. Beautiful is better than gly.</span><br><span class="hljs-string">       2. Explicit is better than implicit.</span><br><span class="hljs-string">       3. Simple is better than complex.</span><br><span class="hljs-string">       4. Complex is better than complicated.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br>text2 = <span class="hljs-string">&#x27;&#x27;&#x27;  </span><br><span class="hljs-string">       1. Beautiful is better than ugly.</span><br><span class="hljs-string">       3. Simple is better than complex.</span><br><span class="hljs-string">       4. Complicated is beter than complex.</span><br><span class="hljs-string">       5. Flat is better than nested.</span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br><br>d = difflib.HtmlDiff()<br>htmlContent = d.make_file(text1,text2)<br><span class="hljs-comment"># print(htmlContent)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;diff.html&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(htmlContent)<br></code></pre></td></tr></table></figure><p>输出的结果为：<br><img src="https://pic.imgdb.cn/item/6549bac6c458853aefaef147.png" alt="输出结果"></p><p><code>difflib</code>库中的内容还有很多，欢迎大家前去探索！</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P4 - 单周期CPU设计文档</title>
    <link href="/2023/11/06/P4-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/06/P4-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P4-单周期CPU设计文档"><a href="#P4-单周期CPU设计文档" class="headerlink" title="P4 单周期CPU设计文档"></a>P4 单周期CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li>设计的处理器为32位单周期处理器</li><li>处理器支持的指令集为<code>add, sub, ori, lw, sw, beq, lui, nop，j，jal，jr，lb，sb，lh，sh</code>等</li><li><code>nop</code>为空指令，其机器码为<code>0x00000000</code>，不进行任何有效行为，如修改寄存器等</li><li><code>add, sub</code>按无符号加减法处理，不考虑溢出</li></ul><p>整体架构参考了《数字设计与计算机体系结构》图7-14，同时在P3的Logisim电路设计上进行了改动。</p><p><img src="https://pic.imgdb.cn/item/653fb286c458853aef8839f2.png" alt="《数字设计与计算机体系结构》图7-14"></p><p><img src="https://pic.imgdb.cn/item/653fb2e7c458853aef8a3714.png" alt="P3 Logisim电路设计概览"></p><h2 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Control signals of GRF are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> A3Sel_rt 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> A3Sel_rd 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> A3Sel_ra 2&#x27;b10</span><br><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WDSel_aluans 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WDSel_dmrd 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WDSel_PCa4 2&#x27;b10</span><br><br><br><span class="hljs-comment">// Control signals of IFU are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_PCa4 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_branch 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_j 2&#x27;b10</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_jr 2&#x27;b11</span><br><br><br><span class="hljs-comment">// Control signals of ALU are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_add 3&#x27;b000</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_sub 3&#x27;b001</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_or 3&#x27;b010</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_lui 3&#x27;b011</span><br><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALUBSel_grf 1&#x27;b0</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALUBSel_imm 1&#x27;b1</span><br><br><br><span class="hljs-comment">// Control signal of EXT are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> EXT_zero 1&#x27;b0</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> EXT_signed 1&#x27;b1</span><br><br><br><span class="hljs-comment">// Control signal of DM are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> DM_word 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> DM_halfword 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> DM_byte 2&#x27;b10</span><br></code></pre></td></tr></table></figure><h3 id="IFU"><a href="#IFU" class="headerlink" title="IFU"></a>IFU</h3><p>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</p><p>PC 用寄存器实现，应具有<strong>同步复位</strong>功能，复位值为起始地址。</p><p><strong>起始地址：0x00003000。</strong></p><p>地址范围：0x00003000 ~ 0x00006FFF。</p><p>IM用ROM实现，容量为4096 × 32bit。</p><p>IM实际地址宽度仅为12位，需要使用恰当的方法将PC中储存的地址同IM联系起来。</p><blockquote><p>PC的处理方法：</p><ul><li>PC的变化范围为0x00003000 ~ 0x00006FFF，考虑使用PC<sup>‘</sup> &#x3D; PC - 0x00003000，则PC<sup>‘</sup>的范围为0x00000000-0x00003FFF，不仅保证PC和PC<sup>‘</sup>在数值上一一对应，而且在设计处理时更加方便。</li><li>注意，输出是需要输出PC的值，而不是PC<sup>‘</sup>。</li><li>IM的实际地址宽度为12位，而PC的有效位数（可能发生变化的位数）为低14位。因为ROM是按字寻址，在从IM读取指令时只需要用PC[13:2]作为地址，就可以正确读取数据。</li></ul></blockquote><h4 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效，将PC置为0x0000_3000</td></tr><tr><td>PCSel[2:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>offset[15:0]</td><td>I</td><td>beq等branch指令的偏移量，即Instr[15:0]</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即Instr[25:0]</td></tr><tr><td>jr_reg[31:0]</td><td>I</td><td>jr指令中指定寄存器所储存的数</td></tr><tr><td>PC[31:0]</td><td>O</td><td>输出当前PC的值</td></tr><tr><td>PCa4[31:0]</td><td>O</td><td>输出当前PC加上0x0000_0004的值</td></tr><tr><td>Instr[31:0]</td><td>O</td><td>输出IM中PC地址上的指令</td></tr></tbody></table><h4 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>同步复位</td><td>reset置1，且时钟上升沿来临时，将PC置为0x0000_3000</td></tr><tr><td>2</td><td>更新PC的值</td><td>时钟上升沿来临时，根据<strong>PCSel</strong>的值更新PC的值</td></tr></tbody></table><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup><br>GPR[31] &lt;- PC + 4</td></tr></tbody></table><h3 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h3><p>使用<strong>具有写使能功能</strong>的寄存器实现，寄存器总数为<strong>32个</strong>，具有<strong>异步复位</strong>功能。</p><p>其中，<strong>0号寄存器</strong>($zero)的值始终保持为0。其他的寄存器<strong>初始值(复位后)均为0</strong>，无需专门设置。</p><h4 id="端口定义-1"><a href="#端口定义-1" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>WE</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32为数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><h4 id="功能定义-1"><a href="#功能定义-1" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>reset置1，且时钟上升沿来临时，所有寄存器存储的数值清零</td></tr><tr><td>2</td><td>读数据</td><td>读出A1，A2地址对应寄存器中所存储的数据到对应的RD1，RD2</td></tr><tr><td>3</td><td>写数据</td><td>当WE有效且时钟上升沿来临时，将WD写入A3所对应的寄存器中</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>A3Sel</th><th>操作</th></tr></thead><tbody><tr><td>A3Sel_rt</td><td>A3来自rt字段，对应I型指令</td></tr><tr><td>A3Sel_rd</td><td>A3来自rd字段，对应I型指令</td></tr><tr><td>A3Sel_ra</td><td>A3为$ra，对应jal指令</td></tr></tbody></table><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa4</td><td>WD为PC + 4</td></tr></tbody></table><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>提供 32 位加、减、或运算及大小比较功能。</p><p>加减法按无符号处理（不考虑溢出）。</p><h4 id="端口定义-2"><a href="#端口定义-2" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>zero</td><td>O</td><td>输出A - B的结果是否为0</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="功能定义-2"><a href="#功能定义-2" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>运算</td><td>根据ALUOp指定的操作对A和B进行运算</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>ALUOp</th><th>操作</th></tr></thead><tbody><tr><td>ALU_add</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_sub</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_or</td><td>result &#x3D; A | B</td></tr><tr><td>ALU_lui</td><td>result &#x3D; B | 10<sup>16</sup></td></tr></tbody></table><table><thead><tr><th>ALUBSel</th><th>操作</th></tr></thead><tbody><tr><td>ALUBSel_grf</td><td>ALU的第二个运算数来自GRF</td></tr><tr><td>ALUBSel_imm</td><td>ALU的第二个运算数来自立即数</td></tr></tbody></table><h3 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h3><p>使用RAM实现，容量为3072 × 32bit，应具有<strong>同步复位</strong>功能，复位值为0x00000000。</p><p><strong>起始地址：0x00000000</strong>。</p><p>地址范围：0x00000000 ~ 0x00002FFF。</p><h4 id="端口定义-3"><a href="#端口定义-3" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A[31:0]</td><td>I</td><td>需要进行读&#x2F;写操作的地址</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位写入RAM的数据</td></tr><tr><td>WE</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定DM进行的读&#x2F;写操作方式</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入DM时对应的指令PC值</td></tr><tr><td>RD[31:0]</td><td>O</td><td>32位从RAM读出的输出数据</td></tr></tbody></table><h4 id="功能定义-3"><a href="#功能定义-3" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>reset置1，且时钟上升沿来临时，重置RAM内存为0</td></tr><tr><td>2</td><td>写数据</td><td>当WE有效且时钟上升沿到来时，将WD中的数据写入A对应的RAM地址中</td></tr><tr><td>3</td><td>读数据</td><td>读取A对应的RAM地址中存储的数据到RD</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><h4 id="端口定义-4"><a href="#端口定义-4" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="功能定义-4"><a href="#功能定义-4" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>扩展</td><td>根据EXTOp指定的操作，对立即数进行扩展</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>使用与或门阵列构造控制信号。</p><p>和逻辑的功能是<strong>识别</strong>，将输入的机器码识别为相应的指令；或逻辑的功能是<strong>生成</strong>，根据输入的指令的不同，产生不同的控制信号。</p><h4 id="端口定义-5"><a href="#端口定义-5" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>opcode</td><td>I</td><td>32位指令Instr[31:26]</td></tr><tr><td>funct</td><td>I</td><td>32位指令Instr[5:0]</td></tr><tr><td>ALUflag_zero</td><td>I</td><td>ALU中两运算数相减是否为0，对应beq指令</td></tr><tr><td>A3Sel</td><td>O</td><td>指定数据将写入GRF的寄存器序号，即A3</td></tr><tr><td>ALUOp</td><td>O</td><td>指定ALU进行的运算操作</td></tr><tr><td>ALUBSel</td><td>O</td><td>指定ALU第二个操作数是否为立即数</td></tr><tr><td>WDSel</td><td>O</td><td>指定写入GRF的数据的来源</td></tr><tr><td>RegWrite</td><td>O</td><td>是否可向GRF中写入数据</td></tr><tr><td>MemWrite</td><td>O</td><td>是否可向DM中写入数据</td></tr><tr><td>PCSel</td><td>O</td><td>指定更新PC的方式</td></tr><tr><td>EXTOp</td><td>O</td><td>指定EXT进行立即数扩展的方式</td></tr><tr><td>DMOp</td><td>O</td><td>指定DM操作的方式</td></tr></tbody></table><h4 id="功能定义-5"><a href="#功能定义-5" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>生成控制信号</td><td>生成控制信号</td></tr></tbody></table><h2 id="重要机制实现方法"><a href="#重要机制实现方法" class="headerlink" title="重要机制实现方法"></a>重要机制实现方法</h2><h3 id="生成控制信号"><a href="#生成控制信号" class="headerlink" title="生成控制信号"></a>生成控制信号</h3><table><thead><tr><th align="center"></th><th align="center">opcode</th><th align="center">funct</th><th align="center">A3Sel</th><th align="center">ALUOp</th><th align="center">ALUBSel</th><th align="center">WDSel</th><th align="center">RegWrite</th><th align="center">MemWrite</th><th align="center">PCSel</th><th align="center">EXTOp</th><th align="center">DMOp</th></tr></thead><tbody><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td><td align="center">A3Sel_rd</td><td align="center">ALU_add</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td><td align="center">A3Sel_rd</td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_or</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_branch</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_lui</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">j</td><td align="center">000010</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jal</td><td align="center">000011</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_ra</td><td align="center"></td><td align="center"></td><td align="center">WDSel_PCa4</td><td align="center">1</td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jr</td><td align="center">001000</td><td align="center">001000</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_jr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lb</td><td align="center">100000</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">sb</td><td align="center">101000</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">lh</td><td align="center">100001</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr><tr><td align="center">sh</td><td align="center">101001</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr></tbody></table><blockquote><ol><li><p>PCSel一列缺省值为PCSel_PCa4</p><p>当beq和ALUflag_zero同时为高电平时，PCSel为PCSel_branch</p></li></ol></blockquote><p>controller的verilog代码如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;def.v&quot;</span><br><br><span class="hljs-keyword">module</span> controller(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] opcode,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] funct,<br>    <span class="hljs-keyword">input</span> ALUflag_zero,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] A3Sel,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] ALUOp,<br>    <span class="hljs-keyword">output</span> ALUBSel,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] WDSel,<br>    <span class="hljs-keyword">output</span> RegWrite,<br>    <span class="hljs-keyword">output</span> MemWrite,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] PCSel,<br>    <span class="hljs-keyword">output</span> EXTOp,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] DMOp<br>    );<br><br><br><span class="hljs-comment">// parameter of funct, for R-type instructions.</span><br><span class="hljs-keyword">parameter</span> ADD  = <span class="hljs-number">6&#x27;b100000</span>,<br>          SUB  = <span class="hljs-number">6&#x27;b100010</span>,<br>          JR   = <span class="hljs-number">6&#x27;b001000</span>,<br>          ZERO = <span class="hljs-number">6&#x27;b000000</span>;<br><br><span class="hljs-comment">// parameter of opcode, for I-type and J-type instructions.</span><br><span class="hljs-comment">// I-Type</span><br><span class="hljs-keyword">parameter</span> ORI  = <span class="hljs-number">6&#x27;b001101</span>,<br>          LW  = <span class="hljs-number">6&#x27;b100011</span>,<br>          SW  = <span class="hljs-number">6&#x27;b101011</span>,<br>          BEQ = <span class="hljs-number">6&#x27;b000100</span>,<br>          LUI = <span class="hljs-number">6&#x27;b001111</span>,<br>          JAL = <span class="hljs-number">6&#x27;b000011</span>,<br>          LB  = <span class="hljs-number">6&#x27;b100000</span>,<br>          SB  = <span class="hljs-number">6&#x27;b101000</span>,<br>          LH  = <span class="hljs-number">6&#x27;b100001</span>,<br>          SH  = <span class="hljs-number">6&#x27;b101001</span>;<br><br><span class="hljs-comment">// J-Type</span><br><span class="hljs-keyword">parameter</span> J = <span class="hljs-number">6&#x27;b000010</span>;<br><br><br><span class="hljs-comment">// identify instruction</span><br><span class="hljs-keyword">wire</span> zero, add, sub, ori, lw, sw, beq, lui, jal, jr, j;<br><span class="hljs-keyword">wire</span> lb, sb, lh, sh;<br><br><span class="hljs-comment">// R</span><br><span class="hljs-keyword">assign</span> zero = (opcode == ZERO);<br><span class="hljs-keyword">assign</span> add = (zero &amp;&amp; (funct == ADD));<br><span class="hljs-keyword">assign</span> sub = (zero &amp;&amp; (funct == SUB));<br><span class="hljs-keyword">assign</span> jr = (zero &amp;&amp; (funct == JR));<br><br><span class="hljs-comment">// I and J</span><br><span class="hljs-keyword">assign</span> ori = (opcode == ORI);<br><span class="hljs-keyword">assign</span> lw = (opcode == LW);<br><span class="hljs-keyword">assign</span> sw = (opcode == SW);<br><span class="hljs-keyword">assign</span> beq = (opcode == BEQ);<br><span class="hljs-keyword">assign</span> lui = (opcode == LUI);<br><span class="hljs-keyword">assign</span> jal = (opcode == JAL);<br><span class="hljs-keyword">assign</span> j = (opcode == J);<br><span class="hljs-keyword">assign</span> lb = (opcode == LB);<br><span class="hljs-keyword">assign</span> sb = (opcode == SB);<br><span class="hljs-keyword">assign</span> lh = (opcode == LH);<br><span class="hljs-keyword">assign</span> sh = (opcode == SH);<br><br><br><span class="hljs-keyword">assign</span> A3Sel = (ori || lw || lui || lb || lh) ? `A3Sel_rt :<br>               (add || sub) ? `A3Sel_rd : <br>               jal ? `A3Sel_ra : <span class="hljs-number">2&#x27;b00</span>;<br><br><span class="hljs-keyword">assign</span> ALUOp = (lw || sw || add || lh || sh || lb || sb) ? `ALU_add :<br>               (sub || beq) ? `ALU_sub :<br>               ori ? `ALU_or :<br>               lui ? `ALU_lui : <span class="hljs-number">3&#x27;b000</span>;<br><br><span class="hljs-keyword">assign</span> ALUBSel = (lw || sw || lui || ori || lb || sb || lh || sh);<br><br><span class="hljs-keyword">assign</span> WDSel = (add || sub || ori || lui) ? `WDSel_aluans :<br>               (lw || lb || lh) ? `WDSel_dmrd :<br>               (jal) ? `WDSel_PCa4 : <span class="hljs-number">2&#x27;b00</span>;<br><br><span class="hljs-keyword">assign</span> RegWrite = (add || sub || ori || lui || jal || lw || lh || lb);<br><br><span class="hljs-keyword">assign</span> MemWrite = (sw || sb || sh);<br><br><span class="hljs-keyword">assign</span> PCSel = (beq &amp;&amp; ALUflag_zero) ? `PCSel_branch :<br>               (jal || j) ? `PCSel_j :<br>               (jr) ? `PCSel_jr : `PCSel_PCa4;<br><br><span class="hljs-keyword">assign</span> EXTOp = (lw || sw || lb || sb || lh || sh);<br><br><span class="hljs-keyword">assign</span> DMOp = (lw || sw) ? `DM_word :<br>              (lb || sb) ? `DM_byte :<br>              (lh || sh) ? `DM_halfword : <span class="hljs-number">2&#x27;b00</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="DM中对读写半字-字节的处理"><a href="#DM中对读写半字-字节的处理" class="headerlink" title="DM中对读写半字&#x2F;字节的处理"></a>DM中对读写半字&#x2F;字节的处理</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;def.v&quot;</span><br><br><span class="hljs-keyword">module</span> dm(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] A,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WD,<br>    <span class="hljs-keyword">input</span> WE,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] DMOp,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WPC,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RD<br>    );<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RAM [<span class="hljs-number">0</span>:<span class="hljs-number">3071</span>];<br><span class="hljs-keyword">integer</span> i;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2072</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        RAM[i] = <span class="hljs-number">32&#x27;h0000_0000</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">11</span>:<span class="hljs-number">0</span>] address;<br><span class="hljs-keyword">assign</span> address = A[<span class="hljs-number">13</span>:<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// write data with DMOp</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] tempRD;<br><span class="hljs-keyword">assign</span> tempRD = RAM[address];<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] halfword0;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] halfword1;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte0;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte1;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte2;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte3;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] datain;<br><br><span class="hljs-keyword">assign</span> halfword0 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>], WD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> halfword1 = &#123;WD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]&#125;;<br><br><span class="hljs-keyword">assign</span> byte0 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>], tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>], WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> byte1 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>], tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>], WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> byte2 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>], WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>], tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> byte3 = &#123;WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>], tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><br><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (DMOp == `DM_word) <span class="hljs-keyword">begin</span><br>        datain = WD;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_halfword) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-keyword">begin</span><br>            datain = halfword0;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><br>            datain = halfword1;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            datain = WD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_byte) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b00</span>) <span class="hljs-keyword">begin</span><br>            datain = byte0;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b01</span>) <span class="hljs-keyword">begin</span><br>            datain = byte1;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b10</span>) <span class="hljs-keyword">begin</span><br>            datain = byte2;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b11</span>) <span class="hljs-keyword">begin</span><br>            datain = byte3;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            datain = WD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        datain = WD;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2072</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            RAM[i] &lt;= <span class="hljs-number">32&#x27;h0000_0000</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (WE) <span class="hljs-keyword">begin</span><br>            RAM[address] &lt;= datain;<br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%h: *%h &lt;= %h&quot;</span>, WPC, A, datain);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            RAM[address] &lt;= RAM[address];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment">// read data with DMOp</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dataout;<br><span class="hljs-keyword">assign</span> RD = dataout;<br><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (DMOp == `DM_word) <span class="hljs-keyword">begin</span><br>        dataout = tempRD;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_halfword) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">16</span>&#123;tempRD[<span class="hljs-number">15</span>]&#125;&#125;, tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">16</span>&#123;tempRD[<span class="hljs-number">31</span>]&#125;&#125;, tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            dataout = tempRD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_byte) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b00</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">7</span>]&#125;&#125;, tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b01</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">15</span>]&#125;&#125;, tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b10</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">23</span>]&#125;&#125;, tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b11</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">31</span>]&#125;&#125;, tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            dataout = tempRD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        dataout = tempRD;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="测试代码1"><a href="#测试代码1" class="headerlink" title="测试代码1"></a>测试代码1</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">156</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">135</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a3</span>,$<span class="hljs-built_in">a3</span>,<span class="hljs-number">1035</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a1</span>,<span class="hljs-number">101</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2211</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,end<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s6</span>,<span class="hljs-number">170</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">s0</span>,<span class="hljs-number">4</span>($<span class="hljs-built_in">t1</span>)<br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,loop<br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">v0</span>,<span class="hljs-number">11111</span><br></code></pre></td></tr></table></figure><h3 id="测试代码2"><a href="#测试代码2" class="headerlink" title="测试代码2"></a>测试代码2</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">123</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, l1e<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">j </span>  l1<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1e:</span><br><span class="hljs-keyword">jal </span>sum<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>  l2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sum:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">a2</span><br><span class="hljs-keyword">jr </span> $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l2:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="测试代码3"><a href="#测试代码3" class="headerlink" title="测试代码3"></a>测试代码3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0xf123</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">0x3f21</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x4567</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x7465</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">0x89ab</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s2</span>, <span class="hljs-number">0xb89a</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcdef</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcfed</span><br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t8</span>, -<span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">20</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">8</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s1</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">25</span><br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, -<span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t2</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t5</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>根据你的理解，在下面给出的DM的输入示例中，地址信号addr位数为什么是[11:2]而不是[9:0]？这个addr信号又是从哪里来的？</li></ol><p><img src="https://pic.imgdb.cn/item/6549bf83c458853aefbbf664.png" alt="DM示例"></p><p>DM里的RAM按字节寻址，且该DM设计大小为4KB，所以应该使用addr[11:2]</p><p>addr来自ALU的计算输出，代表要读取的数据在RAM中的地址</p><ol start="2"><li><p>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</p><p>控制器设计的译码方式有三种。</p><ul><li><p>三元运算符</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> ALUOp = (lw || sw || add || lh || sh || lb || sb) ? `ALU_add :<br>               (sub || beq) ? `ALU_sub :<br>               ori ? `ALU_or :<br>               lui ? `ALU_lui : <span class="hljs-number">3&#x27;b000</span>;<br></code></pre></td></tr></table></figure></li><li><p>case语句</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">case</span>(ALUOp)<br>`ALU_add: C = A + B;<br>`ALU_sub: C = A - B;<br>`ALU_or: C = A | B;<br>`ALU_lui: C = B &lt;&lt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">default</span>: C = <span class="hljs-number">32&#x27;h0000_0000</span>;<br><span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure></li><li><p>if-else语句</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (ALUOP == `ALU_add)<br>C = A + B;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ALUOP == `ALU_sub)<br>C = A - B;<br><span class="hljs-keyword">else</span><br>C = <span class="hljs-number">32&#x27;h0000_0000</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>assign语句配合三目运算符使用，可以不用再额外定义reg变量。</p><p>case语句，if-else语句配合宏定义使用可以增强代码的可读性。if-else语句写起来略显繁琐。</p><ol start="3"><li><p>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</p><p>同步复位中，clk的优先级高于reset；异步复位中两者优先级相同。</p></li><li><p>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</p><p>addi与addiu的区别在于当出现溢出时，addiu忽略溢出，并将溢出的最高位舍弃；addi会报错SignalException(IntegerOverflow)。忽略溢出时，二者等价。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3 - 单周期CPU设计文档</title>
    <link href="/2023/10/30/P3-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/10/30/P3-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p><strong>Tips</strong></p><p>课下要求可能会发生变化，文章仅供参考，未必完全正确。</p><p>请勿抄袭！</p>          </div><h1 id="P3-单周期CPU设计文档"><a href="#P3-单周期CPU设计文档" class="headerlink" title="P3 单周期CPU设计文档"></a>P3 单周期CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li>设计的处理器为32位单周期处理器</li><li>处理器支持的指令集为<code>add, sub, ori, lw, sw, beq, lui, nop，j，jal，jr，lb，sb，lh，sh</code>等</li><li><code>nop</code>为空指令，其机器码为<code>0x00000000</code>，不进行任何有效行为，如修改寄存器等</li><li><code>add, sub</code>按无符号加减法处理，不考虑溢出</li></ul><h2 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h2><p>参考了《数字设计与计算机体系结构》图7-14，在实际设计上略有改动。</p><p><img src="https://pic.imgdb.cn/item/653fb286c458853aef8839f2.png" alt="《数字设计与计算机体系结构》图7-14"></p><p>最终实现效果概览如下。</p><p><img src="https://pic.imgdb.cn/item/653fb2e7c458853aef8a3714.png" alt="单周期CPU概览图"></p><h2 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h2><h3 id="IFU-取指令单元"><a href="#IFU-取指令单元" class="headerlink" title="IFU(取指令单元)"></a>IFU(取指令单元)</h3><p>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</p><p>PC 用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</p><p><strong>起始地址：0x00003000。</strong></p><p>地址范围：0x00003000 ~ 0x00006FFF。</p><p>IM用ROM实现，容量为4096 × 32bit。</p><p>IM实际地址宽度仅为12位，需要使用恰当的方法将PC中储存的地址同IM联系起来。</p><div class="note note-success">            <p>PC的处理方法：</p><ul><li>PC的变化范围为0x00003000 ~ 0x00006FFF，考虑使用PC<sup>‘</sup> &#x3D; PC - 0x00003000，则PC<sup>‘</sup>的范围为0x00000000-0x00003FFF，不仅保证PC和PC<sup>‘</sup>在数值上一一对应，而且在设计处理时更加方便。</li><li>注意，输出是需要输出PC的值，而不是PC<sup>‘</sup>。</li><li>IM的实际地址宽度为12位，而PC的有效位数（可能发生变化的位数）为低14位。因为ROM是按字寻址，在从IM读取指令时只需要用PC[13:2]作为地址，就可以正确读取数据。</li></ul>          </div><h4 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-1-1 IFU模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>clk</td>        <td>I</td>        <td>时钟信号</td>    </tr>    <tr>        <td>reset</td>        <td>I</td>        <td><strong>异步</strong>复位信号，将PC置0</td>    </tr>    <tr>        <td>offset[15:0]</td>        <td>I</td>        <td>            beq等branch指令的偏移量，即Instr[15:0]        </td>    </tr>    <tr>        <td>imm[25:0]</td>        <td>I</td>        <td>j指令和jal指令中的立即数，即Instr[25:0]</td>    </tr>    <tr>        <td>PCsel[2:0]</td>        <td>I</td>        <td>指定更新PC的方式</td>    </tr>    <tr>        <td>Instr[31:0]</td>        <td>O</td>        <td>输出IM中PC地址上的指令</td>    </tr>    <tr>        <td>PC</td>        <td>O</td>        <td>输出当前PC的值</td>    </tr>    <tr>        <td>PC+4</td>        <td>O</td>        <td>输出PC+4的值</td>    </tr></table><h4 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption> 表2-1-2 IFU模块功能定义 </caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>异步复位</td>        <td>reset置1时，将PC置为0x00003000</td>    </tr>    <tr>        <td>2</td>        <td>更新下一个PC的值</td>        <td>            时钟上升沿来临时，更新PC的值<br>            PCsel为2'b00时，PC <- PC + 4<br>            PCsel为2'b01时，PC <- PC + 4 + sign_extend(offset||0<sup>2</sup>)<br>            PCsel为2'b10时，PC <- PC[31:28]||imm||0<sup>2</sup><br>            PCsel为2'b11时，PC <- PC[31:28]||imm||0<sup>2</sup>; GPR[31] <- PC + 4        </td>    </tr> </table><h3 id="GRF-寄存器文件"><a href="#GRF-寄存器文件" class="headerlink" title="GRF(寄存器文件)"></a>GRF(寄存器文件)</h3><p>使用<strong>具有写使能功能</strong>的寄存器实现，寄存器总数为<strong>32个</strong>，具有<strong>异步复位</strong>功能。</p><p>其中，<strong>0号寄存器</strong>($zero)的值始终保持为0。其他的寄存器<strong>初始值(复位后)均为0</strong>，无需专门设置。</p><h4 id="端口定义-1"><a href="#端口定义-1" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-2-1 GRF模块端口定义</caption>    <tr>        <td> 信号名 </td>        <td> 方向 </td>        <td> 描述 </td>    </tr>    <tr>        <td> clk </td>        <td> I </td>        <td> 时钟信号 </td>    </tr>    <tr>        <td> reset </td>        <td> I </td>        <td> <strong>异步</strong>复位信号，将32个寄存器中的值全部清零<br>1:复位<br>0:无效</td>    </tr>    <tr>        <td> WE </td>        <td> I </td>        <td> 写使能信号<br>1:可向GRF中写入数据<br>0:不能向GRF中写入数据</td>    </tr>    <tr>        <td> A1[4:0] </td>        <td> I </td>        <td> 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td>    </tr>    <tr>        <td> A2[4:0] </td>        <td> I </td>        <td> 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td>    </tr>    <tr>        <td> A3[4:0] </td>        <td> I </td>        <td> 5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td>    </tr>    <tr>        <td> WD[31:0] </td>        <td> I </td>        <td> 32位数据输入信号</td>    </tr>    <tr>        <td> RD1[31:0] </td>        <td> O </td>        <td> 输出A1指定的寄存器中的32位数据</td>    </tr>    <tr>        <td> RD2[31:0] </td>        <td> O </td>        <td> 输出A2指定的寄存器中的32位数据</td>    </tr></table><h4 id="功能定义-1"><a href="#功能定义-1" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-2-2 GRF模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>异步复位</td>        <td>reset信号置1时，所有寄存器存储的数值清零，其行为与logisim自带部件register的reset接口完全相同</td>    </tr>    <tr>        <td>2</td>        <td>读数据</td>        <td>读出A1，A2地址对应寄存器中所存储的数据到对应的RD1，RD2</td>    </tr>    <tr>        <td>3</td>        <td>写数据</td>        <td>当<strong>WE有效且时钟上升沿来临</strong>时，将WD写入A3所对应的寄存器中</td>    </tr></table><h3 id="ALU-算术逻辑单元"><a href="#ALU-算术逻辑单元" class="headerlink" title="ALU(算术逻辑单元)"></a>ALU(算术逻辑单元)</h3><p>提供 32 位加、减、或运算及大小比较功能。</p><p>加减法按无符号处理（不考虑溢出）。</p><h4 id="端口定义-2"><a href="#端口定义-2" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-3-1 ALU模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>A[31:0]</td>        <td>I</td>        <td>第一个32位计算数</td>    </tr>    <tr>        <td>B[31:0]</td>        <td>I</td>        <td>第二个32位计算数</td>    </tr>    <tr>        <td>ALUop[2:0]</td>        <td>I</td>        <td>指定ALU进行的计算</td>    </tr>    <tr>        <td>res[31:0]</td>        <td>O</td>        <td>运算结果</td>    </tr>    <tr>        <td>comp[2:0]</td>        <td>O</td>        <td>            输出A与B的大小关系        </td>    </tr></table><h4 id="功能定义-2"><a href="#功能定义-2" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-3-2 ALU模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>比较大小</td>        <td>            A > B时，comp=2'b00<br>            A = B时，comp=2'b01<br>            A < B时，comp=2'b10<br>        </td>    </tr>    <tr>        <td>2</td>        <td>加运算</td>        <td>ALUop = 3'b000时，res = A + B，不考虑溢出</td>    </tr>    <tr>        <td>3</td>        <td>减运算</td>        <td>            ALUop = 3'b001时，res = A - B，不考虑溢出        </td>    </tr>    <tr>        <td>4</td>        <td>或运算</td>        <td>ALUop = 3'b010时，res = A | B</td>    </tr>    <tr>        <td>5</td>        <td>B置高16位</td>        <td>ALUop = 3'b011时，res = B || 10<sup>16</sup></td>    </tr></table><blockquote><p>多余的ALUop为扩展指令预留。</p></blockquote><h3 id="DM-数据存储器"><a href="#DM-数据存储器" class="headerlink" title="DM(数据存储器)"></a>DM(数据存储器)</h3><p>使用RAM实现，容量为3072 × 32bit，应具有<strong>异步复位</strong>功能，复位值为0x00000000。</p><p><strong>起始地址：0x00000000</strong>。</p><p>地址范围：0x00000000 ~ 0x00002FFF。</p><p>RAM 应使用<strong>双端口模式</strong>，即设置 RAM 的 <strong>Data Interface</strong> 属性为 <strong>Separate load and store ports</strong>。</p><h4 id="端口定义-3"><a href="#端口定义-3" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-4-1 DM模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>clk</td>        <td>I</td>        <td>时钟信号</td>    </tr>    <tr>        <td>reset</td>        <td>I</td>        <td><strong>异步</strong>复位信号，将DM内的RAM重置为0</td>    </tr>    <tr>        <td>WE</td>        <td>I</td>        <td>写使能信号，WE为1时，允许写入数据；WE为0时，禁止写入</td>    </tr>    <tr>        <td>DMop[1:0]</td>        <td>I</td>        <td>指定DM进行的读/写操作类型</td>    </tr>    <tr>        <td>A[31:0]</td>        <td>I</td>        <td>需要进行读/写操作的地址</td>    </tr>    <tr>        <td>WD[31:0]</td>        <td>I</td>        <td>写入RAM的32位输入数据</td>    </tr>    <tr>        <td>RD[31:0]</td>        <td>O</td>        <td>从RAM读出的32位输出数据</td>    </tr></table><h4 id="功能定义-3"><a href="#功能定义-3" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-4-2 DM模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>异步复位</td>        <td>reset置1时，异步重置RAM内存为0</td>    </tr>    <tr>        <td>2</td>        <td>写数据</td>        <td>            当<strong>WE有效且时钟上升沿到来</strong>时，将WD中的数据写入A对应的RAM地址中            <br>DMop为2'b00时，执行lw指令            <br>DMop为2'b01时，执行lh指令            <br>DMop为2'b10时，执行lb指令        </td>    </tr>    <tr>        <td>3</td>        <td>读数据</td>        <td>            读取A对应的RAM地址中存储的数据到RD            <br>DMop为2'b00时，执行sw指令            <br>DMop为2'b01时，执行sh指令            <br>DMop为2'b10时，执行sb指令        </td>    </tr></table><blockquote><p>与处理IFU中地址的方法相同，使用A[13:2]即可从DM的RAM中正确读取数据。</p></blockquote><h3 id="EXT-扩展单元"><a href="#EXT-扩展单元" class="headerlink" title="EXT(扩展单元)"></a>EXT(扩展单元)</h3><p>使用Logisim内置的Bit Extender。</p><h4 id="端口定义-4"><a href="#端口定义-4" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption> 表2-5-1 EXT模块端口定义 </caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>num[15:0]</td>W        <td>I</td>        <td>需要扩展的16位立即数</td>    </tr>    <tr>        <td>sel</td>        <td>I</td>        <td>指定进行扩展的方式</td>    </tr>    <tr>        <td>result[31:0]</td>        <td>O</td>        <td>扩展完成的32位数</td>    </tr></table><h4 id="功能定义-4"><a href="#功能定义-4" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-5-2 EXT模块功能定义</caption>    <tr>        <td>sel</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1'b0</td>        <td>零扩展</td>        <td>result = zero_extend(num)</td>    </tr><tr>        <td>1'b1</td>        <td>符号扩展</td>        <td>result = sign_extend(num)</td>    </tr></table><h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller(控制器)"></a>Controller(控制器)</h3><p>使用与或门阵列构造控制信号。</p><p>和逻辑的功能是<strong>识别</strong>，将输入的机器码识别为相应的指令；或逻辑的功能是<strong>生成</strong>，根据输入的指令的不同，产生不同的控制信号。</p><h4 id="端口定义-5"><a href="#端口定义-5" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-6-1 Controller模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>op[5:0]</td>        <td>I</td>        <td>32位指令Instr[31:26]</td>    </tr>    <tr>        <td>comp[1:0]</td>        <td>I</td>        <td>ALU中两运算数的大小，决定是否执行branch指令</td>    </tr>    <tr>        <td>funct[5:0]</td>        <td>I</td>        <td>32位指令Instr[5:0]</td>    </tr>    <tr>        <td>RegDst[1:0]</td>        <td>O</td>        <td>            指定数据写入GRF的寄存器序号<br>            RegDst为2'b00时，序号为Instr[20:16]，对应I型指令的rt<br>            RegDst为2'b01时，序号为Instr[15:11]，对应R型指令的rd<br>            RegDst为2'b10时，序号为31，即<strong>$ra</strong>的序号，用于jal指令        </td>    </tr>    <tr>        <td>ALUSrc</td>        <td>O</td>        <td>            指定ALU第二个运算数是否是立即数<br>            ALUSrc为0时，运算数来自GRF<br>            ALUSrc为1时，运算数为立即数        </td>    </tr>    <tr>        <td>MemToReg[1:0]</td>        <td>O</td>        <td>            指定写入GRF的数据的来源<br>            MemToReg为2'b00时，数据为ALU的输出res<br>            MemToReg为2'b01时，数据为DM的输出RD<br>            MemToReg为2'b10时，数据为PC + 4，用于jal指令将PC + 4写入$ra的操作        </td>    </tr>    <tr>        <td>RegWrite</td>        <td>O</td>        <td>是否可向GRF中写入数据</td>    </tr>    <tr>        <td>MemWrite</td>        <td>O</td>        <td>是否可向DM中写入数据</td>    </tr>    <tr>        <td>PCsel[1:0]</td>        <td>O</td>        <td>指定更新PC的方式</td>    </tr>    <tr>        <td>Extop</td>        <td>O</td>        <td>            指定EXT进行立即数扩展的方式<br>            ExtOp为0时，EXT进行零扩展<br>            ExtOp为1时，EXT进行符号扩展<br>        </td>    </tr>    <tr>        <td>DMop[1:0]</td>        <td>O</td>        <td>指定操作DM的方式</td>    </tr>    <tr>        <td>ALUop[2:0]</td>        <td>O</td>        <td>指定ALU进行的计算</td>    </tr></table><h4 id="功能定义-5"><a href="#功能定义-5" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-6-2 Controller模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>生成控制信号</td>        <td>生成控制信号</td>    </tr></table><h2 id="重要机制实现方法"><a href="#重要机制实现方法" class="headerlink" title="重要机制实现方法"></a>重要机制实现方法</h2><h3 id="生成控制信号"><a href="#生成控制信号" class="headerlink" title="生成控制信号"></a>生成控制信号</h3><p><img src="https://pic.imgdb.cn/item/653fb25bc458853aef877fb7.png" alt="控制信号真值表"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><img src="https://pic.imgdb.cn/item/653fb332c458853aef8bb437.png" alt="程序计数器细节"></p><h3 id="DM中对读写半字-字节的处理"><a href="#DM中对读写半字-字节的处理" class="headerlink" title="DM中对读写半字&#x2F;字节的处理"></a>DM中对读写半字&#x2F;字节的处理</h3><p><img src="https://pic.imgdb.cn/item/653fb331c458853aef8bb0ee.png" alt="DM总览"></p><p><img src="https://pic.imgdb.cn/item/653fb331c458853aef8bb190.png" alt="写字/半字/字节"></p><p><img src="https://pic.imgdb.cn/item/653fb332c458853aef8bb2cd.png" alt="读字/半字/字节"></p><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="测试代码1"><a href="#测试代码1" class="headerlink" title="测试代码1"></a>测试代码1</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">156</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">135</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a3</span>,$<span class="hljs-built_in">a3</span>,<span class="hljs-number">1035</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a1</span>,<span class="hljs-number">101</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2211</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,end<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s6</span>,<span class="hljs-number">170</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">s0</span>,<span class="hljs-number">4</span>($<span class="hljs-built_in">t1</span>)<br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,loop<br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">v0</span>,<span class="hljs-number">11111</span><br></code></pre></td></tr></table></figure><p>导出为</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns">v2.<span class="hljs-number">0</span> raw<br><span class="hljs-number">3408009</span>c<br><span class="hljs-number">340a0087</span><br><span class="hljs-number">34</span>e7040b<br><span class="hljs-number">3c050065</span><br><span class="hljs-number">340508a3</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">116a0008</span><br><span class="hljs-number">358c0008</span><br><span class="hljs-number">3</span>c1600aa<br><span class="hljs-number">016c5820</span><br><span class="hljs-number">01405820</span><br><span class="hljs-number">8d300004</span><br><span class="hljs-number">01495020</span><br><span class="hljs-number">01405822</span><br><span class="hljs-number">116</span>afff7<br><span class="hljs-number">3c022b67</span><br></code></pre></td></tr></table></figure><h3 id="测试代码2"><a href="#测试代码2" class="headerlink" title="测试代码2"></a>测试代码2</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">123</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, l1e<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">j </span>  l1<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1e:</span><br><span class="hljs-keyword">jal </span>sum<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>  l2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sum:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">a2</span><br><span class="hljs-keyword">jr </span> $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l2:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="测试代码3"><a href="#测试代码3" class="headerlink" title="测试代码3"></a>测试代码3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0xf123</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">0x3f21</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x4567</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x7465</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">0x89ab</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s2</span>, <span class="hljs-number">0xb89a</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcdef</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcfed</span><br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t8</span>, -<span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">20</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">8</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s1</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">25</span><br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, -<span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t2</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t5</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</li></ol><p>状态存储：GRF、DM</p><p>状态转移：IFU、ALU、EXT、Controller</p><ol start="2"><li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？请给出分析，若有改进意见也请一并给出。</li></ol><p>我认为是合理的。</p><p>IM只需要被读取，而ROM是只读的，下次打开文件时内存依然存在，且运行过程中不会被篡改；</p><p>DM需要支持读、写功能，一个时钟周期内只会进行读、写的其中一种操作。RAM即可支持读写操作，又在占用空间上优于寄存器文件。</p><p>GRF需要支持读、写功能，且与ALU直接相连，对读、写速度要求较高，故使用寄存器文件。</p><ol start="3"><li>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</li></ol><p>并未设计新的模块。</p><p>4.事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</p><p>Controller采用与或门阵列实现，读入nop指令时所有的控制信号均保持在低电平，只进行了PC &lt;- PC + 4，而不会产生其他任何操作。</p><ol start="5"><li>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</li></ol><p>我认为该样例覆盖了该CPU中支持的所有指令，且先由最基本的可独立判断正误的指令进行验证，之后再对更高层的指令的结果正误进行验证，能对CPU的设计起到较为准确的反馈。</p><p>可以考虑加入一些32位数、16位无符号数的边界情况，多增加一些目标寄存器为<code>$0</code>的指令，达到更好的测试效果。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归调用汇编代码翻译的一些心得</title>
    <link href="/2023/10/21/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
    <url>/2023/10/21/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>教程 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-5/mips5-11/#_6">函数调用 - 计算机组成教程 (buaa.edu.cn)</a> 中曾介绍过如何将带有递归函数调用的c语言代码翻译成汇编指令。P2课下也涉及了部分需要应用递归的题目，在此总结一下我完成此类汇编翻译的一些心得。</p><p>我们在此就以 <a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=36&PieId=1121">P2_L0_full_1 - 系统能力课程实验平台 (buaa.edu.cn)</a> 当作例题，简要介绍一下设计思路。</p><h1 id="例题1：全排列生成"><a href="#例题1：全排列生成" class="headerlink" title="例题1：全排列生成"></a>例题1：全排列生成</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>题目编号 1121-36</p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>实现满足下面功能的汇编程序：</p><ol><li><p>使用mips实现全排列生成算法。</p></li><li><p>以0x00000000为数据段起始地址。</p></li><li><p>输入一个小于等于6的正整数，求出n的全排列，并按照字典序输出。</p></li><li><p>每组数据最多执行500,000条指令。</p></li><li><p>请使用syscall结束指令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>只输入一行，输入一个整数n **(0 &lt; n &lt;&#x3D; 6)**。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照字典序输出n!行数组，每行输出n个数字，数字之间以空格隔开，每行最后一个数字后可以有空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="解答步骤"><a href="#解答步骤" class="headerlink" title="解答步骤"></a>解答步骤</h2><p>在此分享一下我完成汇编代码的一些思路步骤。</p><h3 id="第一步：完成符合要求的C语言代码"><a href="#第一步：完成符合要求的C语言代码" class="headerlink" title="第一步：完成符合要求的C语言代码"></a>第一步：完成符合要求的C语言代码</h3><p>C语言的代码与汇编指令具有很高的相似性，如果有一份正确的C语言代码，汇编编程题就相当于一个“翻译题”。</p><p>全排列问题的C语言代码如下：（如果对此有疑问的话，可以去网上搜索一下全排列的相关讲解，在此不展开说明）</p><p><img src="https://pic.imgdb.cn/item/6533b63bc458853aef395a40.png" alt="全排列问题的C语言解答"></p><h3 id="第二步：一些必要的macro"><a href="#第二步：一些必要的macro" class="headerlink" title="第二步：一些必要的macro"></a>第二步：一些必要的macro</h3><p>使用宏可有效提高代码的复用性，提高代码的可读性。</p><p>我比较习惯用的macro有：</p><ul><li><p>取array[i]的值到%d</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> getNum(%d,%i)<br><span class="hljs-keyword">sll </span>%d,%i,<span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>%d,array(%d)<br>.end_macro<br></code></pre></td></tr></table></figure></li><li><p>取array[i] [j]的值到%d，矩阵的<strong>列数</strong>为%n</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> getNum(%d,%i,%<span class="hljs-keyword">j,%n)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mul </span>%d,%i,%n<br><span class="hljs-keyword">add </span>%d,%d,%<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span>%d,%d,<span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>%d,array(%d)<br>.end_macro<br></code></pre></td></tr></table></figure></li><li><p>将字压入栈</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br></code></pre></td></tr></table></figure><p>相对应的弹出栈</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br></code></pre></td></tr></table></figure></li></ul><h3 id="第三步：合理规划寄存器"><a href="#第三步：合理规划寄存器" class="headerlink" title="第三步：合理规划寄存器"></a>第三步：合理规划寄存器</h3><p><code>s0</code>-<code>s7</code>是留给“需要保存的变量”，如常量，全局变量等；<code>t0</code>-<code>t9</code>是留给“临时变量”，如循环时常用的i、j、k变量等。对于一般的题目，我使用<code>s0</code>来保存n的值，<code>t0</code>留给循环变量i，<code>t9</code>留给计算出来的临时地址。</p><p>当然，如何分配主要还是看自己写的顺不顺手，只要自己有一套可操作的规则即可。</p><h3 id="第四步：完成代码"><a href="#第四步：完成代码" class="headerlink" title="第四步：完成代码"></a>第四步：完成代码</h3><p>我们在此先给出完整的汇编代码。如果对递归调用之外的地方存在疑问，可以再去阅读额外的讲解。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">array:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">symbol:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">blank:</span> .asciiz <span class="hljs-string">&quot; &quot;</span><br><span class="hljs-symbol">next_line:</span> .asciiz <span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br><br><span class="hljs-meta">.text</span><br><span class="hljs-symbol">main:</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br>li   $<span class="hljs-built_in">s1</span>, <span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-symbol">init_loop:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, symbol($<span class="hljs-built_in">t8</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s0</span>, init_loop<br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># index</span><br><span class="hljs-keyword">jal </span> FullArray<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">FullArray:</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, search<br><span class="hljs-symbol">print:</span><br>li   $<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">print_loop:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">a0</span>, array($<span class="hljs-built_in">t8</span>)<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">4</span><br>la   $<span class="hljs-built_in">a0</span>, <span class="hljs-keyword">blank</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s0</span>, print_loop<br><span class="hljs-symbol">print_end:</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">4</span><br>la   $<span class="hljs-built_in">a0</span>, next_line<br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">search:</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># i</span><br><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t8</span>, symbol($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-number">0</span>, Else<br><span class="hljs-symbol">If:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">t2</span>, array($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s1</span>, symbol($<span class="hljs-built_in">t9</span>)<br><br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">t0</span>)<br>push($<span class="hljs-built_in">t1</span>)<br><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jal </span> FullArray<br><br>pop($<span class="hljs-built_in">t1</span>)<br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, symbol($<span class="hljs-built_in">t9</span>)<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Else:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s0</span>, loop<br><span class="hljs-symbol">loop_end:</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure><h2 id="两个注意事项"><a href="#两个注意事项" class="headerlink" title="两个注意事项"></a>两个注意事项</h2><h3 id="1-注意return的位置"><a href="#1-注意return的位置" class="headerlink" title="1.注意return的位置"></a>1.注意return的位置</h3><p>观察C语言代码，我们发现有两个需要return的位置。一般来说，return直接写作<code>jr $ra</code>即可。</p><h3 id="2-递归调用前后的处理工作"><a href="#2-递归调用前后的处理工作" class="headerlink" title="2.递归调用前后的处理工作"></a>2.递归调用前后的处理工作</h3><p>我们把上面代码中设计递归调用的片段截取下来：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">t2</span>, array($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s1</span>, symbol($<span class="hljs-built_in">t9</span>)<br><br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">t0</span>)<br>push($<span class="hljs-built_in">t1</span>)<br><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jal </span> FullArray<br><br>pop($<span class="hljs-built_in">t1</span>)<br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, symbol($<span class="hljs-built_in">t9</span>)<br></code></pre></td></tr></table></figure><p>这里，<code>$ra</code>存储的是之前调用的位置+4，比如说在执行完<code>jal FullArray</code>之后，<code>$ra</code>存储的是pop($t1)的地址。<code>$t0</code>存的是参数index，<code>$t1</code>存的是FullArray里的遍历变量i。</p><p>进行push和pop的原因，无非是对寄存器内原有的值进行保护。<strong>对寄存器的保护(进行push和pop操作)一定是在函数调用前后进行的</strong>，而往往不是刚进入函数的时候。</p><p>难点在于，哪些变量需要被push？</p><ul><li><p>首先，<code>$ra</code>是必须被存在栈里的，否则调用结束后返回调用位置可能会出现异常；</p></li><li><p>然后，函数的参数、返回值等一般是需要被push的，在这里就是index；</p></li><li><p>其次，就是一些涉及到函数“状态”的量，比如说变量i，因为是对不同数字是否被占用进行遍历，存在遍历的先后顺序，所以i的不同会导致函数的“当前状态不同”；</p><p>假如不对i进行保存，i&#x3D;3时递归到第二层，在第二层中假设i最后为0且未进入第三层递归，那么再回到第一层时，i的值就与之前发生了变化，会造成函数执行异常；</p></li><li><p>最后，调用者(caller)调用的函数(callee)中，callee使用到了一些caller中使用的寄存器，那么进行函数调用的时候需要保护caller中的这些寄存器。</p></li></ul><p>确定了需要被push和pop的变量之后，我们还需要注意push和pop的顺序是否对应，栈是后入先出，最先<code>push($ra)</code>就要最后<code>pop($ra)</code>。</p><p>完成了push和pop的代码之后，我们就需要更新函数的参数</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># 下一个FullArray调用时参数为index + 1</span><br></code></pre></td></tr></table></figure><p>然后就可以递归调用了！</p><p>（一般来说函数的参数保存在<code>a0</code>-<code>a3</code>寄存器里，当我意识到这点时已经晚了）</p><p>至此，一个完整的含有递归的汇编代码就完成了！</p><p>借助上面的分析，看看下面这两道例题，并尝试自己解决。</p><h1 id="例题2：哈密顿回路"><a href="#例题2：哈密顿回路" class="headerlink" title="例题2：哈密顿回路"></a>例题2：哈密顿回路</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>题目编号 1109-5 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-5/mips5-12/">challenge！哈密顿回路 - 计算机组成教程 (buaa.edu.cn)</a></p><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><p>输入一个具有n个顶点的无向图G，判断G是否有哈密顿回路<a href="https://oi-wiki.org/graph/hamilton/">哈密顿图 - OI Wiki (oi-wiki.org)</a>。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数n，代表G有n个顶点，第二行是一个整数m，代表G有m条边，接下来的2 * m行，每行具有一个整数，设每个奇数行的数为a，它下一行的数b，序号为a, b的两个顶点间具有一条边，两个整数之间以回车隔开（点的标号从 1 开始）。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，若为 0 则代表G不具有哈密顿回路，若为 1 则代表G具有哈密顿回路。</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>1、0 &lt; n &lt; 100</p><p>2、0 &lt; m &lt; 100</p><p>3、请勿使用 <code>.globl main</code></p><p>4、最大运行指令条数限制为 100000</p><p>5、请使用 <code>syscall</code> 结束程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>6<br>1<br>2<br>1<br>3<br>2<br>3<br>2<br>4<br>3<br>5<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>6<br>1<br>2<br>1<br>3<br>2<br>3<br>2<br>4<br>1<br>4<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2"></a>输出样例2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h3 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h3><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="参考C语言代码"><a href="#参考C语言代码" class="headerlink" title="参考C语言代码"></a>参考C语言代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> G[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];    <span class="hljs-comment">// 采用邻接矩阵存储图中的边</span><br><span class="hljs-type">int</span> book[<span class="hljs-number">8</span>];    <span class="hljs-comment">// 用于记录每个点是否已经走过</span><br><span class="hljs-type">int</span> m, n, ans;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    book[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>, i;<br>    <span class="hljs-comment">// 判断是否经过了所有的点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        flag &amp;= book[i];<br>    &#125;<br>    <span class="hljs-comment">// 判断是否形成一条哈密顿回路</span><br>    <span class="hljs-keyword">if</span> (flag &amp;&amp; G[x][<span class="hljs-number">0</span>]) &#123;<br>        ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 搜索与之相邻且未经过的边</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!book[i] &amp;&amp; G[x][i]) &#123;<br>            dfs(i);<br>        &#125;<br>    &#125;<br>    book[x] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-type">int</span> i, x, y;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>        G[x - <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        G[y - <span class="hljs-number">1</span>][x - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从第0个点（编号为1）开始深搜</span><br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考解答"><a href="#参考解答" class="headerlink" title="参考解答"></a>参考解答</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br>G: <span class="hljs-meta">.space</span> <span class="hljs-number">280</span><br><span class="hljs-symbol">book:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">40</span><br><br><span class="hljs-meta">.macro</span> get(%des, %i, %<span class="hljs-keyword">j, </span>%col)<br><span class="hljs-keyword">mult </span>%i, %col<br><span class="hljs-keyword">mflo </span>%des<br><span class="hljs-keyword">add </span> %des, %des, %<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %des, <span class="hljs-number">2</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br><br><span class="hljs-meta">.text</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># n</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># m</span><br>li   $<span class="hljs-built_in">s7</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># constant</span><br><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">loop1:</span><br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s1</span>, loop1_end<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span><br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, G($<span class="hljs-built_in">t9</span>)<br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, G($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop1<br><span class="hljs-symbol">loop1_end:</span><br><br>li   $<span class="hljs-built_in">a0</span>, <span class="hljs-number">0</span><br>li   $<span class="hljs-built_in">s2</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># ans</span><br><span class="hljs-keyword">jal </span> dfs<br><br><span class="hljs-comment">## print answer</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">s2</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">dfs:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t8</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># i</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># flag</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loop2:</span><br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">s0</span>, loop2_end<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t8</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">and </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t9</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">t8</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop2<br><span class="hljs-symbol">loop2_end:</span><br><br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, G($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">Nope</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">Nope</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Nope:</span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># i in stack</span><br><span class="hljs-symbol">loop3:</span><br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, loop3_end<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-number">0</span>, Else<br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, G($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-number">0</span>, Else<br><br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">t0</span>)<br>push($<span class="hljs-built_in">a0</span>)<br><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">jal </span> dfs<br><br>pop($<span class="hljs-built_in">a0</span>)<br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Else:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop3<br><span class="hljs-symbol">loop3_end:</span><br><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure><h1 id="例题3：01迷宫"><a href="#例题3：01迷宫" class="headerlink" title="例题3：01迷宫"></a>例题3：01迷宫</h1><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>题目编号 1121-38 <a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=38&PieId=1121">P2_L1_puzzle - 系统能力课程实验平台 (buaa.edu.cn)</a></p><h3 id="题目要求-2"><a href="#题目要求-2" class="headerlink" title="题目要求"></a>题目要求</h3><ol><li>使用mips实现01迷宫路线数目计算。</li><li>以0x00000000为数据段起始地址。</li><li>输入一个n*m的01矩阵作为01迷宫，并给定他的起点与终点，求出他不同逃跑路线的数目（不同逃跑路线中可以有相同的部分，但是不能完全相同）。</li><li>每组数据最多执行5,000,000条指令。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://pic.imgdb.cn/item/6533cfecc458853aefa04018.png" alt="迷宫示例"></p><ol><li>上图表示的是一个4*5的01矩阵，这个矩阵就是一个01迷宫。</li><li>如上图，以红色0作为起点，绿色0作为终点，每一次行进只能选择上下左右中值为0且未走过的位置，满足上述条件的路线，即为一条迷宫逃跑路线。如右图中，蓝色的路线即为一条逃跑路线。</li></ol><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>前两行输入两个整数n和m（n、m均为正整数并且小于等于7），分别代表01矩阵行数和列数。接下来的n*m行，每行输入1个整数（0或1），对应着01矩阵各个元素值(第i*m+j个整数为矩阵的第（i+1）行第j个元素，即一行一行输入)。接下来的四行分别代表迷宫的起点和终点，每行一个整数，分别代表起点与终点行数和列数。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>只输出一个整数，代表逃跑路线的数目。</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>5<br>0<br>0<br>1<br>0<br>0<br>1<br>0<br>0<br>0<br>1<br>1<br>0<br>1<br>0<br>1<br>1<br>0<br>0<br>0<br>0<br>1<br>1<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h3 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h3><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="参考C语言代码-1"><a href="#参考C语言代码-1" class="headerlink" title="参考C语言代码"></a>参考C语言代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 100007</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1007</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> db double</span><br><span class="hljs-type">int</span> n, m, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> start_x, start_y, end_x, end_y;<br><span class="hljs-type">int</span> space[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>], book[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;, cnt);</span><br>    <span class="hljs-keyword">if</span> (x == end_x &amp;&amp; y == end_y) &#123;<br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> tx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (tx &lt;= <span class="hljs-number">0</span> || tx &gt; n || ty &lt;= <span class="hljs-number">0</span> || ty &gt; m || book[tx][ty] ||<br>            space[tx][ty]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        book[tx][ty] = <span class="hljs-number">1</span>;<br>        dfs(tx, ty);<br>        book[tx][ty] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;space[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;start_x, &amp;start_y);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;end_x, &amp;end_y);<br>    book[start_x][start_y] = <span class="hljs-number">1</span>;<br>    dfs(start_x, start_y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考解答-1"><a href="#参考解答-1" class="headerlink" title="参考解答"></a>参考解答</h2><h3 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">map:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">400</span><br><span class="hljs-symbol">dir:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">48</span><br><br><span class="hljs-meta">.macro</span> get_map(%des, %i, %<span class="hljs-keyword">j, </span>%col)<br><span class="hljs-keyword">mult </span>%i, %col<br><span class="hljs-keyword">mflo </span>%des<br><span class="hljs-keyword">add </span> %des, %des, %<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %des, <span class="hljs-number">2</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> get_dir(%des, %i, %<span class="hljs-keyword">j)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %i, <span class="hljs-number">1</span><br><span class="hljs-keyword">add </span> %des, %des, %<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %des, <span class="hljs-number">2</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br><br><span class="hljs-meta">.text</span><br>li   $<span class="hljs-built_in">s6</span>, -<span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">s7</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># const</span><br>li   $<span class="hljs-built_in">t8</span>, <span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">init_dir:</span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">3</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">main:</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># n</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># m</span><br><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># i</span><br><span class="hljs-symbol">input1:</span><br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, input1_end<br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># j</span><br><span class="hljs-symbol">input2:</span><br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s1</span>, input2_end<br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s1</span>)<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">v0</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   input2<br><span class="hljs-symbol">input2_end:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   input1<br><span class="hljs-symbol">input1_end:</span><br><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># start_x</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># start_y</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s4</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># end_x</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s5</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># end_y</span><br>li   $<span class="hljs-built_in">t7</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># result</span><br><br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">s2</span> <span class="hljs-comment"># argument x</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">s3</span> <span class="hljs-comment"># argument y</span><br><br><span class="hljs-keyword">jal </span> dfs<br><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t7</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">dfs:</span><br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">s4</span>, Else<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">s5</span>, Else<br><span class="hljs-symbol">If0:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t7</span>, $<span class="hljs-built_in">t7</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol">Else:</span><br><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># for int i = 0;</span><br><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">bge </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t8</span>, loop_end<br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t1</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s7</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t2</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">add </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">a1</span> <span class="hljs-comment">#tx</span><br><span class="hljs-keyword">add </span> $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">a2</span> <span class="hljs-comment">#ty</span><br><br><span class="hljs-keyword">ble </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-number">0</span>, If<br><span class="hljs-keyword">ble </span> $<span class="hljs-built_in">t2</span>, $<span class="hljs-number">0</span>, If<br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s0</span>, If<br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>, If<br><br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t3</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t3</span>, $<span class="hljs-number">0</span>, If<br><br><span class="hljs-comment"># possible</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, map($<span class="hljs-built_in">t9</span>)<br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">a2</span>)<br>push($<span class="hljs-built_in">a1</span>)<br>push($<span class="hljs-built_in">t2</span>)<br>push($<span class="hljs-built_in">t1</span>)<br>push($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">t2</span><br><br><span class="hljs-keyword">jal </span> dfs<br><br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">t1</span>)<br>pop($<span class="hljs-built_in">t2</span>)<br>pop($<span class="hljs-built_in">a1</span>)<br>pop($<span class="hljs-built_in">a2</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">If:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop<br><span class="hljs-symbol">loop_end:</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式总结</title>
    <link href="/2023/10/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/10/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（也称为”元字符”），是一种可以用来描述和匹配字符串的特定模式。</p><p>正则表达式提供了一种灵活且强大的方式来查找、替换、验证和提取文本数据，是一种用于模式匹配和搜索文本的工具。</p><h2 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串<br>可以查找文档内或输入域内特定的文本。</li></ul><p>如果需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p><h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>正则表达式的模式可以包括以下内容：</p><ul><li>字面值字符：例如字母、数字、空格等，可以直接匹配它们自身。</li><li>特殊字符：例如点号 .、星号 *、加号 +、问号 ? 等，它们具有特殊的含义和功能。</li><li>字符类：用方括号 [ ] 包围的字符集合，用于匹配方括号内的任意一个字符。</li><li>元字符：例如 \d、\w、\s 等，用于匹配特定类型的字符，如数字、字母、空白字符等。</li><li>量词：例如 {n}、{n,}、{n,m}等，用于指定匹配的次数或范围。</li><li>边界符号：例如 ^、$、\b、\B 等，用于匹配字符串的开头、结尾或单词边界位置。</li></ul><div class="note note-success">            <p><strong>Example</strong></p><p>我们有这样的一个正则表达式：^ [0-9]+abc$。这是什么意思呢？</p><ul><li><p>^ 为匹配输入字符串的开始位置。</p></li><li><p>[0-9]+匹配多个数字，[0-9]匹配单个数字，+表示匹配一个或者多个。</p></li><li><p>abc匹配字母abc并以abc结尾，$为匹配输入字符串的结束位置。</p></li></ul><p>这个样例让我们直观的感受了一下正则表达式的作用，后面的内容会介绍相关的字符和语法规则。</p>          </div><h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><ul><li>普通字符（字面值字符）：普通字符按照字面意义进行匹配，例如匹配字母 “a” 将匹配到文本中的 “a” 字符。<blockquote><p>(hello world) —- hello world √ Hello world ×<br>(12345) —- 12345 √ 1234×</p></blockquote></li><li>元字符：元字符具有特殊的含义，例如 \d 匹配任意数字字符，\w 匹配任意字母数字字符，. 匹配任意字符（除了换行符）等。</li></ul><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><ul><li>*：匹配前面的模式零次或多次。<blockquote><p>(hel*o world) —– helo world √ hello world √ heo world √<br>(hello world) * —– 空串 √ hello world √ hello worldhello world √</p></blockquote></li><li>+：匹配前面的模式一次或多次。<blockquote><p>(hel+o world) —– helo world √ hello world √ heo world ×<br>(hello world)+ —– 空串 × hello world √ hello worldhello world √</p></blockquote></li><li>?：匹配前面的模式零次或一次。<blockquote><p>(hel?o world) —– helo world √ hello world × heo world √<br>(hello world)? —– 空串 √ hello world √ hello worldhello world ×</p></blockquote></li><li>{n}：匹配前面的模式恰好 n 次。</li><li>{n,}：匹配前面的模式至少 n 次。</li><li>{n,m}：匹配前面的模式至少 n 次且不超过 m 次。<blockquote><p>(hello{3}) —– hellooo √ hello ×<br>(hello{1,}) —– hello √ helloo √<br>(hello{1,3}) —– hello √ helloo √ hellooo √</p></blockquote></li><li>要匹配这些特殊字符本身，需要在其前方加上反斜杠符号。</li></ul><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ul><li>[ ]：匹配括号内的任意一个字符。<br>例如，[abc] 匹配字符 “a”、”b” 或 “c”。</li><li>[^ ]：匹配除了括号内的字符以外的任意一个字符。<br>例如，[^abc] 匹配除了字符 “a”、”b” 或 “c” 以外的任意字符。<blockquote><p>([123]{2}) — 11 √ 12 √ 13 √ 21 √ 22 √ 34 ×</p></blockquote></li></ul><h2 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h2><ul><li>^：匹配字符串的开头。</li><li>$：匹配字符串的结尾。</li><li>\b：匹配单词边界。</li><li>\B：匹配非单词边界。</li><li>\w: 匹配一个字，包括大小写字母，数字和下划线，等价于[0-9a-zA-Z_]。<blockquote><p>\w+ —– a √ 123 √ 2024O_o √</p></blockquote></li><li>\d: 匹配一个数字，等价于[0-9]。<blockquote><p>\d+ —– 1 √ 123 √</p></blockquote></li></ul><h2 id="分组和捕获"><a href="#分组和捕获" class="headerlink" title="分组和捕获"></a>分组和捕获</h2><ul><li>( )：用于分组和捕获子表达式。</li><li>(?: )：用于分组但不捕获子表达式。</li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li>\：转义字符，用于匹配特殊字符本身。</li><li>.：匹配任意字符（除了换行符）。<blockquote><p>(hello.rld) —– hello world × hellowrld √<br>(hello\.world) —– hello.world √ hello world × helloworld ×</p></blockquote></li><li>|：用于指定多个模式的选择。</li></ul><h1 id="修饰符（标记）"><a href="#修饰符（标记）" class="headerlink" title="修饰符（标记）"></a>修饰符（标记）</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><div class="note note-success">            <p><strong>Example</strong></p><p>&#x2F;pattern&#x2F;flags</p>          </div><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore-不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 . 中<br>包含换行符\n</td><td align="left">默认情况下的圆点 . 是匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符\n。</td></tr></tbody></table><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>(), (?:), (?&#x3D;), []</td><td>圆括号和方括号</td></tr><tr><td>*, +, ?, {n}, {n,}, {n,m}</td><td>限定符</td></tr><tr><td>^, $, \任何元字符、任何字符</td><td>定位点和序列（即：位置和顺序）</td></tr><tr><td>|</td><td>替换，”或”操作<br>字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-danger">            <p>这部分内容感觉更像是新的讲解 :)</p>          </div><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td>.</td><td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 “(.|n)”的模式。</td></tr><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘\(‘ 或 ‘\)’。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies)’ 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td>(?&#x3D;pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?&lt;&#x3D;pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。</td></tr><tr><td>x|y</td><td>匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\cx</td><td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td>\xn</td><td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td>\num</td><td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td>\nml</td><td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td>\un</td><td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>菜鸟教程：<a href="https://www.runoob.com/regexp/regexp-tutorial.html">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>]]></content>
    
    
    <categories>
      
      <category>面向对象设计与构造</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>coPre测试题目与解析</title>
    <link href="/2023/09/27/coPre%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/09/27/coPre%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>Pre共有三道题，分别考察了MIPS、Verilog和Logisim，考试时间2小时。<br>以下试题内容均为回忆版，还请见谅。</p>          </div><h1 id="第一题：supaltitude"><a href="#第一题：supaltitude" class="headerlink" title="第一题：supaltitude"></a>第一题：supaltitude</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>阿庄哥（随便起的名字）从某处开始沿着山路骑车。设起点的相对海拔为$0$，从起点到终点一共经过了$n$个记录点，给出该记录点与前一个记录点的相对海拔差，输出整个过程中所处的最高相对海拔值。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul><li>一个正整数$n$，表示从起点开始总共经过的记录点的个数；</li><li>一个数组$a[n]$，其中$a[i]$表示第$i$个记录点相对于第$i-1$个检查点的相对海拔差；</li><li>输入数据保证$0 \le n \le 128$, $-128 \le a[i] \le 128$。</li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li>一个整数，表示整个过程中所处的最高相对海拔值。</li></ul><h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">7<br>3<br>-1<br>-4<br>1<br>5<br>-3<br>1<br></code></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h3><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">6<br>-4<br>-3<br>-2<br>-1<br>4<br>4<br></code></pre></td></tr></table></figure><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先需要考虑的是，需不需要开辟数组空间？</p><p>题目的本质是想要我们求<strong>连续子数组的最大和</strong>，所以其实只需要每次读入一个数，更新当前的前缀和，并与最大前缀和对比即可，并不需要开辟数组空间。</p><div class="note note-info">            <p>前缀和：从nums数组第0个数开始累加，到第$i$个位置的累加结果。</p>          </div><p>清楚题意之后，我们可以尝试写出以下c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, n, a;<br>    <span class="hljs-comment">// max是最大前缀和，sum是当前前缀和</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>        sum += a;<br>        <span class="hljs-keyword">if</span>(max &lt; sum)<br>            max = sum;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, max);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在Pre的MIPS汇编程序设计中已经学习了条件语句和循环语句的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text<br>li $t1, 100             #t1 = 100<br>li $t2, 200             #t2 = 200<br>slt $t3, $t1, $t2       #if(t1 &lt; t2) t3 = 1 <br>beq $t3, $0, if_1_else<br>nop<br>#do something<br>j if_1_end              #jump to end<br>nop<br>if_1_else:<br>#do something else<br><br>if_1_end:<br>li $v0, 10<br>syscall<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text<br>li $t1, 100             #n = 100<br>li $t2, 0               #i<br><br>for_begin1:             #for (int i = 0; i &lt; n; i++)<br>slt $t3, $t2, $t1       #&#123;<br>beq $t3, $0, for_end1  <br>nop      <br>#do something<br>addi $t2, $t2, 1        #i++<br>j for_begin1<br>nop                     #&#125;  <br><br>for_end1:<br>li $v0, 10<br>syscall<br><br></code></pre></td></tr></table></figure><p>基于以上分析与所学知识，我们便可以完成所需的MIPS程序。</p><blockquote><p>提示： </p><ul><li>对于MIPS程序设计题，先写出可解决该问题的C语言程序代码，再逐句“翻译”成对应的MIPS指令，是一种值得尝试的选择；</li><li>编写MIPS代码时可以添加一些空格、缩进、标签、注释等，增强代码的可读性。</li></ul></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">main:<br>li   $v0, 5<br>syscall<br>move $s0, $v0 #n = $v0 = $s0<br>li   $s1, 0   #max = 0<br>li   $s2, 0   #sum = 0<br>li   $t0, 0   #i = 0<br>for_loop:<br>beq  $t0, $s0, for_loop_end<br>li   $v0, 5<br>syscall<br>move $t1, $v0<br>add  $s2, $s2, $t1<br>ble  $s2, $s1, else<br>if:<br>move $s1, $s2<br>else:<br>addi $t0, $t0, 1<br>j    for_loop<br><br>for_loop_end:<br>move $a0, $s1<br>li   $v0, 1<br>syscall<br>li   $v0, 10<br>syscall<br></code></pre></td></tr></table></figure><h1 id="第二题：noDescendSequence"><a href="#第二题：noDescendSequence" class="headerlink" title="第二题：noDescendSequence"></a>第二题：noDescendSequence</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>“不下降数”表示一个整数的高位数码不会大于低位数码。例如，$1234$、$1223$是“不下降数”，而$1243$不是“不下降数”。</p><p>使用Verilog构建一个判断一个4位16进制数输入是否为“不下降数”的电路。</p><p>端口定义如下：</p><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>in[15:0]</td><td>I</td><td>接受带判断的数字</td></tr><tr><td>out</td><td>O</td><td>如果是“不下降数”，返回1；<br>否则，返回0</td></tr></tbody></table><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这道题很简单，只需要把in的四个数码分别比较即可。</p><blockquote><p>在完成模块的设计后，最好使用testbench进行测试。</p></blockquote><h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> noDescendSequence(<br><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in,<br><span class="hljs-keyword">output</span> out<br>);<br><span class="hljs-keyword">assign</span> out = (in[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>] &lt;= in[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>] &amp;&amp; in[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>] &lt;= in[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>] <br>&amp;&amp; in[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>] &lt;= in[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h1 id="第三题：tetris"><a href="#第三题：tetris" class="headerlink" title="第三题：tetris"></a>第三题：tetris</h1><p>忘了题目了，好像是Mealy型自动机，大家全面准备吧:)</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
