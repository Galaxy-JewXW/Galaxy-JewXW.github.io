<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS假期预习（二）——MIPS知识补充</title>
    <link href="/2024/02/24/111/"/>
    <url>/2024/02/24/111/</url>
    
    <content type="html"><![CDATA[<h1 id="OS假期预习（二）——MIPS知识补充"><a href="#OS假期预习（二）——MIPS知识补充" class="headerlink" title="OS假期预习（二）——MIPS知识补充"></a>OS假期预习（二）——MIPS知识补充</h1><p>下面将介绍操作系统实验使用的 CPU 与我们计组的课设 CPU 的不同之处，并对 MIPS 汇编相关知识进行补充。</p><p>操作系统实验使用 MIPS32 4Kc CPU， 这是一款由 MIPS® Technologies 公司开发的使用 MIPS32 指令集的商业处理器核。</p><p>而计组中实现的 CPU 使用 MIPS-C 指令集，MIPS-C 指令集是 MIPS32 指令集的精简版本，也就是相当于计组实现的 CPU 指令集和功能是操作系统实验中使用的一个子集。</p><p>具体谈及操作系统实验中涉及，而计组 CPU 不完整的功能，主要是有两个部分：访存流程、CP0协处理器相关。</p><h2 id="访存流程"><a href="#访存流程" class="headerlink" title="访存流程"></a>访存流程</h2><p>在计组中，我们的 CPU 不存在<strong>虚拟地址</strong>机制，访存指令中的所有地址均是物理地址。物理地址被直接发送到 DM、IM 中，直接获取数据。这简化了 MIPS32 的访存流程，让大家可以更多的关注 CPU 内部计算与控制逻辑。</p><p>而在完整的 MIPS32 访存流程中，汇编指令 <strong>不直接和物理内存打交道</strong>。</p><p>访存指令中的地址，被称作<strong>虚拟地址</strong>，在执行访存操作的时候，虚拟地址会先被送入 <strong>MMU</strong> 进行<strong>地址翻译</strong>、<strong>权限检查</strong>，最终拿到物理地址。</p><p>对于 MMU 检查合法的访存操作，通过 MMU 拿到物理地址之后，相应访存操作才会进一步被实际在物理地址上执行。</p><p>所有的软件（包括 MIPS 汇编、C 语言编写的软件等）访存的地址都是虚拟地址。</p><p>MIPS32 的 MMU 支持基于 <strong>TLB</strong> 的 <strong>页式地址翻译</strong>，而操作系统实验使用了 MIPS32 的这个地址翻译功能。这一部分在计组的 CPU 中并没有涉及。</p><p>这将牵扯出我们OS中的两个知识点：MIPS32 具体访存流程、TLB 在 MIPS32 地址翻译中扮演的角色。具体内容将在我们 Lab2 内存管理中学到，在 pre 中我们仅介绍到此。</p><p>目前，只需要大家牢记，在 MIPS32 指令集中，我们的访存指令不再直接操作物理地址，而是使用虚拟地址以及地址翻译机制，间接管理物理内存。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS假期预习（一）——Linux，Git与Shell脚本</title>
    <link href="/2024/02/23/OSPre1/"/>
    <url>/2024/02/23/OSPre1/</url>
    
    <content type="html"><![CDATA[<h1 id="OS假期预习（一）——Linux，Git与Shell脚本"><a href="#OS假期预习（一）——Linux，Git与Shell脚本" class="headerlink" title="OS假期预习（一）——Linux，Git与Shell脚本"></a>OS假期预习（一）——Linux，Git与Shell脚本</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Linux是什么？"><a href="#Linux是什么？" class="headerlink" title="Linux是什么？"></a>Linux是什么？</h3><p>Linux 操作系统是基于 <strong>Linux 内核</strong>的开源操作系统，Linux 内核在 1991 年由 Linus Torvalds 首次发布，在庞大的社区下不断完善和升级。Linux 系统通常制作成 <strong>Linux 发行版</strong>供用户使用。Linux 发行版包括 Linux 内核，以及相关的软件和库。这些软件和库大多数都是由 <strong>GNU 项目</strong>提供的。</p><p>GNU（GNU is Not Unix 的递归缩写），是一个广泛的自由软件集合，为 Linux 操作系统提供了大量的开源软件。这些开源软件有一些非常出名，可以说是家喻户晓：比如的编译器套件 GCC 和调试器 GDB，编程语言 Pascal，用于科学计算的 R 语言，很多人以之为信仰的 Emacs 编辑器等，都是 GNU 项目的产物。</p><p>实验课程使用的 Linux 发行版叫做 Ubuntu，是目前最为流行的 Linux 发行版之一。</p><h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>使用命令行界面（Command Line Interface，CLI），我们会用一行一行的命令来告诉操作系统我们需要进行什么操作，操作系统也会把执行的结果输出到屏幕上。</p><p>Shell 直译为“壳”，也就是操作系统的“外壳”（相对于操作系统“内核”而言），即用于访问操作系统服务的用户界面。Shell 可以分为命令行界面（CLI Shell）和图形用户界面（GUI Shell，GUI 是 Graphical User Interface 的简称）。我们经常使用的 Windows，macOS，都是 GUI Shell，很多 Linux 发行版也会提供 GUI Shell，但服务器上运行的 Linux 一般都是 CLI Shell。</p><p>使用CLI Shell的主要原因在于：</p><ul><li>节约资源。在很多资源有限的小型服务器或单片机设备上，内存和 CPU 等资源是十分受限的。运行 GUI Shell 本身就是一笔不小的资源开销，这会大大增加系统性能的负担。</li><li>高效自动化操作。举个例子：如果你希望把一个目录下的一千多个文件按序号重命名，在 GUI Shell 下可能很难实现，需要一个一个重命名。但在 CLI Shell 下，你就可以写一个脚本文件，利用循环高效完成这些操作。对于很多复杂操作，GUI 可能不会提供相应的操作方式，但命令行可以完成相当复杂的操作逻辑。</li><li>精准操作。命令行本质上是对操作和返回结果的文本描述。针对一些复杂的操作，我们只需要将命令的集合打包成一个脚本文件，就可以在以后精准复现这些操作。这种性质在传播经验时也非常奏效：相比于手把手教你在图形界面上点来点去，不如直接发你一个命令脚本，你就立刻能够知道每一步都在做什么，而且可以直接运行复现。</li></ul><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>在命令行界面中，用户通过一行一行命令向操作系统发出指示，从而达到人机交互的目的。在 Linux 操作系统中，命令的一般格式为：<code>命令名 [选项] [参数] ...</code>，方括号的意思是可选，意为可以没有，也可以有一个或多个。</p><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><div class="note note-success">            <p>cd 用法：</p><p>cd [选项] 目录 </p><p>作用：切换到某个目录（Change Directory）。</p>          </div><p>终端底部出现了新的一行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cd /<br>git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:/</span>$<br></code></pre></td></tr></table></figure><p>这一行大致理解为：我们进入了 <code>/</code> 这个目录。那么 <code>/</code> 这个目录是什么，上一行的 <code>~</code> 又是什么，</p><p>Linux 文件系统的最顶层是根目录，<code>/</code> 表示的就是根目录，Linux 一切的文件都存放在根目录下。我们刚刚就进行了“切换到根目录”的操作。根目录下放置所有的二级目录，包括 Linux 内核启动需要的 <code>/boot</code> 目录，系统配置文件的 <code>/etc</code> 目录，存放普通用户主目录的目录 <code>/home</code>，系统管理员的用户（即 root 用户）主目录 <code>/root</code>，用户系统资源存放的目录 <code>/usr</code> 等等……如果对每个目录都存放什么内容感兴趣，可以利用搜索引擎搜索，这里就不赘述了。</p><p><code>~</code> 则是当前用户主目录的简写，你可以使用 <code>cd ~</code> 回到当前用户主目录。对于一般用户，主目录是 <code>/home/用户名</code>，对于 root 用户，主目录则是 <code>/root</code>。<code>$</code> 代表当前的用户是普通用户；如果当前用户是系统管理员（root）用户，则此处会显示 <code>#</code>。在下文中，我们统一用 <code>$ xxx</code> 表示你应当在终端中输入命令 <code>xxx</code>，这里 <code>$</code> 是终端中显示的符号。</p><p>假设我们目前处于根目录（即 <code>/</code> 目录），接下来我们试着进入 <code>/etc</code> 这个目录。很容易想到命令是 <code>cd /etc</code>，但输入 <code>cd etc</code> 也能等效地完成任务。可以看出，<code>cd</code> 命令是支持<strong>相对路径</strong>的。当我们输入 <code>cd etc</code> 时，系统会在当前的目录，也就是 <code>/</code> 中寻找 <code>etc</code> 这个目录并切换到那里。</p><p>那我们如何返回上一级目录呢？在 Linux 系统中，<code>.</code> 表示当前目录，<code>..</code> 表示上一级目录，所以我们输入 <code>cd ..</code> 就可以返回到上一级目录了。如果输入 <code>cd .</code>，就代表切换到当前所在的目录，也就是什么都不做。还有一个特别的小技巧：输入 <code>cd -</code> 可以跳转到上一次访问的目录。</p><p>查看目录下的文件，可以使用<code>ls</code>命令。</p><div class="note note-success">            <p>ls<br>用法：ls [选项] [目录]<br>作用：列出目录中的文件。若参数“目录”未给出，则列出当前目录中的文件。<br>选项（常用）：<br>-a              显示隐藏的文件<br>-l              每行只列出一个文件</p>          </div><p>创建一个新的目录，可以使用<code>mkdir</code>命令。</p><div class="note note-success">            <p>mkdir<br>用法：mkdir [选项] 目录<br>作用：创建一个新目录。</p>          </div><p>使用 <code>cd ~</code> 命令回到用户的主目录。这时输入 <code>mkdir newdir</code> 就可以在主目录下创建一个新的目录 <code>newdir</code>。输入 <code>cd newdir</code> 就可以进入刚刚创建的目录。可以注意到，终端已经对当前目录做出了提示，变成了：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:~/newdir</span>$<br></code></pre></td></tr></table></figure><p>我们可以输入 <code>pwd</code> 命令，查看当前目录的绝对路径。</p><div class="note note-success">            <p>pwd<br>用法：pwd [选项]<br>作用：输出当前目录的绝对路径。</p>          </div><p>结果如下所示，这也和刚才提到的 <code>~</code> 的概念相互印证。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git<span class="hljs-variable">@21xxxxxx</span><span class="hljs-symbol">:~/newdir</span><span class="hljs-variable">$ </span>pwd<br>/home/git/newdir<br></code></pre></td></tr></table></figure><p>与 <code>mkdir</code> 对应，我们还有删除<strong>空</strong>目录的命令 <code>rmdir</code>，请注意，这个命令只能删除空目录。</p><div class="note note-success">            <p>rmdir<br>用法：rmdir [选项] 目录<br>作用：删除一个空的目录。请注意，只有空的目录才能被删除。</p>          </div><p>退回到用户主目录下，我们可以删除 <code>newdir</code> 这个目录。</p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>在 Linux 的哲学下<strong>一切皆文件</strong>，包括目录、设备等等全部是以文件方式存在于操作系统中的。上一节之所以叫做”目录操作“，是因为所介绍的几个命令是“目录”这种文件独有的命令。这一节叫做“文件操作”，介绍的命令是一般文件（包括目录）都可以操作的命令。例如复制和删除操作，其对象可以是几乎所有文件，也包含目录。</p><p>我们首先介绍如何利用 <code>touch</code> 命令创建一个新的空文件。</p><div class="note note-success">            <p>touch<br>用法：touch [选项] 文件名<br>作用：当文件存在时更新文件的时间戳，当文件不存在时创建新文件。</p>          </div><p>我们主要利用的是后者（创建新文件）的作用。进入用户主目录，输入 <code>touch helloworld.c</code>，就可以创建一个叫做 <code>helloworld.c</code> 的文件。</p><p>那么如何删除一个文件，或者删除一个非空的目录呢？</p><div class="note note-success">            <p>rm<br>用法：rm [选项] 文件<br>作用：删除文件。<br>选项（常用）：<br>-r              递归删除目录及其内容，删除非空目录必须有此选项，否则无法删除。<br>-f              强制删除，不提示用户确认，忽略不存在的目录。<br>-i              逐一提示用户确认每个将要被删除的文件。</p>          </div><blockquote><p>Tips：<code>rm -rf</code> 是十分危险的命令（尤其在 root 用户下），非必要不使用 <code>rm -rf</code> 命令，在执行之前需要再三确认。root 用户具有至高无上的权限，在该用户下执行 <code>rm -rf /</code> 可以删除一切文件，包括 Linux 本身，从而导致系统被毁灭。</p></blockquote><p>常用的文件操作除了新建文件和删除文件，还有复制和移动文件。</p><div class="note note-success">            <p>cp<br>用法：cp [选项] 源文件 目标路径<br>作用：将源文件（也可以是目录）复制为目标路径对应的文件（如果目标路径是文件）或复制到目标路径（如果目标路径是目录）。<br>选项（常用）：<br>-r              递归复制目录及其子目录内的所有内容。</p>          </div><blockquote><p>递归复制指的是当要复制的目录下存在子目录，且子目录中存在子目录或文件的时候，将逐一复制它们。windows的复制默认是递归复制的。</p><p>如果不递归复制，结果得到的目录只包含空的子目录，其子目录下的内容将不会复制。</p></blockquote><p>我们在用户主目录中使用命令 <code>touch test.txt</code> 来创建一个名为 <code>test.txt</code> 的文件，然后使用 <code>mkdir dir</code> 创建一个名为 <code>dir</code> 的目录。接下来使用 <code>cp test.txt dir/</code> 来进行复制操作。我们先用前面提到过的 <code>ls</code> 命令看看当前目录下的 <code>test.txt</code> 是否还存在，然后切换到 <code>dir</code> 目录，使用 <code>ls</code> 命令，可以看到 <code>test.txt</code> 这个文件。</p><div class="note note-success">            <p>mv<br>用法：mv [选项] 源文件 目标路径<br>作用：将源文件（也可以是目录）移动为目标路径对应的文件（如果目标路径是文件）或移动到目标路径（如果目标路径是目录）。<br>选项（常用）：<br>-r              递归移动目录及其子目录内的所有内容。</p>          </div><p><code>mv</code> 命令的另外一个作用就是重命名文件。原理上很好理解，也就是把一个文件以不同的名字移动到当前目录下，这和重命名是等价的。举个例子，我们在 <code>dir</code> 下使用 <code>mv test.txt test2.txt</code> 就可以把 <code>test.txt</code> 重命名为 <code>test2.txt</code> 了。</p><p>对于两个纯文本文件来说，我们还可以使用 <code>diff</code> 命令进行比较的操作。</p><div class="note note-success">            <p>diff<br>用法：diff [选项] 文件1 文件2<br>选项（常用）：<br>-b              不检查空白字符的不同。<br>-B              不检查空行。<br>-q              仅显示有无差异，不显示详细信息。</p>          </div><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>在 Windows 或 macOS 操作系统中，文件管理器提供了搜索的功能，以便我们查找文件。那么在 Linux 下如何进行查找操作呢？我们引入两个命令：<code>find</code> 和 <code>grep</code>。</p><div class="note note-success">            <p>find<br>用法：find [路径] &lt;选项&gt;<br>作用：在给定路径下递归地查找文件，输出符合要求的文件的路径。如果没有给定路径，则在当前目录下查找。<br>选项（常用）：<br>-name &lt;文件名&gt;             指定需要查找的文件名。</p>          </div><p>使用 <code>find</code> 命令并加上 <code>-name</code> 选项可以在当前目录下递归地查找符合参数所示文件名的文件，并将文件的路径输出至屏幕上。</p><p><code>grep</code> 命令则有所不同。<code>find</code> 是根据文件的属性（文件名、修改日期等）查找文件，而 <code>grep</code> 则是匹配文件内的内容查找文件和文件中的匹配位置。</p><div class="note note-success">            <p>grep<br>用法：grep [选项] PATTERN FILE<br>（PATTERN是匹配字符串，FILE是文件或目录的路径）<br>作用：输出匹配PATTERN的文件和相关的行。<br>选项（常用）：<br>-a              不忽略二进制数据进行搜索。<br>-i              忽略大小写差异。<br>-r              从目录中递归查找。<br>-n              显示行号。</p>          </div><p>当你需要在整个项目目录中查找某个函数名、变量名等特定文本的时候，<code>grep</code> 将是你手头一个强有力的工具。</p><p>前面讲到 <code>ls</code> 命令的功能是列出文件。在我们的 Linux 系统中有一个比 <code>ls</code> 更“高级”的命令，叫做 <code>tree</code>，它可以直接输出一个目录下的文件树。这个命令一般不是 Linux 发行版预装的，但我们已经为你安装好了，直接使用即可。</p><div class="note note-success">            <p>tree<br>用法: tree [选项] [目录名]<br>选项(常用)：<br>-a              列出全部文件（包含隐藏文件）。<br>-d              只列出目录。</p>          </div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>连接终端后，我们所处的目录是 <code>~</code> 目录，也就是用户主目录。我们可以使用 <code>ls</code> 命令列出一个目录下都有什么内容，可以用 <code>cd</code> 进入到一个目录（输入绝对路径和相对路径都可以），可以用 <code>pwd</code> 显示当前目录的绝对路径。我们可以用 <code>mkdir</code> 创建一个目录，用 <code>rmdir</code> 删除一个空目录。我们可以使用 <code>touch</code> 新建文件，<code>rm</code> 删除文件，<code>cp</code> 复制文件，<code>mv</code> 移动或者重命名文件。</p><p>如果想要查看一个命令的详尽说明，就需要使用 Linux 下的帮助命令——<code>man</code> 命令，通过 <code>man</code> 命令可以查看 Linux 中的命令帮助、配置文件帮助和编程帮助等信息。</p><div class="note note-success">            <p>man<br>用法：man [选项] 命令<br>作用：查看命令的详细说明手册。</p>          </div><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><h3 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h3><ul><li>Ctrl+C 终止当前程序的执行。当程序卡死或者你不想让它继续执行了，可以输入 Ctrl+C 终止程序。请注意，Ctrl+C 在 Windows 中是复制的意思，但在 Linux CLI 的环境下就是结束进程的意思。所以在使用终端模拟器（比如使用浏览器或 XShell 等）连接终端时，复制终端中显示的内容时记得不要按 Ctrl+C，而是老老实实右键复制，以免误杀进程。</li><li>Ctrl+Z 挂起当前程序。暂停程序，放到后台。Ctrl+Z 挂起程序后会显示该程序挂起编号，若想要恢复该程序可以使用 <code>fg [job_spec]</code>即可，<code>job_spec</code> 即为挂起编号，不输入时默认为最近挂起进程。</li><li>Ctrl+D 终止输入（若正在使用 Shell，则退出当前 Shell）。在标准输入中输入 Ctrl+D 也意味着输入了一个 EOF。</li><li>Ctrl+L 清屏。相当于命令 <code>clear</code>。</li></ul><p>特别提示，Ctrl+S 在终端中的作用是暂停该终端。有的同学在进行编辑的时候会误触此组合键导致终端“卡死”，此时使用 Ctrl+Q 组合键即可让终端继续运行。</p><blockquote><p>Tips：在多数 Shell 中，四个方向键也是有各自特定的功能的：Left 和 Right 可以控制光标的位置，Up 和 Down 可以切换最近使用过的命令。</p></blockquote><h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><p>下面介绍的若干 Linux 下的实用工具，它们都是在 Linux 下开发工作中非常重要的工具，可以说是不可或缺。</p><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>GCC（GNU Compiler Collection，GNU 编译器套件）包含了著名的 C 语言编译器 gcc（GNU project C and C++ compiler）。</p><div class="note note-success">            <p>gcc<br>用法：gcc [选项] 源代码文件<br>作用：编译源代码文件。</p>          </div><p>首先我们在用户主目录下创建一个文件 <code>hello.c</code>，使用 Vim 打开这个文件。进入编辑模式，输入以下内容，保存退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来在当前目录下使用 <code>gcc</code> 命令进行编译。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello.c<br></code></pre></td></tr></table></figure><p>此时我们没有看到相关输出，说明编译过程成功完成。在当前目录下出现了 <code>a.out</code> 这个文件（这个文件名是 gcc 编译器默认的可执行程序的文件名）。</p><p>既然 gcc 为我们编译出了一个可执行文件，那么我们就可以执行这个文件。执行 <code>a.out</code> 的命令是：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>我们知道，<code>./</code> 是“当前目录下”的意思。为什么要加上一个 <code>./</code> 呢，难道不是多此一举吗？实际上在 Linux 中，<code>./</code> 表示被执行的文件在当前目录，Linux 会在当前目录中查找可执行文件。如果不加 <code>./</code>，那么 Linux 就会在“系统 <code>PATH</code>”中寻找。然而 <code>a.out</code> 并不在系统 <code>PATH</code> 中，所以 Shell 就会报错<code>a.out: command not found</code>。</p><blockquote><p>系统 <code>PATH</code>：<code>PATH</code> 是一个系统变量，记录了若干目录。如果待运行的程序不在当前目录，操作系统便可以去依次搜索 <code>PATH</code> 变量中记录的目录，如果在这些目录中找到待运行的程序，操作系统便可以运行这个程序。</p></blockquote><p>运行 <code>a.out</code> 之后，我们就可以看到终端输出了 <code>Hello, world!</code>。</p><h3 id="make-Makefile"><a href="#make-Makefile" class="headerlink" title="make &amp; Makefile"></a>make &amp; Makefile</h3><p>GNU 项目中有一个叫做“make”的工具，是最常用的 C 语言项目构建工具。我们都知道，“make”是制作的意思，而 make 构建工具的作用本质上就是“制作出一个文件”。当我们开发了一个较大的项目，make 工具就可以将这些文件编译链接成可执行文件。当然 make 工具进行编译和链接的操作是需要人工指导的，这个“指导文件”就是 Makefile。make 工具可以根据时间戳自动判断项目的哪些部分是需要重新编译的，每次只重新编译必要的部分。make 工具是基于 Shell 命令运行的，所以只要项目的编译器可以通过 Shell 命令调用，make 都可以对项目进行构建。</p><p>为了能够清晰地了解 make 的基本概念，我们来使用 Makefile 指导编译一个最简单的项目——也就是刚刚的 Hello World 项目。</p><p>不使用 make 工具，我们可以使用下面的命令来对 hello.c 进行编译：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -o hello hello.c<br></code></pre></td></tr></table></figure><p>如果使用 make 工具来构建，我们就需要在当前目录下创建并编辑 Makefile 文件（文件名就叫做 <code>Makefile</code>）。Makefile 的基本格式如下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target</span>: dependencies<br>    <span class="hljs-keyword">command</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">command</span> <span class="hljs-number">2</span><br>    ...<br>    <span class="hljs-keyword">command</span> n<br></code></pre></td></tr></table></figure><p>其中，<code>target</code> 是我们构建（Build）的目标，可以是真的目标文件、可执行文件，也可以是一个标签（详见参考教程）。而 <code>dependencies</code> 是构建该目标所需的其它文件或其他目标。之后是构建出该目标所需执行的命令。有一点尤为需要注意：每一个命令（command）之前必须有一个制表符（tab）。这里必须使用制表符而不能是空格，否则 make 会报错。</p><p>我们通过在 Makefile 中书写这些显式规则来告诉 make 工具文件间的依赖关系：如果想要构建 <code>target</code>，那么首先要准备好 <code>dependencies</code>，接着执行 <code>command</code> 中的命令，以得到 <code>target</code>。在书写完恰当的规则之后，只需要在 shell 中输入 <code>make target</code>（<code>target</code> 是目标名），即可执行相应的命令、生成相应的目标。</p><p>因此，我们的简易的 Makefile 可以写成如下的样子，之后执行 <code>make hello</code> 或是 <code>make</code>，即可产生 <code>hello</code> 这个可执行文件，使用 <code>./hello</code> 就可以执行它。值得注意的是，当执行 <code>make</code> 指令而不附加其他参数时，默认构建第一个目标。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">all:</span> hello<br><br><span class="hljs-symbol">hello:</span> hello.c<br>    gcc -o hello hello.c<br></code></pre></td></tr></table></figure><h3 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h3><p>ctags 是一个方便代码阅读的工具，我们用到的功能是代码跳转功能。利用 ctags，我们可以在 Vim 下进行更便捷的开发。</p><p>在使用之前我们需要修改 Vim 的配置文件，使其支持 ctags 的相关功能。打开 <code>~/.vimrc</code> 文件（如果没有则新建），添加下面两行并保存。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">tags</span>=tags<br><span class="hljs-built_in">set</span> autochdir<br></code></pre></td></tr></table></figure><p>我们修改 <code>hello.c</code> 文件，如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ctags_test.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span> p;<br>    p.a = <span class="hljs-number">1</span>;<br>    p.b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建一个文件 <code>ctags_test.h</code>，输入如下内容：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct Pair &#123;<br>    int a<span class="hljs-comment">;</span><br>    int b<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我们保存并退出 Vim，执行命令 <code>ctags -R *</code>，就会发现在该目录下出现了新的文件 <code>tags</code> ——这是 ctags 为我们创建的符号名索引文件。此时我们就能使用 ctags 的功能了。</p><p>使用 Vim 打开 <code>hello.c</code> 文件，将光标移动到 <code>a</code> 或 <code>b</code> 上，按下 Ctrl+]，就可以跳转到结构体中 <code>a</code>或 <code>b</code> 的定义处。再按下 Ctrl+O就可以返回跳转前的位置。</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>对于我们来说，Linux 终端就是我们眼前的黑框框。Linux 是一个优秀的多用户多进程操作系统，用户经常需要同时运行多个程序并同时观察它们的输出。然而我们的终端看起来只能同时显示一个程序，并不能同时观察多个程序的运行。一个简单的解决方案就是同时打开多个终端，让一个用户同时多次登录 Linux 计算机（Linux 允许这样做）。但这样做有时在窗口切换时会产生麻烦。</p><p>另外还有一个问题：当我们的终端和 Linux 计算机断开连接时，终端前台正在运行的进程会被杀死。所以我们在终端中等待程序运行时就需要一直保持着终端的连接，这对于长时间运行程序的服务器来说是不现实的，运维人员不能总是在前台看着程序不断输出。</p><p>为了解决这两个问题，我们引入“终端复用神器” <strong>tmux</strong>（Terminal multiplexer）。它实现了终端窗口和进程分离，同时也可以在窗口中同时显示多个进程的运行。</p><p>窗格、窗口、会话是 tmux 的三个基本概念，一个会话可以包含多个窗口，一个窗口可以分割为多个窗格。突然断开连接或主动分离（Detach）后 tmux 仍会保持程序的运行，通过重新连接会话可以直接在之前的环境继续工作。</p><p>看到了 tmux 的运行效果，我们立刻会问，如何进入 tmux，实现分屏操作呢？</p><p>我们在 Shell 下直接输入命令 <code>tmux</code>，可以看到终端底部出现一行绿色，这时就已经进入了 tmux 的新会话。tmux 的操作由一系列快捷键组成，下面对重要的快捷键进行介绍。</p><ul><li>Ctrl+B Shift+Num 5（同时按下 Ctrl 和 B，然后松开这两个键，紧接着立刻输入“%”，下面同理），将窗口左右分屏。</li><li>Ctrl+B Shift+’ ，将窗口上下分屏。</li><li>重复以上两个快捷键，可以将目前活动的窗格继续分屏。</li><li>Ctrl+B Up &#x2F; Down &#x2F; Left &#x2F; Right 根据按键方向切换到某个窗格。</li><li>Ctrl+B Space，切换窗格布局（上下变成左右，左右变成上下）。</li><li>Ctrl+B X，关闭当前正在使用的窗格（根据提示按 Y 确认关闭）。</li><li>Ctrl+B D，分离（Detach）当前会话，回到 Shell 的终端环境。此时程序仍然保持在 tmux 会话中的状态。</li></ul><p>当我们使用 Ctrl+B D 分离了会话或者意外断开了连接，我们该如何恢复到之前的会话中呢？</p><p>我们首先使用 <code>tmux ls</code> 命令查看当前都有哪些会话。记住会话名（会话名是冒号左边的内容，默认情况下是一个数字），使用 <code>tmux a -t 会话名</code> 恢复到原来的会话。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h3><p>Git 是一个先进的<strong>版本控制系统</strong>。试想一个几百人同时开发一个大项目的场景：有人想在某个版本进行测试，也有人想要在这个版本的基础上进行新功能的开发而不影响测试人员，还有人想进行另外一个功能的开发……在迭代许多版本之后，代码的管理就变得十分复杂了。复杂主要包括两个方面：时间上的复杂（版本不断更新，新功能出现问题需要回退等等）和空间上的复杂（不同人开发不同的部分）。为了解决这些问题，就出现了版本控制系统。</p><h3 id="三种储存位置"><a href="#三种储存位置" class="headerlink" title="三种储存位置"></a>三种储存位置</h3><p>Git 中的三种储存状态分别是：工作区（Working Directory）、暂存区（Staging Area）和储存库（Repository）。</p><p>一般来说，一个项目在 Git 中是以目录的形式存在的，这个目录包含了<strong>工作区</strong>（<code>.git</code> 子目录之外的内容）和<strong>储存库</strong>（<code>.git</code> 子目录）。工作区可以理解为“目前正在编辑的版本”，储存库储存在一个隐藏目录 <code>.git</code> 中（因为它以 <code>.</code> 开头，所以是隐藏的），用来存放提交过的所有版本的内容及其联系。<strong>暂存区</strong>存放了已经确定修改但尚未提交的文件。暂存区的信息理论上也储存在 <code>.git</code> 目录中，但是在用途上和储存库有区别，因此和储存库的概念区分开来。</p><h3 id="四种储存状态"><a href="#四种储存状态" class="headerlink" title="四种储存状态"></a>四种储存状态</h3><p>一个文件，在 Git 目录中有以下四种状态：</p><ul><li>未跟踪（Untracked）：一个文件在储存库的版本信息中没有被记录过。比如在储存库中新建了一个文件，这个文件现在就是未跟踪的状态；在一个非空目录下使用 <code>git init</code> 来初始化一个空储存库，此时这个目录下的所有文件都处于未跟踪的状态。</li><li>未修改（Unmodified）：一个文件在跟踪之后一直没有改动过，或者改动已经被提交（即工作区的内容和储存库中的内容相同），则处于未修改状态。当我们修改这个文件时，则会使这个文件变成已修改状态。</li><li>已修改（Modified）：一个文件已经被修改（即工作区的内容和储存库中的内容不同），但还没有加入（<code>git add</code>) 到暂存区中。</li><li>已暂存（Staged）：一个文件已被加入暂存区。加入暂存区意味着将一个已修改的文件加入下次提交（<code>git commit</code>）需要存入储存库的文件清单中。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a><code>git init</code></h4><p><code>git init</code> 会自动把当前目录变成一个空的 Git 仓库，这样就可以对当前目录下的内容进行版本管理了。</p><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a><code>git clone</code></h4><p><code>git init</code> 创建一个新的储存库，而 <code>git clone &lt;URL&gt;</code> 则是“克隆”一个已有的储存库到当前目录下。通常我们会从一个互联网地址（即 URL，统一资源定位符）进行克隆，所以一般这种操作可以理解为“下载”。</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h4><p>这个命令可以查看当前分支的状态，以及当前工作区的变动和暂存区的内容，便于我们对工作区的概况进行掌握。</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h4><p>使用这个命令，可以把一个新文件或者已经修改过的文件加入暂存区中。在你完成一部分实验内容之后，可以使用 <code>git add .</code> 将你的所有修改加入暂存区，也可以使用 <code>git add &lt;filename&gt;</code> 来将指定的文件加入暂存区。</p><h4 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a><code>git restore</code></h4><p>我们在修改一个文件之后，可能想要放弃这个修改。当这个文件还没有通过 <code>git add</code> 加入暂存区时，我们可以使用 <code>git restore &lt;filename&gt;</code> 来撤销对这个文件的修改，使其退回到上一个 commit 的状态。如果这个文件已经加入了暂存区，我们可以通过 <code>git restore --staged &lt;filename&gt;</code> 来取消暂存。</p><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h4><p>这个命令涉及到分支的知识，分支的概念在这里不会详细介绍，可以参考 <a href="https://git-scm.com/book/zh/v2">Pro Git</a>。在实验课程中，可能会涉及在各个 Lab 中进行切换。这时使用 <code>git checkout lab&lt;x&gt;</code> 可以切换到相应的分支。</p><p>请注意，在切换时，需要保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）。</p><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h4><p>使用 <code>git commit -m &lt;message&gt;</code> 这个命令将暂存区的修改提交到储存库中。当 message 参数有空格时需要把 message 用引号括起来。在提交时，要求给出一段说明性文字。这段文字可以任意填写，但建议按照提交内容填写，以保证多人协作时的可读性。本实验不会涉及多人协作，所以方便自己开发即可。</p><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><code>git push</code></h4><p>这个命令将本地的 commit 推送到一个远程仓库。在课程实验中，这个命令可以将你的 commit 推送到 GitLab。</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><code>git pull</code></h4><p>这个命令将远程新建的分支下载到本地，并且将远端的更改合并到当前的分支。在利用评测机进行实验分支的初始化之后，可以在开发机中使用这个命令来将新的分支下载到本地。</p><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>所谓 Shell 脚本，其实就是一条一条命令组合起来，放到一个文件中，并且可以直接运行这个文件。</p><p>Shell 脚本和 Windows 批处理文件是十分类似的，只不过在 Linux 下，脚本语言编程是用户的必备技能，也是高效操作所必需的技能；而在 Windows 下的批处理脚本则对于普通用户来说可有可无，因为他们只需操作图形界面就可以完成日常生活中的绝大多数操作。</p><h3 id="Shell脚本的执行"><a href="#Shell脚本的执行" class="headerlink" title="Shell脚本的执行"></a>Shell脚本的执行</h3><p>在 Windows 中，批处理文件的扩展名是 <code>.bat</code>，类似地，在 Linux 中，脚本文件的文件名在最后一般会加上 <code>.sh</code> 后缀。实际上 Linux 中没有扩展名的概念，所以加不加 <code>.sh</code> 对运行是没有影响的。但为了区分于其他文件，一般约定脚本文件的文件名都以 <code>.sh</code> 结尾。</p><p>执行 Shell 脚本很容易：<code>./文件名</code>（文件名包含 <code>.sh</code>，因为这是文件名的一部分。再次强调，Linux 中没有扩展名的概念）即可运行。</p><p>需要注意的是，被执行的脚本文件必须有“执行”权限。在 Linux 系统中，每个文件对于拥有者、用户组和其他用户都分别有“读”、“写”、“执行”的权限。我们使用 <code>touch</code> 命令创建的文件默认是没有“执行”权限的，需要手动添加。若发现 Shell 脚本执行时出现了“Permission denied”的错误，多半是因为没有添加“执行”权限。我们可以使用下面的命令手动添加“执行”权限。</p><div class="note note-success">            <p>chmod +x 文件名</p>          </div><p>后文中提到的 Shell 语法均指的是 Bash Shell 语法。</p><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world!"></a>Hello, world!</h4><p>首先用 <code>touch</code> 命令创建一个新文件 <code>hello.sh</code>，使用 Vim 输入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#My first Shell script!</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><p>保存退出，修改权限，运行。我们可以看到终端输出了 <code>Hello, world!</code>。下面对程序进行逐行解释。</p><p>第一行：指定脚本的默认运行程序（即解释器）。在这里指定为 bash，这是我们最常使用的脚本运行程序。</p><blockquote><p>其中，<code>#!</code> 出现在脚本文件的第一行的前两个字符，被称为 Shebang。当文件中存在 Shebang 的情况下，程序加载器会分析 Shebang 后面的内容，并且将这些内容作为脚本文件的解释器。</p></blockquote><p>第二行：注释。注释以 <code>#</code> 开头。</p><p>第三行：输出。将 <code>echo</code> 命令后面的字符串输出。像本章开头所说的，Shell 脚本是命令和组合，其实 <code>echo</code> 也是一个命令。不信你把这一行在终端中直接运行一下，看看发生了什么，也可以使用 <code>man</code> 命令查询一下 <code>echo</code> 命令是做什么的。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>一般的脚本语言都涉及到变量的操作，那么 Shell 脚本中是如何定义和使用变量的呢？</p><p>Shell 是弱类型语言，定义变量时无需指定类型。定义变量（变量名为 <code>var_name</code>，值为 <code>value</code>）的方式是：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">var_name</span>=value<br></code></pre></td></tr></table></figure><p>请注意，等号两边<strong>不允许有空格</strong>。</p><p>使用 <code>$var_name</code> 可以获取变量的值。在使用时，建议在变量名的两端加一个花括号（形如 <code>$&#123;var_name&#125;</code>），以帮助解释器识别变量的边界，避免歧义。</p><p>下面我们用定义和使用变量的形式，重新编写上面的 Hello, world 程序，将 <code>hello.sh</code> 的内容修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>str=&quot;Hello, world!&quot;<br>echo $str<br></code></pre></td></tr></table></figure><p>保存退出，运行，达到了同样的效果。</p><h4 id="脚本参数——特殊的变量"><a href="#脚本参数——特殊的变量" class="headerlink" title="脚本参数——特殊的变量"></a>脚本参数——特殊的变量</h4><p>之前学习命令的时候，我们发现很多命令都需要传入参数和选项。在 Shell 脚本中，传递参数是完全支持的，这也大大提高了 Shell 脚本的通用性和便捷性。下面我们简单讲解如何传递参数。</p><p>参数在 Shell 脚本中体现为特殊的变量。在执行语句中，参数以空格分隔，每一个参数在脚本中都是一个字符串变量。第一个参数映射到变量名 <code>1</code>，第二个参数映射到变量名 <code>2</code>，以此类推……</p><p>我们用一个实例来说明参数的传递。我们将 <code>hello.sh</code> 的内容修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>str=&quot;Hello, $1 and $2!&quot;<br>echo $str<br></code></pre></td></tr></table></figure><p>输入如下命令运行，看看控制台输出了什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./hello.sh world OS</span><br></code></pre></td></tr></table></figure><p>请在双引号中引用变量。如果将上述的双引号改成单引号，则会原文输出引号内的内容，你可以尝试一下。</p><p>需要补充的是，对于传递的参数，不仅有 <code>$1</code>、<code>$2</code> 这样的特殊变量，还提供了其他的特殊变量：</p><ul><li><code>$#</code> 传递的参数个数；</li><li><code>$*</code>一个字符串，内容是传递的全部参数。</li></ul><h4 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h4><p>如果我们想对大批量的文件进行复杂操作，我们一般需要用到条件控制和循环控制。这也是自动化操作的精髓所在。下面我们对 <code>if</code> 和 <code>while</code> 关键字进行简单讲解。</p><p><code>if</code> 语句块的格式如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> condition1<br>then<br>    <span class="hljs-keyword">command</span>11<br>    <span class="hljs-keyword">command</span>12<br>    <span class="hljs-string">......</span><br>elif condition2<br>then<br>    <span class="hljs-keyword">command</span>21<br>    <span class="hljs-keyword">command</span>22<br>    <span class="hljs-string">......</span><br>else<br>    <span class="hljs-keyword">command</span>31<br>    <span class="hljs-keyword">command</span>32<br>    <span class="hljs-string">......</span><br>fi<br></code></pre></td></tr></table></figure><p>其中，<code>fi</code> 是“if”的倒写，代表 <code>if</code> 语句块的结束；<code>elif</code> 意为“else if”。<code>elif</code> 和 <code>else</code> 可以按需省略。下面举例说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>if (( $1 &gt; $2 ))<br>then<br>        echo &quot;first &gt; second&quot;<br>elif (( $1 &lt; $2 ))<br>then<br>        echo &quot;first &lt; second&quot;<br>elif (( $1 == $2 ))<br>then<br>        echo &quot;first == second&quot;<br>else<br>        echo &quot;I don&#x27;t know...&quot;<br>fi<br></code></pre></td></tr></table></figure><p>其中 <code>(())</code> 是用于比较<strong>整数</strong>之间大小的表达方式。传入字符串或浮点数，则是未定义的行为。可以试着传入不同的参数，看看程序输出了什么。</p><p><code>while</code> 语句块的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>    command1<br>    command2<br>    ...<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>其中 <code>done</code> 表示“do”语句块的结束。下面举例说明。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>mkdir files<br>cd files<br>i=1<br>while (($i &lt;= $1))<br>do<br>        touch &quot;file$i.txt&quot;<br>        let i=i+1 # or i=$((i+1))<br>done<br></code></pre></td></tr></table></figure><p>这里，<code>let</code> 是为变量赋值的命令，与之等价地，也可以使用 <code>i=$((i+1))</code>。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>Shell 脚本也支持<strong>函数</strong>。函数的定义方式如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">fun_name</span>() &#123;<br>    body...<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int_value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>function</code> 和 <code>()</code> 可以省略其中一个。其中返回语句是可选的，函数可以不返回值。<code>int_value</code> 是一个[0,255][0,255]之间的整数，返回其他值是未定义的行为，一般会返回一个错误的结果。</p><p>函数的调用方法如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">fun_name</span></span> param1 param2 ... paramN<br></code></pre></td></tr></table></figure><p>其中第 N 个参数在函数体内使用 <code>$N</code> 来获取，且不需要在函数定义开头声明。值得注意的是，当 N&gt;&#x3D;10 时，需要用 <code>$&#123;N&#125;</code> 来获取参数，否则 <code>$</code> 只会带第一位数字。如果函数有返回值，则在函数调用的后面需要使用 <code>$?</code> 获取返回值。下面用一个例子说明函数是如何定义和调用的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>function fun1() &#123;<br>        echo &quot;Hello, world!&quot;<br>&#125;<br>function fun2() &#123;<br>        echo &quot;I&#x27;ve got &quot;$1&quot; and &quot;$2&quot;!&quot;<br>&#125;<br>function fun3() &#123;<br>        echo &quot;I&#x27;m computing first + second!&quot;<br>        return $(($1 + $2))<br>&#125;<br>fun1<br>fun2 2 3<br>fun3 4 5<br>echo &quot;The sum is &quot;$?&quot;.&quot;<br></code></pre></td></tr></table></figure><p>其中，<code>$(($1 + $2))</code> 的意思是先计算 <code>$1 + $2</code> 的值。</p><h3 id="sed——用命令编辑和输出文本"><a href="#sed——用命令编辑和输出文本" class="headerlink" title="sed——用命令编辑和输出文本"></a>sed——用命令编辑和输出文本</h3><p>我们已经初步了解到 Shell 脚本的强大功能。但我们目前对于文本的编辑功能仅仅学习了 Vim 等工具的使用。有人可能会想到，可以通过 Shell 脚本（即一条条的命令）对文本文件的内容进行编辑和输出吗？当然可以！sed 是通过命令编辑和输出文本的工具，通过掌握 <code>sed</code> 命令的使用，我们就可以实现文本内容编辑和选择输出的自动化。</p><div class="note note-success">            <p>sed<br>sed [选项] ‘命令’ 输入文本<br>选项（常用）：<br>-n：安静模式，只显示经过sed处理的内容。否则显示输入文本的所有内容。<br>-i：直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。<br>命令（常用）：<br>&lt;行号&gt;a&lt;内容&gt;： 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一行之后新增。使用$表示最后一行。后面的命令同理。<br>&lt;行号&gt;c&lt;内容&gt;：取代。用内容取代相应行的文本。<br>&lt;行号&gt;i&lt;内容&gt;：插入。在当前行的上面插入一行文本。<br>&lt;行号&gt;d：删除当前行的内容。<br>&lt;行号&gt;p：输出选择的内容。通常与选项-n一起使用。<br>s&#x2F;<re>&#x2F;<string>：将<re>（正则表达式）匹配的内容替换为<string>。</p>          </div><blockquote><p>sed 中正则表达式的相关语法可以查阅 <a href="https://www.gnu.org/software/sed/manual/html_node/Regular-Expressions.html">sed 文档</a>。sed 等工具中的正则表达式语法和 Java 等语言中不完全相同，请注意区分。</p></blockquote><p>不加 <code>-i</code> 选项时，只在控制台显示编辑后的文件内容，而不修改文件本身。下面举几个使用例子，以便更好地理解 <code>sed</code> 命令的使用方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -n &#x27;3p&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出 my.txt 的第三行</span><br>sed &#x27;2d&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 my.txt 文件的第二行</span><br>sed &#x27;2,$d&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 my.txt 文件的第二行到最后一行</span><br>sed &#x27;s/str1/str2/g&#x27; my.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在整行范围内把 str1 替换为 str2。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有 g 标记，则只有每行第一个匹配的 str1 被替换成 str2</span><br>sed -e &#x27;4astr &#x27; -e &#x27;s/str/aaa/&#x27; my.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-e 选项允许在同一行里执行多条命令。例子的第一条是第四行后添加一个 str，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二个命令是将 str 替换为 aaa。命令的执行顺序对结果有影响。</span><br></code></pre></td></tr></table></figure><blockquote><p>除了 <code>sed</code> 命令，还有更强大的 <code>awk</code> 命令，但使用也更加复杂。</p></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>很多命令都有控制台输出。如果想要把这些命令的输出写到文件中，应该怎么办呢？答案是使用重定向。Linux 定义了三种流：</p><ul><li>标准输入：<code>stdin</code>，由 0 表示。</li><li>标准输出：<code>stdout</code>，由 1 表示。</li><li>标准错误：<code>stderr</code>，由 2 表示。</li></ul><p>默认情况下，这些流使用的设备是控制台，也就是我们可以在控制台上看到命令的输出。在命令后使用<code>&gt;</code>符号可以将输出重定向。举个例子：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span> / &gt; lsoutput.txt<br></code></pre></td></tr></table></figure><p>这个命令就是将根目录下的文件名输出到当前目录的 <code>lsoutput.txt</code> 文件中，<strong>覆盖文件的原有内容</strong>，如果想在文件后追加命令的输出，使用 <code>&gt;&gt;</code> 符号而不是<code>&gt;</code>。由于输出被重定向到文件，所以我们在控制台中看不到输出了。这就是输出重定向的基本用法。</p><p>我们在控制台中单独运行 <code>gcc</code> 命令，什么参数也不加。由于没有输入文件，显然编译器是无法正确运行的。所以我们可以看到 gcc 产生了一个 fatal error：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> gcc<br>gcc: fatal error: <span class="hljs-keyword">no</span> input <span class="hljs-keyword">files</span><br>compilation terminated.<br></code></pre></td></tr></table></figure><p>试试看使用命令 <code>gcc &gt; gccerr</code>，看看发生了什么？我们发现控制台仍然输出了错误，而 <code>gccerr</code> 中没有任何内容。似乎重定向不好用了。这是为什么呢？</p><p>实际上，<code>&gt;</code> 是 <code>1&gt;</code> 的简写。在我们刚才提到的三种流中，1 指的是标准输出，而不包括标准错误输出。<code>gcc</code> 输出的编译错误消息属于标准错误输出。如果想要将错误输出到文件，需要使用 <code>2&gt;</code>，也就是将错误输出重定向到文件。试试使用 <code>gcc 2&gt; gccerr</code>，看看是否达到了预期效果。</p><p>同理，我们也可以对输入进行重定向。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道符号<code>|</code>可以对命令进行连接。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">command</span>1 | <span class="hljs-keyword">command</span>2 | <span class="hljs-keyword">command</span>3 | <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>以上内容是将 <code>command1</code> 的输出传给 <code>command2</code> 的输入，<code>command2</code> 的输出传给 <code>command3</code> 的输入，以此类推。</p><p><code>cat</code> 命令将文件内容输出到标准输出，<code>grep</code> 命令支持从标准输入读取文本。所以这两个命令就可以用管道进行连接。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> hello.txt | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令的作用就是将 <code>hello.txt</code> 文件输出，输出的内容传入 <code>grep</code> 命令，<code>grep</code> 命令在这些内容中查找 <code>Hello</code> 字符串。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道“原地”哈希题</title>
    <link href="/2024/02/17/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/"/>
    <url>/2024/02/17/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="两道“原地”哈希题"><a href="#两道“原地”哈希题" class="headerlink" title="两道“原地”哈希题"></a>两道“原地”哈希题</h1><h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h2><p>题目链接：<a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由题目可知数组 nums 中的 n 个数都在 [1, n] 的范围内，因为是数字的个数和位置个数应该一一对应如果有数字出现了两次，就意味着 [1,n] 中有数字没有出现过。</p><p>解题突破口就是，将每一个数放在对应的位置。如果位置和值不相等，就是出现两次的数。</p><p>由于数组的下标范围是 [0, n-1]，我们需要将数 i 放在数组中下标为 i-1 的位置。如果 nums[i] 恰好出现了一次，那么将 nums[i] 放在数组中下标为 nums[i]−1 的位置即可； 如果 nums[i] 出现了两次，那么我们希望其中的一个 nums[i] 放在数组下标中为 nums[i]−1 的位置，另一个 nums[i] 放置在任意「不冲突」的位置 x。</p><p><img src="https://pic.imgdb.cn/item/65d05b919f345e8d03533744.jpg"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>遍历数组；<ul><li>当遍历到位置 i 时，看 nums[i] 和 nums[i]−1，是否相同；</li><li>如果相同这开始从下一个数字开始比较；</li><li>如果不同则应该把 nums[i]−1 放在对应的位置上，因此我们交换 num[i] 和 nums[nums[i]−1] 即可，直到待交换的两个元素相等为止；</li></ul></li><li>遍历数组，找到数组中下标和值不一样的数字就是 重复出现两次的数 加入到resul 中即可；</li><li>返回结果 result。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-comment">/* 原地啊交换数组 */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>            <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i] - <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">/* 找到数组中下标和值不一样的数字就是 重复出现两次的数 */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span> != i) result.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>题目链接：<a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针的一个应用</title>
    <link href="/2024/01/30/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2024/01/30/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode上的一个双指针题的解法与简化"><a href="#Leetcode上的一个双指针题的解法与简化" class="headerlink" title="Leetcode上的一个双指针题的解法与简化"></a>Leetcode上的一个双指针题的解法与简化</h1><h2 id="题目：80-删除有序数组中的重复项-II"><a href="#题目：80-删除有序数组中的重复项-II" class="headerlink" title="题目：80. 删除有序数组中的重复项 II"></a>题目：80. 删除有序数组中的重复项 II</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/</a></p><p>给你一个有序数组<code>nums</code>，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong>，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>读完题目之后，我们应该注意到：nums数组是有序的！这意味着：相同元素必然连续。</p><p>我们可以设置快慢两个指针：<code>fast</code>和<code>slow</code>，运用for循环进行遍历，判断哪些元素应该保留，哪些应该剔除。</p><p>具体而言，<code>slow</code>指针表示处理出的数组的长度，fast指针表示已经检查过的数组的长度。即<code>nums[fast]</code>表示待检查的第一个元素，<code>nums[slow − 1]</code>为上一个应该被保留的元素所移动到的指定位置。</p><p>因为本题要求相同元素最多出现两次，所以我们需要检查上上个应该被保留的元素<code>nums[slow − 2]</code>是否和当前待检查元素<code>nums[fast]</code>相同。当且仅当<code>nums[slow − 2] == nums[fast]</code>时，当前待检查元素<code>nums[fast]</code>不应该被保留（因为此时必然有<code>nums[slow − 2] == nums[slow − 1] == nums[fast]</code>）。</p><p>最后，slow即为处理好的数组的长度。</p><p>特别地，数组的前两个数必然可以被保留，因此对于长度不超过2的数组，我们无需进行任何处理，对于长度超过2的数组，我们直接将双指针的初始值设为2即可。</p><p>于是便有了这样的解答：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 特殊判断，如果nums长度小于2，直接输出长度n即可</span><br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">2</span>, fast = <span class="hljs-number">2</span>; <span class="hljs-comment">// 因为上面已经做过特殊判别，所以这里快慢指针从2开始</span><br>        <span class="hljs-keyword">while</span> (fast &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[slow - <span class="hljs-number">2</span>] != nums[fast]) &#123; <span class="hljs-comment">// 因为题目要求最多两个数相同，所以这么判断</span><br>            <span class="hljs-comment">// 如果nums[slow - 2] == nums[fast]，代表已经有两个数相等，此时nums[fast]</span><br>            <span class="hljs-comment">// 对应的数值不能放进结果之中。反之，如果nums[slow - 2] != nums[fast]，</span><br>            <span class="hljs-comment">// 那么nums[fast]可以放进nums[slow]中，并且slow++，记录结果的长度。</span><br>                nums[slow] = nums[fast]; <br>                slow++;<br>            &#125;<br>            fast++; <span class="hljs-comment">// 不管怎么样，快指针都是要向前遍历各个元素的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> slow; <span class="hljs-comment">// 返回结果的长度，即slow</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>基于上面显式的双指针法，我们可以进一步抽象简化。</p><p>首先应该考虑，我们使用双指针的目的是什么？其实是方便指向我们要使用的数字。所以指针对应的数值才是主角。</p><p>在下面的题解中，我们应该尽量少使用指针，让数值自己出来比较：</p><p>联想到C++的for循环语法：<code>for (int num : nums)</code>，可以让num自身当右指针；</p><p>可以再令一个i代表左指针。</p><p>结合上面的思想，我们可以得到下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123; <span class="hljs-comment">// num当右指针</span><br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">2</span> || nums[i - <span class="hljs-number">2</span>] &lt; num) &#123; <span class="hljs-comment">// i &lt; 2是特殊判断，nums[i - 2] &lt; num</span><br>            <span class="hljs-comment">// 是因为题目要求相同元素不能超过两个。之所以可以用小于号判断，是因为数组是有序的</span><br>                nums[i] = num; <span class="hljs-comment">// 相当于上面官方解法的nums[slow] = nums[fast];</span><br>                i++; <span class="hljs-comment">// 相当于上面官方解法的slow++;，即左指针移动</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 输出长度，即相当于上面题解的slow</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果每个元素最多出现K次，你要怎么修改上面的代码？</p><p>很简单，改成<code>if (i &lt; k || nums[i - k] &lt; num)</code>就好了！</p><p>（这能不能看作这类问题的通解呢？）</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尺取法及应用 - POJ 3061</title>
    <link href="/2024/01/29/%E5%B0%BA%E5%8F%96%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20-%20POJ3061/"/>
    <url>/2024/01/29/%E5%B0%BA%E5%8F%96%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20-%20POJ3061/</url>
    
    <content type="html"><![CDATA[<h1 id="尺取法及其应用-POJ-3061"><a href="#尺取法及其应用-POJ-3061" class="headerlink" title="尺取法及其应用 - POJ 3061"></a>尺取法及其应用 - POJ 3061</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>返回推进区间的开头和结尾，求满足条件的最小区间的方法称为尺取法。</strong>，顾名思义，就是像一把尺子（固定某一条件），不断向右（左）移动，不断更新所求答案。一般用来求满足条件的最小区间。</p><p>主要实现方法为：</p><ol><li>初始化左右端点</li><li>不断扩大右端点，直至满足条件</li><li>如果直至终点也无法满足条件，则终止，否则更新结果</li><li>扩大左端点（右移1），跳回步骤2</li></ol><p>这种方法只有一个疑问点，就是R不往回移动，其结果一定是对的吗？</p><p>考虑一下，L一直向右移动，R其实没必要向左动了。R只有在不满足条件的时候才向右，否则停在原位。</p><p>此时凭L的移动，已经能找出所有可行的区间了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例题链接：<a href="http://poj.org/problem?id=3061">http://poj.org/problem?id=3061</a></p><p>找到最短的序列长度，使得序列元素和大于S。</p><p>在这道题中，序列都是正数，如果一个区间其和大于等于S，那么不需要在向后推进右端点了，因为其和也肯定大于等于S但长度更长。</p><p>所以，<strong>当区间和小于S时右端点向右移动，和大于等于S时，左端点向右移动以进一步找到最短的区间</strong>。</p><p>如果右端点移动到区间末尾其和还不大于等于S，结束区间的枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> t,n,s;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-comment">//加速流</span><br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        cin&gt;&gt;n&gt;&gt;s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            cin&gt;&gt;a[i];<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>,ans=n+<span class="hljs-number">1</span>;   <span class="hljs-comment">//l，r:左右端点  ans初始值设为n+1</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(r&lt;n&amp;&amp;sum&lt;s)<br>                sum+=a[r++];<br>            <span class="hljs-keyword">if</span>(sum&lt;s)         <span class="hljs-comment">//如果所有数的和都小于s，直接跳出循环</span><br>                <span class="hljs-keyword">break</span>;<br>            ans=<span class="hljs-built_in">min</span>(ans,r-l); <span class="hljs-comment">//此时r一定小于n</span><br>            sum-=a[l++];      <span class="hljs-comment">//去掉最左端点，继续前进</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans==n+<span class="hljs-number">1</span>)<br>            cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>网上说还可以结合前缀和来思考解法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章 超标量处理器概览</title>
    <link href="/2024/01/16/%E7%AC%AC1%E7%AB%A0%20%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%A7%88/"/>
    <url>/2024/01/16/%E7%AC%AC1%E7%AB%A0%20%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-超标量处理器概览"><a href="#第1章-超标量处理器概览" class="headerlink" title="第1章 超标量处理器概览"></a>第1章 超标量处理器概览</h1><h2 id="1-1-为什么需要超标量"><a href="#1-1-为什么需要超标量" class="headerlink" title="1.1 为什么需要超标量"></a>1.1 为什么需要超标量</h2><p>程序执行时间  &#x3D;  $Instructions * CPI * f$。其中:$Instructions$指的是指令个数，$CPI$(Cycles  per  Instrution)指的是执行每条指令所需的周期数，$f$指的是每周期所需要的时间，亦即时钟频率。</p><h3 id="加快处理器执行程序的速度"><a href="#加快处理器执行程序的速度" class="headerlink" title="加快处理器执行程序的速度"></a>加快处理器执行程序的速度</h3><p>可以考虑以下三点：</p><ul><li><p>减少程序中指令的数量。指令的数量对已经编写好的固定程序是定值。</p></li><li><p>减少CPI，即增大IPC（Instructions per Cycle，每周期执行指令的个数）。</p><p>普通流水线处理器的IPC最大为1。要想每周期执行多于一条指令，就需要使用超标量（Superscalar）处理器。</p><p>处理器采用何种架构进行实现也成为微结构（Microarchitecture）。</p></li><li><p>减少周期时间（cycle time），即加大频率。</p><ul><li>精巧的电路设计，更深的流水线</li><li>优秀的EDA工具</li><li>硅工艺</li></ul></li></ul><p>实际中IPC与运行频率是互相制约的。</p><p>超长指令字（Very Long Instruction Word，VLIW）也是一种每周期可以执行多条指令的处理器架构。</p><ul><li>超标量处理器依靠硬件自身决定哪些指令可被并行地执行，VLIW处理器依靠编译器和程序员自身来决定。</li><li>VLIW在硬件实现上简单，在功能专一的专用处理器领域得到应用，如DSP。</li></ul><h3 id="处理器设计需要折中（tradeoff）"><a href="#处理器设计需要折中（tradeoff）" class="headerlink" title="处理器设计需要折中（tradeoff）"></a>处理器设计需要折中（tradeoff）</h3><ul><li>分支预测<ul><li>精确的分支预测算法需要复杂的硬件资源，无法在一个周期内完成</li><li>分支预测无法在一个周期内完成，那么处理器就不能连续地取指令，造成性能下降</li></ul></li><li>load&#x2F;store指令<ul><li>完全乱序执行可获得较大的IPC。</li><li>相关性检查变得复杂，需要更复杂的恢复机制。</li></ul></li><li>Checkpoint的个数与硬件的面积</li><li>发射队列（issue queue）的个数与仲裁（select）电路的复杂度</li><li>每周期可同时执行的指令个数（issue width）和寄存器堆（register file）的端口个数</li></ul><p>超标量处理器设计没有一个确定的设计原则，需要根据应用领域和场合确定设计的思路。</p><h2 id="1-2-普通处理器的流水线"><a href="#1-2-普通处理器的流水线" class="headerlink" title="1.2 普通处理器的流水线"></a>1.2 普通处理器的流水线</h2><h3 id="1-2-1-流水线概述"><a href="#1-2-1-流水线概述" class="headerlink" title="1.2.1 流水线概述"></a>1.2.1 流水线概述</h3><blockquote><p> 这里假设处理器的性能与处理器的频率直接相关。</p><p>在现实中，频率并不是决定处理器性能的唯一因素。</p></blockquote><p>当处理器没有使用流水线时，周期时间为D，消耗的硬件面积为G。</p><p>对于一个 $n$ 级流水线，周期时间变为 $\frac{D}{n} + S$，其中S表示流水线寄存器的延迟；消耗的硬件面积为 $G + n * L$，其中L为每个流水线寄存器及其附属的控制逻辑所消耗的硬件面积。</p><p> $n$ 级流水线处理器的性能（Performance） &#x3D; $\frac{1}{\frac{D}{n}+S}$；总共消耗的硬件面积（Cost） &#x3D;  $G + n * L$。</p><p>获得同样的性能，消耗的硬件面积越小越好，用公式表示为：</p><p>$$<br>\frac{Cost}{Performance} &#x3D; \frac{G + n * L}{\frac{1}{\frac{D}{n}+S}} &#x3D; \frac{GD}{n} + nSL + LD + GS<br>$$<br>对上式求导可得到函数的极值点，由此可以得到最优化的流水线级数n。</p><p>现实设计中根据实际需求得到理想的流水级级数。</p><h3 id="1-2-2-流水线的划分"><a href="#1-2-2-流水线的划分" class="headerlink" title="1.2.2 流水线的划分"></a>1.2.2 流水线的划分</h3><ol><li><p>每个阶段所需要的时间近似相等</p><p>最长的流水段所需要的时间决定了整个处理器的周期时间</p></li><li><p>每个阶段的操作都会被重复地执行</p></li><li><p>每个阶段的操作都和其他的流水段相互独立、互不相干</p><p>最难满足，也是影响执行效率的关键因素</p></li></ol><p>不同的指令集，流水线实现的难易程度是不同的。</p><p>对于一般的精简指令集（RISC）来说，如MIPS和ARM，由于指令的长度相等，并且每条指令所完成的任务比较规整，所以容易用流水线来实现。</p><p>经典RISC处理器的流水线如下图。</p><p><img src="https://pic.imgdb.cn/item/65a936b8871b83018a804e8d.png"></p><p>该MIPS处理器的设计在大二的计组实验中已经学习。</p><p>但是，每个流水段所需要的时间相差很多，因此需要对各个流水段进行平衡。</p><h4 id="合：将两个或多个流水段合并成一个流水段"><a href="#合：将两个或多个流水段合并成一个流水段" class="headerlink" title="合：将两个或多个流水段合并成一个流水段"></a>合：将两个或多个流水段合并成一个流水段</h4><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a807070.png"></p><p>适用于对性能要求不高的低功耗嵌入式处理器。每个流水段所耗费的时间均衡，但整体的运行频率下降。</p><h4 id="拆：将一个流水段拆成更小的阶段"><a href="#拆：将一个流水段拆成更小的阶段" class="headerlink" title="拆：将一个流水段拆成更小的阶段"></a>拆：将一个流水段拆成更小的阶段</h4><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a8071cc.png"></p><p>可以获得比较高的主频，适合高性能处理器。</p><ul><li>导致硬件消耗的增大</li><li>寄存器堆的端口数要随之增加，以支持多个流水段同时读写</li><li>存储器（如D-Cache）的端口数量要随之增加</li><li>处理器的功耗随之增大</li><li>神流水线导致预测失败时的惩罚（mis-prediction penalty）增大</li></ul><p>一定范围内增加处理器的流水线深度可以提高性能。</p><h3 id="1-2-3-指令间的相关性"><a href="#1-2-3-指令间的相关性" class="headerlink" title="1.2.3 指令间的相关性"></a>1.2.3 指令间的相关性</h3><h4 id="先写后读（RAW）"><a href="#先写后读（RAW）" class="headerlink" title="先写后读（RAW）"></a>先写后读（RAW）</h4><p>Read After Write，也称true dependence，这种相关性是无法回避的。<br>$$<br>A: R_1 &#x3D; R_2 + R_3\<br>B: R_5 &#x3D; R_1 + R_4<br>$$<br>B的操作数$R_1$来自A的结果，所以要等待A将结果计算出来，B才能继续运行。</p><h4 id="先读后写（WAR）"><a href="#先读后写（WAR）" class="headerlink" title="先读后写（WAR）"></a>先读后写（WAR）</h4><p>也称anti-dependence。<br>$$<br>A: R_1 &#x3D; R_2 + R_3\<br>B: R_2 &#x3D; R_5 + R_4<br>$$<br>A读取$R_2$之前，B不能把结果写入到$R_2$。</p><p>这种相关性是可以避免的，只需要B将的结果写入到其他寄存器。</p><h4 id="先写后写（WAW）"><a href="#先写后写（WAW）" class="headerlink" title="先写后写（WAW）"></a>先写后写（WAW）</h4><p>也称output dependence。<br>$$<br>A: R_1 &#x3D; R_2 + R_3\<br>B: R_1 &#x3D; R_5 + R_4<br>$$<br>这种相关性是可以避免的，只需要B将结果写入到其他寄存器。</p><h4 id="控制相关性"><a href="#控制相关性" class="headerlink" title="控制相关性"></a>控制相关性</h4><p>由分支指令引起。只有当分支指令的结果被计算出来的时候，才可以知道从哪里获得后续的指令来执行。</p><p>分支指令需要一段时间才能获得结果，在这段时间内只能按照预测的方式来取指令。</p><h4 id="存储器地址的相关性"><a href="#存储器地址的相关性" class="headerlink" title="存储器地址的相关性"></a>存储器地址的相关性</h4><p>RAW，WAR，WAW三个相关性不仅对寄存器之间的关系适用，对于存储器地址之间的关系也同样适用。</p><p>如<code>sw r1, 0(r5)</code>和<code>lw r2, 0(r6)</code>两条指令，当r5与r6的值相等时，这两条指令存在RAW的相关性。</p><p>这种类型的相关性需要将load&#x2F;store指令所携带的地址计算出来才可以判别。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>指令之间的各种相关性，使得他们在处理器中无法完全地乱序执行。</p><p>对于普通的处理器来说，WAW和WAR并不会引起问题，RAW可以通过旁路（bypass）的方式来解决。</p><p>对于超标量处理器来说，三种相关性都会阻碍指令的乱序执行，都需要在处理器中进行特殊的处理。</p><h2 id="1-3-超标量处理器的流水线"><a href="#1-3-超标量处理器的流水线" class="headerlink" title="1.3 超标量处理器的流水线"></a>1.3 超标量处理器的流水线</h2><p>超标量处理器的执行方式：顺序执行（in-order）和乱序执行（out-of-order）。</p><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a8072c3.png"></p><ul><li><p>Frontend：流水线的取指令（Fetch）和解码（Decode）阶段，很难实现（也没有意义）乱序执行。</p></li><li><p>Issue：将指令送到对应的功能单元（Function Unit，FU）中执行</p><p>这里可以实现乱序执行，只要指令的源操作数准备好了，就可以将其先于其他指令运行。</p></li><li><p>Write back：将指令的结果写到目的寄存器中。</p><p>在处理器内部适用寄存器重命名，将指令集中定义的逻辑寄存器（Architecture Register File，ARF）动态地转化为芯片内部实际使用的物理寄存器（Physical Register File，PRF），从而实现乱序地写回寄存器。</p></li><li><p>Commit：一条指令被允许更改处理器的状态（Architecture state，如D-Cache等）</p><p>为了保证程序按照原来的意图执行，并且实现精确的异常，这个阶段需要顺序执行，才能够保证从处理器外部看起来，程序是串行执行的。</p></li></ul><h3 id="1-3-1-顺序执行"><a href="#1-3-1-顺序执行" class="headerlink" title="1.3.1 顺序执行"></a>1.3.1 顺序执行</h3><p><img src="https://pic.imgdb.cn/item/65a936c0871b83018a807407.png"></p><p>若每周期可从I-Cache中取出两条指令来执行，则称为2-way的超标量处理器。</p><p>发射（Issue）：指令解码之后，读取寄存器而得到操作数，根据自身的类型，将指令送到对应的FU中执行。</p><p>所有FU要经过同样周期数的流水线，保证流水线的写回（Write back）阶段是顺序执行的。</p><h4 id="Scoreboard"><a href="#Scoreboard" class="headerlink" title="Scoreboard"></a>Scoreboard</h4><p>Scoreboard记录流水线中每条指令的执行情况。典型情况下需要记录的信息如下。</p><p><img src="https://pic.imgdb.cn/item/65a936bf871b83018a806f71.png"></p><ul><li>P：Pending，指令的结果还没有写回到逻辑寄存器中。</li><li>F：一条指令在哪个FU中执行，在将指令结果进行旁路的时候会使用这个信息。</li><li>Result Position：记录一条指令到达FU中流水线的哪个阶段，3表示到达FU流水线的第一个流水段，1表示到达FU流水线的最后一个阶段，0表示到达写回阶段。</li></ul><p>程序在顺序执行的超标量流水线中的执行情况如下图所示。</p><p><img src="https://pic.imgdb.cn/item/65a93779871b83018a83fb42.png"></p><p>很多指令在流水线都会由于前面指令的阻塞而不能够继续执行。例如上图的指令F，它与前面的指令都是不相关的，但是这条指令只有等到前面所有的指令都已经发射了，它才可以送到FU中执行，这样就降低了处理器的性能。</p><p>在所有的处理器中，RAW相关性都是不能绕开的。</p><p>但是对于WAW和WAR，由于顺序执行的处理器只有一个统一的写回阶段，而且这个阶段位于流水线的最后一级，所以这两种相关性都不会对流水线产生影响。</p><h3 id="1-3-2-乱序执行"><a href="#1-3-2-乱序执行" class="headerlink" title="1.3.2 乱序执行"></a>1.3.2 乱序执行</h3><p>一旦某条指令的操作数准备好了，就可以将其送入FU中执行。</p><p><img src="https://pic.imgdb.cn/item/65a93779871b83018a83fde8.png"></p><p>为了在乱序执行时解决WAW和WAR这两种相关性，需要对寄存器进行重命名（register renaming），可以在解码（Decode）阶段完成，也可以单独使用一个流水段来完成。</p><p>处理器中需要增加物理寄存器堆（Physical Register File，PRF）配合对指令集中定义的寄存器（Architecture Register File，ARF）进行重命名，PRF中寄存器的数量要多于ARF。</p><p>指令在发射阶段被储存在一个缓存中，这个缓存称为发射队列（Issue Queue，IQ）。一旦操作数准备好了，就可以从发射队列中离开，送到对应的FU中执行。</p><p>发射阶段是流水线从顺序执行到乱序执行的分界点。</p><p>由于每个FU执行周期数都不相同，所以指令在写回阶段是乱序的。一条指令只要计算完毕，就会把结果写到PRF中。</p><p>分支预测失败（mis-prediction）和异常（exception）的存在使得PRF的结果未必都会写到ARF中，因此也将PRF称为Future File。</p><h4 id="重排序缓存和提交阶段"><a href="#重排序缓存和提交阶段" class="headerlink" title="重排序缓存和提交阶段"></a>重排序缓存和提交阶段</h4><p>为了保证程序的串行结果，指令需要按照程序中规定的顺序更新处理器的状态，需要使用重排序缓存（ROB）的部件来配合。使用ROB来实现程序对处理器状态的顺序更新，这个阶段称为提交（Commit）阶段。</p><p>一条指令在这个阶段会将它的结果从PRF搬移到ARF中，同时重排序缓存也会配合完成对异常的处理。</p><h4 id="退休"><a href="#退休" class="headerlink" title="退休"></a>退休</h4><p>如果不存在异常，那么指令就可以顺利地离开流水线，并对处理器的状态进行更改，此时称这条指令退休（retire）了。</p><p>一条指令一旦退休，就不可能回到之前的状态了。一条指令在退休之前，都可以从流水线中被清除。</p><h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>如果在写回阶段就将store指令的结果写到存储器中，那么一旦由于分支预测失败或是异常等原因，需要将这条store指令从流水线中抹掉时，就没有办法恢复存储器的状态。</p><p>使用一个缓存（Store Buffer，SB）来存储store指令没有退休以前的结果。store指令在写回阶段会将他的结果写到SB中，只有一条store指令真正retire之后，才可以把它的值从SB写到存储器中。</p><p>load指令除了从D-Cache中寻找数据，还需要从Store Buffer中进行查找。</p><p>程序在乱序执行的超标量流水线中的执行情况如下图所示。</p><p><img src="https://pic.imgdb.cn/item/65a93779871b83018a83fa52.png"></p><p>i表示发射阶段；解码和寄存器重命名位于同一个流水段；r表示计算完成，在ROB中等待retire；C表示一条指令经过了提交阶段，离开流水线而退休了，这个过程是按照程序中规定的顺序（in-order）执行的。</p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P7 - 流水线CPU设计文档</title>
    <link href="/2023/12/06/P7%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/12/06/P7%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P7-流水线CPU设计文档"><a href="#P7-流水线CPU设计文档" class="headerlink" title="P7 流水线CPU设计文档"></a>P7 流水线CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li><p>设计的处理器为32位五级流水线处理器</p></li><li><p>处理器支持的指令集为</p><blockquote><p>add, sub, and, or, slt, sltu, lui<br>addi, andi, ori<br>lb, lh, lw, sb, sh, sw<br>mult, multu, div, divu, mfhi, mflo, mthi, mtlo<br>beq, bne, jal, jr,</p><p><strong>mfc0,</strong> <strong>mtc0,</strong> <strong>eret,</strong> <strong>syscall</strong></p></blockquote></li><li><p>在 P6 基础上新增了 <code>mfc0, mtc0, eret, syscall</code> 四条新指令</p></li><li><p><code>eret</code> 具有跳转的功能但是没有延迟槽，保证 <code>eret</code> 的后续指令不被执行</p></li><li><p><code>syscall</code> 指令行为与 MARS 不同，无需实现特定的输入输出功能，只需直接产生异常并进入内核态</p></li></ul><p>CPU整体架构参考了《数字设计与计算机体系结构》图7-58。</p><p><img src="https://pic.imgdb.cn/item/654cc27dc458853aef789452.png" alt="整体架构"></p><p>mips微系统的架构图如下图所示：</p><p><img src="https://pic.imgdb.cn/item/655dfd95c458853aef0dbd97.png"></p><h2 id="F级：取指令（Fetch）"><a href="#F级：取指令（Fetch）" class="headerlink" title="F级：取指令（Fetch）"></a>F级：取指令（Fetch）</h2><p>本级的输入为来自D级的<code>next_pc</code>，用于更新下一个PC的值。</p><p>本级的输出为<code>F_PC</code>和<code>F_Instr</code>，分别对应从F级指令的PC和F级指令的内容，均需要参与流水。</p><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><p>只负责PC的存储与更新，F_instr来自<code>mips_txt.v</code>的交互。</p><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>PC写使能信号，高电平有效</td></tr><tr><td>next_pc[31:0]</td><td>I</td><td>待更新的指令地址</td></tr><tr><td>pc[31:0]</td><td>O</td><td>当前指令地址</td></tr></tbody></table><h4 id="与mips-txt-v交互"><a href="#与mips-txt-v交互" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog">ifu F_IFU(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.enable</span>(IFU_WE),<br>    <span class="hljs-variable">.next_pc</span>(next_PC),<br>    <span class="hljs-variable">.pc</span>(F_PC)<br>);<br><br><span class="hljs-keyword">assign</span> F_Instr = i_inst_rdata;<br><span class="hljs-keyword">assign</span> i_inst_addr = F_PC;<br></code></pre></td></tr></table></figure><h3 id="F-D级流水线寄存器"><a href="#F-D级流水线寄存器" class="headerlink" title="F&#x2F;D级流水线寄存器"></a>F&#x2F;D级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>F_pc[31:0]</td><td>I</td><td>F级PC</td></tr><tr><td>F_instr[31:0]</td><td>I</td><td>时钟信号</td></tr><tr><td>D_pc[31:0]</td><td>O</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>O</td><td>32位的指令值</td></tr></tbody></table><h2 id="D级：译码（Decode）"><a href="#D级：译码（Decode）" class="headerlink" title="D级：译码（Decode）"></a>D级：译码（Decode）</h2><p>本级的输入为来自F级的<code>F_PC</code>和<code>F_Instr</code>。</p><p>本级的输出为<code>D_gpr_rs</code>, <code>D_gpr_rt</code>, <code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>和<code>next_pc</code>。</p><p>本级涉及到来自E级、M级、W级的转发，其中来自W级的转发通过<strong>GRF内部转发</strong>的方式实现。</p><p><code>$rs</code>和<code>$rt</code>的值在本级转发成<code>D_fwd_gprrs</code>和<code>D_fwd_gprrt</code>，和<code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>参与流水。</p><p>本级需要对<strong>此级指令</strong>的$$Tuse$$和此时<strong>E级</strong>指令与<strong>M级指令</strong>的$Tnew$进行比较，从而确定是否执行阻塞。</p><blockquote><p>$Tuse$和$Tnew$:</p><ul><li><p>$Tuse$表示这条指令位于D级的时候，再经过多少个时钟周期就必须要使用相应的数据。</p><ul><li>每个指令的$Tuse$是固定不变的</li><li>一个指令可以有两个$Tuse$值</li></ul></li><li><p>$Tnew$表示位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。</p><ul><li>$Tnew$是一个动态值，每个指令处于流水线不同阶段有不同的$Tnew$值</li><li>一个指令在一个时刻至多有一个$Tnew$值（一个指令至多写一个寄存器）</li></ul></li><li><p>当$Tuse$ &gt;&#x3D; $Tnew$，说明需要的数据可以及时算出，可以通过<strong>转发</strong>来解决</p><p>当$Tuse$ &lt; $Tnew$，说明需要的数据不能及时算出，必须<strong>阻塞</strong>流水线解决</p></li></ul></blockquote><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><blockquote><ul><li>如果不需要写寄存器，只需要把A3Sel设为0即可。</li><li>此处<strong>WPC</strong>和<strong>WD</strong>均来自<strong>W级</strong>。</li></ul></blockquote><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa8</td><td>WD为<strong>当前流水线层级的PC</strong> + 8</td></tr></tbody></table><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_pc[31:0]</td><td>I</td><td>当前F级PC的值</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>当前D级PC的值</td></tr><tr><td>PCSel[1:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>branch</td><td>I</td><td>branch类型指令<strong>是否达到跳转条件</strong>，高电平有效</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即D_Instr[25:0]</td></tr><tr><td>offset[15:0]</td><td>I</td><td>branch类型指令的偏移量，即D_Instr[15:0]</td></tr><tr><td>ra[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器保存的地址值</td></tr><tr><td>next_pc[31:0]</td><td>O</td><td>下一指令的PC</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- GPR[rs]</td></tr></tbody></table><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>gpr_rs[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器中的值</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rt</code>寄存器中的值</td></tr><tr><td>CMPOp[1:0]</td><td>I</td><td>指定比较数据的方式</td></tr><tr><td>flag</td><td>O</td><td>是否满足所设条件，高电平有效</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>CMPOp</th><th>操作</th></tr></thead><tbody><tr><td>CMP_beq</td><td>beq指令: 若<code>GPR[rs] == GPR[rt]</code>，则flag置1，否则置0</td></tr></tbody></table><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="D-E级流水线寄存器"><a href="#D-E级流水线寄存器" class="headerlink" title="D&#x2F;E级流水线寄存器"></a>D&#x2F;E级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>D_extres[31:0]</td><td>I</td><td>16位立即数扩展的结果</td></tr><tr><td>D_gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>D_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>E_pc[31:0]</td><td>O</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>E_gpr_rs[31:0]</td><td>O</td><td>GPR[rs]</td></tr><tr><td>E_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="E级：执行（Execute）"><a href="#E级：执行（Execute）" class="headerlink" title="E级：执行（Execute）"></a>E级：执行（Execute）</h2><p>本级的输入为<code>D_PC</code>, <code>D_Instr</code>, <code>D_extres</code>, <code>D_gpr_rs</code>, <code>D_gpr_rt</code>。</p><p>本级的输出为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>, <code>E_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>D_fwd_gprrt</code>，和<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>参与流水。</p><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><p>详见<code>def.v</code>文件中的定义。</p><h3 id="E-MDU（乘除槽）"><a href="#E-MDU（乘除槽）" class="headerlink" title="E_MDU（乘除槽）"></a>E_MDU（乘除槽）</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>MDUOp[2:0]</td><td>I</td><td>指定乘除槽进行的操作</td></tr><tr><td>gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>start</td><td>I</td><td>指定乘除槽是否开始计算，高电平有效</td></tr><tr><td>busy</td><td>O</td><td>乘除槽是否处于运算过程中</td></tr><tr><td>HI[31:0]</td><td>O</td><td>32位HI寄存器值结果</td></tr><tr><td>LO[31:0]</td><td>O</td><td>32位LO寄存器值结果</td></tr></tbody></table><h4 id="控制信号-5"><a href="#控制信号-5" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>MDUOp</th><th>功能</th></tr></thead><tbody><tr><td><code>MDU_mult</code></td><td>乘法运算</td></tr><tr><td><code>MDU_div</code></td><td>除法运算</td></tr><tr><td><code>MDU_multu</code></td><td>无符号乘法运算</td></tr><tr><td><code>MDU_divu</code></td><td>无符号除法运算</td></tr><tr><td><code>MDU_mfhi</code></td><td><code>mfhi</code>指令</td></tr><tr><td><code>MDU_mflo</code></td><td><code>mflo</code>指令</td></tr><tr><td><code>MDU_mthi</code></td><td><code>mthi</code>指令，把<code>gpr_rs</code>的值赋给HI寄存器中</td></tr><tr><td><code>MDU_mtlo</code></td><td><code>mtlo</code>指令，把<code>gpr_rs</code>的值赋给LO寄存器中</td></tr></tbody></table><h3 id="E-M级流水线寄存器"><a href="#E-M级流水线寄存器" class="headerlink" title="E&#x2F;M级流水线寄存器"></a>E&#x2F;M级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>E_pc[31:0]</td><td>I</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>E_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>E_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>M_pc[31:0]</td><td>O</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>M_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="M级：存储器（Memory）"><a href="#M级：存储器（Memory）" class="headerlink" title="M级：存储器（Memory）"></a>M级：存储器（Memory）</h2><p>本级的输入为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>。</p><p>本级的输出为<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>, <code>M_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>M_fwd_gprrt</code>。</p><p>本机参与流水的有<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>。</p><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><p>本次实验只需要调用调用<code>mips_txt.v</code>中的接口即可，无需自行实现DM。</p><p>使用<code>fromRAM</code>模块处理DM返回的数据，使其符合写入寄存器的要求。</p><p>使用<code>toRAM</code>模块处理写入DM的数据，支持按照字、半字、字节的模式储存进DM。</p><h4 id="M-fromRAM"><a href="#M-fromRAM" class="headerlink" title="M_fromRAM"></a>M_fromRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行写操作的地址</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>m_data_rdata[31:0]</td><td>I</td><td>从<code>mips_txt.v</code>中的DM读出的数据</td></tr><tr><td>RD</td><td>O</td><td>处理后的正确的读取数据</td></tr></tbody></table><h4 id="M-toRAM"><a href="#M-toRAM" class="headerlink" title="M_toRAM"></a>M_toRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行读操作的地址</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>读取的待处理的寄存器数据</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>MemWrite</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>m_data_byteen[3:0]</td><td>O</td><td>控制写入数据在DM中的位置</td></tr><tr><td>m_data_wdata[31:0]</td><td>O</td><td>处理后的正确的待写入数据</td></tr></tbody></table><h4 id="控制信号-6"><a href="#控制信号-6" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h4 id="与mips-txt-v交互-1"><a href="#与mips-txt-v交互-1" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] M_dmrd;<br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> m_data_addr = M_aluans;<br><br>toRAM M_Store(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.gpr_rt</span>(M_fwd_gprrt),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.MemWrite</span>(M_MemWrite),<br>    <span class="hljs-variable">.m_data_byteen</span>(m_data_byteen),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_data_wdata)<br>);<br><br>fromRAM M_Load(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.m_data_rdata</span>(m_data_rdata),<br>    <span class="hljs-variable">.RD</span>(M_dmrd)<br>);<br><br><span class="hljs-keyword">assign</span> w_grf_wdata = W_grfWD;<br><span class="hljs-keyword">assign</span> w_inst_addr = W_PC;<br><span class="hljs-keyword">assign</span> w_grf_addr = W_A3Sel;<br></code></pre></td></tr></table></figure><h3 id="CP0协处理器"><a href="#CP0协处理器" class="headerlink" title="CP0协处理器"></a>CP0协处理器</h3><p>考虑到宏观PC的处理，将CP0置于M级较为合理。</p><p>将**异常码<code>ExcCode</code>、是否处于延迟槽中的判断信号<code>BDIn</code><strong>和</strong>当前<code>PC</code>**（如果时取指地址异常则传递错误的PC值）一直跟着流水线到达M级直至提交至CP0，由CP0综合判断分析是否响应该异常。</p><p>如果需要响应该异常，则CP0输出Req信号置为1，此时FD、DE、DM、MW寄存器响应Req信号，清空Instr，将PC值设为<code>0x00004180</code>，然后向F级NPC的NPC也被置为<code>0x00004180</code>，下一条指令从<code>0x00004180</code>开始执行。</p><p>当外设和系统外部输入中断信号时，CP0同样也会确认是否响应该中断，然后把Req置为1，执行相同的操作。</p><p>当系统外部输入中断信号时，CP0还会输出一个<code>IntResponse</code>信号指示是否响应外部中断信号，如果响应则系统会相应去写<code>0x00007f20</code>地址，从而时外部中断信号停止。</p><blockquote><p><strong>宏观PC</strong>表示整个 CPU “宏观”运行指令所对应的PC地址。</p><p>所谓“宏观”指令，表示该指令之前的所有指令序列对CPU的更新已完成，该指令及其之后的指令序列对 CPU 的更新未完成。</p></blockquote><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>CP0Add[4:0]</td><td>I</td><td>CP0中寄存器的地址</td></tr><tr><td>CP0In[31:0]</td><td>I</td><td>写入寄存器的32位数据</td></tr><tr><td>VPC[31:0]</td><td>I</td><td>受害PC</td></tr><tr><td>BDIn</td><td>I</td><td>是否为延迟槽内指令，高电平有效</td></tr><tr><td>ExcCodeIn[4:0]</td><td>I</td><td>异常码</td></tr><tr><td>HWInt[5:0]</td><td>I</td><td>外部硬件中断信号</td></tr><tr><td>EXLClr</td><td>I</td><td>将SR的Exl置0，高电平有效</td></tr><tr><td>CP0Out[31:0]</td><td>O</td><td>输出地址为<code>CP0Add</code>的寄存器的值</td></tr><tr><td>EPCOut[31:0]</td><td>O</td><td>输出当前<code>EPC</code>的值</td></tr><tr><td>Req</td><td>O</td><td>是否响应中断请求</td></tr><tr><td>IntResponse</td><td>O</td><td>是否响应<code>中断发生器</code>的中断请求</td></tr></tbody></table><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><table><thead><tr><th>寄存器</th><th>编号</th><th>功能</th></tr></thead><tbody><tr><td>SR</td><td>12</td><td>配置异常的功能</td></tr><tr><td>Cause</td><td>13</td><td>记录异常发生的原因和情况</td></tr><tr><td>EPC</td><td>14</td><td>记录异常处理结束后需要返回的 PC</td></tr></tbody></table><h4 id="功能域"><a href="#功能域" class="headerlink" title="功能域"></a>功能域</h4><table><thead><tr><th align="left">寄存器</th><th align="left">功能域</th><th align="left">位域</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">SR（State Register）</td><td align="left">IM（Interrupt Mask）</td><td align="left">15:10</td><td align="left">分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 <code>mtc0</code> 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr><td align="left">SR（State Register）</td><td align="left">EXL（Exception Level）</td><td align="left">1</td><td align="left">任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr><td align="left">SR（State Register）</td><td align="left">IE（Interrupt Enable）</td><td align="left">0</td><td align="left">全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。</td></tr><tr><td align="left">Cause</td><td align="left">BD（Branch Delay）</td><td align="left">31</td><td align="left">当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr><td align="left">Cause</td><td align="left">IP（Interrupt Pending）</td><td align="left">15:10</td><td align="left">为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr><td align="left">Cause</td><td align="left">ExcCode</td><td align="left">6:2</td><td align="left">异常编码，记录当前发生的是什么异常。</td></tr><tr><td align="left">EPC</td><td align="left">-</td><td align="left">-</td><td align="left">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><h4 id="异常码"><a href="#异常码" class="headerlink" title="异常码"></a>异常码</h4><table><tbody><tr>    <th width="120">异常与中断码</th>    <th width="145">助记符与名称</th>    <th>指令与指令类型</th>    <th>描述</th></tr><tr>    <td align="center">0</td>    <td align="center"><code>Int</code><br>（外部中断）</td>    <td align="center">所有指令</td>    <td>中断请求，来源于计时器与外部中断。</td></tr><tr>    <td rowspan="7" align="center">4</td>    <td rowspan="2" align="center"><code>AdEL</code><br>（取指异常）</td>    <td rowspan="2" align="center">所有指令</td>    <td>PC 地址未字对齐。</td></tr><tr>    <td>PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr>    <td rowspan="5" align="center"><code>AdEL</code><br>（取数异常）</td>    <td align="center"><code>lw</code></td>    <td>取数地址未与 4 字节对齐。</td></tr><tr>    <td align="center"><code>lh</code></td>    <td>取数地址未与 2 字节对齐。</td></tr><tr>    <td align="center"><code>lh</code>, <code>lb</code></td>    <td>取 Timer 寄存器的值。</td></tr><tr>    <td align="center">load 型指令</td>    <td>计算地址时加法溢出。</td></tr><tr>    <td align="center">load 型指令</td>    <td>取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr>    <td rowspan="6" align="center">5</td>    <td rowspan="6" align="center"><code>AdES</code><br>（存数异常）</td>    <td align="center"><code>sw</code></td>    <td>存数地址未 4 字节对齐。</td></tr><tr>    <td align="center"><code>sh</code></td>    <td>存数地址未 2 字节对齐。</td></tr><tr>    <td align="center"><code>sh</code>, <code>sb</code></td>    <td>存 Timer 寄存器的值。</td></tr><tr>    <td align="center">store 型指令</td>    <td>计算地址加法溢出。</td></tr><tr>    <td align="center">store 型指令</td>    <td>向计时器的 Count 寄存器存值。</td></tr><tr>    <td align="center">store 型指令</td>    <td>存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr>    <td align="center">8</td>    <td align="center"><code>Syscall</code><br>（系统调用）</td>    <td align="center"><code>syscall</code></td>    <td>系统调用。</td></tr><tr>    <td align="center">10</td>    <td align="center"><code>RI</code>（未知指令）</td>    <td align="center">-</td>    <td>未知的指令码。</td></tr><tr>    <td align="center">12</td>    <td align="center"><code>Ov</code>（溢出异常）</td>    <td align="center"><code>add</code>, <code>addi</code>, <code>sub</code></td>    <td>算术溢出。</td></tr></tbody></table><h3 id="M-W级流水线寄存器"><a href="#M-W级流水线寄存器" class="headerlink" title="M&#x2F;W级流水线寄存器"></a>M&#x2F;W级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>M_pc[31:0]</td><td>I</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>M_dmrd[31:0]</td><td>I</td><td>从DM中读取的值</td></tr><tr><td>W_pc[31:0]</td><td>O</td><td>W级PC</td></tr><tr><td>W_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>W_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>W_dmrd[31:0]</td><td>O</td><td>从DM中读取的值</td></tr></tbody></table><h2 id="W级：写回（Writeback）"><a href="#W级：写回（Writeback）" class="headerlink" title="W级：写回（Writeback）"></a>W级：写回（Writeback）</h2><p>本级与D级是重合的，需要处理向E级和M级的转发。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>采用<strong>暴力转发</strong>的方式。由AT法的分析，不阻塞就意味着一定能够在使用该寄存器的值之前获得最新的且正确的值。因此采用暴力转发总能得到一个正确的值去覆盖原先错误的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// D级转发</span><br><span class="hljs-keyword">assign</span> D_fwd_gprrs = (D_rs == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rs == E_A3Sel) ? E_grfWD :<br>                    (D_rs == M_A3Sel) ? M_grfWD : D_gpr_rs;<br><br><span class="hljs-keyword">assign</span> D_fwd_gprrt = (D_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rt == E_A3Sel) ? E_grfWD :<br>                    (D_rt == M_A3Sel) ? M_grfWD : D_gpr_rt;<br><br><br><span class="hljs-comment">// E级转发</span><br><span class="hljs-keyword">assign</span> E_grfWD = (E_WDSel == `WDSel_PCa8) ? (E_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>; <span class="hljs-comment">// 不能对功能部件输出进行转发</span><br><span class="hljs-keyword">assign</span> E_fwd_gprrs = (E_rs == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rs == M_A3Sel) ? M_grfWD :<br>                    (E_rs == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rs;<br><br><span class="hljs-keyword">assign</span> E_fwd_gprrt = (E_rt == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rt == M_A3Sel) ? M_grfWD :<br>                    (E_rt == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rt;<br><br><br><span class="hljs-comment">// M级转发</span><br><span class="hljs-keyword">assign</span> M_grfWD = (M_WDSel == `WDSel_aluans) ? M_aluans :<br>                (M_WDSel == `WDSel_mduans) ? M_mduans :<br>                (M_WDSel == `WDSel_PCa8) ? (M_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br><span class="hljs-keyword">assign</span> M_fwd_gprrt = (M_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">5&#x27;d0</span>) :<br>                    (M_rt == W_A3Sel) ? W_grfWD :<br>                    M_gpr_rt;<br><br><br><span class="hljs-comment">// W级转发</span><br><span class="hljs-keyword">assign</span> W_grfWD = (W_WDSel == `WDSel_aluans) ? W_aluans :<br>                (W_WDSel == `WDSel_dmrd) ? W_dmrd :<br>                (W_WDSel == `WDSel_mduans) ? W_mduans :<br>                (W_WDSel == `WDSel_PCa8) ? (W_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>使用组合逻辑，判断每一级中指令的$Tuse$和$Tnew$。</p><p>如果有$Tuse$ &lt; $Tnew$，就执行阻塞。<strong>只可能在D级进行阻塞</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// stall_handle.v</span><br><span class="hljs-keyword">assign</span> D_Tuse_rs = (D_branch | D_j2r) ? <span class="hljs-number">3&#x27;d0</span> :<br>                (D_ic | D_rc | D_load | (D_store &amp;&amp; !D_shift_s) | D_mt | D_md) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> D_Tuse_rt = (D_branch) ? <span class="hljs-number">3&#x27;d0</span> :<br>                    (D_rc | D_md) ? <span class="hljs-number">3&#x27;d1</span> :<br>                    (D_store | D_mtc0) ? <span class="hljs-number">3&#x27;d2</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> E_Tnew = (E_rc | E_ic | E_mf) ? <span class="hljs-number">3&#x27;d1</span> :<br>                (E_load | E_mfc0) ? <span class="hljs-number">3&#x27;d2</span> :<br>                <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> E_stall_rs = (E_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> E_stall_rt = (E_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> M_Tnew = (M_load | M_mfc0) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> M_stall_rs = (M_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> M_stall_rt = (M_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rt);<br><span class="hljs-keyword">assign</span> M_stall_eret = D_eret &amp;&amp; ((E_mtc0 &amp;&amp; E_rd == <span class="hljs-number">5&#x27;d14</span>) || (M_mtc0 &amp;&amp; M_rd == <span class="hljs-number">5&#x27;d14</span>));<br><br><span class="hljs-keyword">assign</span> E_stall_mdu = ((D_mf | D_mt | D_md) &amp;&amp; (E_MDU_busy | E_MDU_start));<br><br><br><span class="hljs-comment">// mips.v</span><br><span class="hljs-keyword">wire</span> stall;<br><span class="hljs-keyword">assign</span> FD_WE = !stall; <span class="hljs-comment">//冻结FD寄存器</span><br><span class="hljs-keyword">assign</span> IFU_WE = !stall; <span class="hljs-comment">//冻结PC</span><br><span class="hljs-keyword">assign</span> DE_flush = stall; <span class="hljs-comment">//清空DE寄存器</span><br><br><span class="hljs-keyword">assign</span> DE_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> EM_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> MW_WE = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">assign</span> FD_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> EM_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> MW_flush = <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h2 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h2><p>系统桥是处理CPU与外设（两个计时器）之间信息交互的通道。</p><p>CPU中store类指令需要储存的数据经过BE处理后会通过m_data_addr, m_data_byteen, m_data_wdata三个信号输出到桥中，桥会根据写使能m_data_byteen和地址m_data_addr来判断到底<strong>写的是内存还是外设</strong>，然后给出正确的写使能。</p><p>load类指令则是全部把地址传递给每个外设和DM中，然后桥根据地址选择从应该反馈给CPU从哪里读出来的数据，然后DE在处理读出的数据，反馈正确的结果。</p><table><thead><tr><th align="center">条目</th><th align="center">地址或地址范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">数据存储器</td><td align="center">0x0000_0000∼0x0000_2FFF</td><td align="center"></td></tr><tr><td align="center">指令存储器</td><td align="center">0x0000_3000∼0x0000_6FFF</td><td align="center"></td></tr><tr><td align="center">PC 初始值</td><td align="center">0x0000_3000</td><td align="center"></td></tr><tr><td align="center">异常处理程序入口地址</td><td align="center">0x0000_4180</td><td align="center"></td></tr><tr><td align="center">计时器 0 寄存器地址</td><td align="center">0x0000_7F00∼0x0000_7F0B</td><td align="center">计时器 0 的 3 个寄存器</td></tr><tr><td align="center">计时器 1 寄存器地址</td><td align="center">0x0000_7F10∼0x0000_7F1B</td><td align="center">计时器 1 的 3 个寄存器</td></tr><tr><td align="center">中断发生器响应地址</td><td align="center">0x0000_7F20∼0x0000_7F23</td><td align="center"></td></tr></tbody></table><p>Bridge的端口列表如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> bridge(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_rdata,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_addr,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_wdata,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] m_temp_data_byteen,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_out,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_out,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_addr,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_wdata,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] m_data_byteen,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_rdata,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_addr,<br>    <span class="hljs-keyword">output</span> TC0_WE,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_addr,<br>    <span class="hljs-keyword">output</span> TC1_WE,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_in<br>    );<br></code></pre></td></tr></table></figure><h2 id="MIPS微系统实现"><a href="#MIPS微系统实现" class="headerlink" title="MIPS微系统实现"></a>MIPS微系统实现</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// mips.v</span><br><br><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,                    <span class="hljs-comment">// 时钟信号</span><br>    <span class="hljs-keyword">input</span> reset,                  <span class="hljs-comment">// 同步复位信号</span><br>    <span class="hljs-keyword">input</span> interrupt,              <span class="hljs-comment">// 外部中断信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] macroscopic_pc, <span class="hljs-comment">// 宏观 PC</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_addr,    <span class="hljs-comment">// IM 读取地址（取指 PC）</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_rdata,   <span class="hljs-comment">// IM 读取数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_addr,    <span class="hljs-comment">// DM 读写地址</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_rdata,   <span class="hljs-comment">// DM 读取数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_wdata,   <span class="hljs-comment">// DM 待写入数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_data_byteen,  <span class="hljs-comment">// DM 字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_int_addr,     <span class="hljs-comment">// 中断发生器待写入地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_int_byteen,   <span class="hljs-comment">// 中断发生器字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_inst_addr,    <span class="hljs-comment">// M 级 PC</span><br><br>    <span class="hljs-keyword">output</span> w_grf_we,              <span class="hljs-comment">// GRF 写使能信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span> :<span class="hljs-number">0</span>] w_grf_addr,     <span class="hljs-comment">// GRF 待写入寄存器编号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_grf_wdata,    <span class="hljs-comment">// GRF 待写入数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_inst_addr     <span class="hljs-comment">// W 级 PC</span><br>    );<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_addr;<br><span class="hljs-keyword">wire</span> TC0_WE;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_in;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC0_out;<br><span class="hljs-keyword">wire</span> TC0_IRQ;<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_addr;<br><span class="hljs-keyword">wire</span> TC1_WE;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_in;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] TC1_out;<br><span class="hljs-keyword">wire</span> TC1_IRQ;<br><br>TC TC0(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.Addr</span>(TC0_addr[<span class="hljs-number">31</span>:<span class="hljs-number">2</span>]),<br>    <span class="hljs-variable">.WE</span>(TC0_WE),<br>    <span class="hljs-variable">.Din</span>(TC0_in),<br>    <span class="hljs-variable">.Dout</span>(TC0_out),<br>    <span class="hljs-variable">.IRQ</span>(TC0_IRQ)<br>);<br><br>TC TC1(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.Addr</span>(TC1_addr[<span class="hljs-number">31</span>:<span class="hljs-number">2</span>]),<br>    <span class="hljs-variable">.WE</span>(TC1_WE),<br>    <span class="hljs-variable">.Din</span>(TC1_in),<br>    <span class="hljs-variable">.Dout</span>(TC1_out),<br>    <span class="hljs-variable">.IRQ</span>(TC1_IRQ)<br>);<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_addr;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_rdata;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_temp_data_wdata;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] m_temp_data_byteen;<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] HWInt;<br><span class="hljs-keyword">wire</span> HWIntResponse;<br><span class="hljs-keyword">assign</span> HWInt = &#123;<span class="hljs-number">3&#x27;b000</span>, interrupt, TC1_IRQ, TC0_IRQ&#125;;<br><br>cpu CPU(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.HWInt</span>(HWInt),<br>    <span class="hljs-variable">.macroscopic_pc</span>(macroscopic_pc),<br>    <span class="hljs-variable">.i_inst_rdata</span>(i_inst_rdata),<br>    <span class="hljs-variable">.m_data_rdata</span>(m_temp_data_rdata),<br>    <span class="hljs-variable">.i_inst_addr</span>(i_inst_addr),<br>    <span class="hljs-variable">.m_data_addr</span>(m_temp_data_addr),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_temp_data_wdata),<br>    <span class="hljs-variable">.m_data_byteen</span>(m_temp_data_byteen),<br>    <span class="hljs-variable">.m_inst_addr</span>(m_inst_addr),<br>    <span class="hljs-variable">.w_grf_we</span>(w_grf_we),<br>    <span class="hljs-variable">.w_grf_addr</span>(w_grf_addr),<br>    <span class="hljs-variable">.w_grf_wdata</span>(w_grf_wdata),<br>    <span class="hljs-variable">.w_inst_addr</span>(w_inst_addr),<br>    <span class="hljs-variable">.HWIntResponse</span>(HWIntResponse)<br>);<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bridge_m_data_addr;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] bridge_m_data_byteen;<br><br>bridge Bridge(<br>    <span class="hljs-variable">.m_data_rdata</span>(m_data_rdata),<br>    <span class="hljs-variable">.m_temp_data_addr</span>(m_temp_data_addr),<br>    <span class="hljs-variable">.m_temp_data_wdata</span>(m_temp_data_wdata),<br>    <span class="hljs-variable">.m_temp_data_byteen</span>(m_temp_data_byteen),<br>    <span class="hljs-variable">.TC0_out</span>(TC0_out),<br>    <span class="hljs-variable">.TC1_out</span>(TC1_out),<br>    <span class="hljs-variable">.m_data_addr</span>(bridge_m_data_addr),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_data_wdata),<br>    <span class="hljs-variable">.m_data_byteen</span>(bridge_m_data_byteen),<br>    <span class="hljs-variable">.m_temp_data_rdata</span>(m_temp_data_rdata),<br>    <span class="hljs-variable">.TC0_addr</span>(TC0_addr),<br>    <span class="hljs-variable">.TC0_WE</span>(TC0_WE),<br>    <span class="hljs-variable">.TC0_in</span>(TC0_in),<br>    <span class="hljs-variable">.TC1_addr</span>(TC1_addr),<br>    <span class="hljs-variable">.TC1_WE</span>(TC1_WE),<br>    <span class="hljs-variable">.TC1_in</span>(TC1_in)<br>);<br><br><span class="hljs-keyword">assign</span> m_data_addr = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">32&#x27;h0000_7f20</span> : bridge_m_data_addr;<br><span class="hljs-keyword">assign</span> m_data_byteen = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">4&#x27;b0001</span> : bridge_m_data_byteen;<br><br><span class="hljs-keyword">assign</span> m_int_addr = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">32&#x27;h0000_7f20</span> : bridge_m_data_addr;<br><span class="hljs-keyword">assign</span> m_int_byteen = (HWIntResponse &amp;&amp; interrupt) ? <span class="hljs-number">4&#x27;b0001</span> : bridge_m_data_byteen;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>对特定的异常和中断编写程序进行测试。</p><h3 id="取值异常"><a href="#取值异常" class="headerlink" title="取值异常"></a>取值异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br><br>li $28, 0<br>li $29, 0<br><br># jr PC mod 4 not 0<br>la $1, label1<br>la $2, label1<br>addiu $1, $1, 1<br>jr $1<br>nop<br>label1:<br><br># jr PC &lt; 0x3000<br>li $1, 0x2996<br>la $2, label2<br>jr $1<br>nop<br>label2:<br><br># jr PC &gt; 0x4ffc<br>li $1, 0x4fff<br>la $2, label3<br>jr $1<br>nop<br>label3:<br><br>end:j end<br><br>.ktext 0x4180<br>mfc0 $12, $12<br>mfc0 $13, $13<br>mfc0 $14, $14<br>mtc0 $2, $14<br>eret<br>ori $1, $0, 0<br></code></pre></td></tr></table></figure><h3 id="存取地址异常"><a href="#存取地址异常" class="headerlink" title="存取地址异常"></a>存取地址异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text <br>ori$28, $0, 0x0000<br>ori$29, $0, 0x0f00<br>mtc0$0, $12<br><br>lui$8, 0x7fff<br>ori$8, $8, 0xffff<br><br>lui$9, 0x8000<br>ori$9, $9, 0x0000<br><br>lw$10, 1($8)# 测试对 lw 地址上界溢出的处理<br>lh$10, 1($8)# 测试对 lh 地址上界溢出的处理<br>lb$10, 1($8)# 测试对 lb 地址上界溢出的处理<br>lw$10,-1($9)# 测试对 lw 地址下界溢出的处理<br>lh$10,-1($9)# 测试对 lh 地址下界溢出的处理<br>lb$10,-1($9)# 测试对 lb 地址下界溢出的处理<br><br>sw$10, 1($8)# 测试对 sw 地址上界溢出的处理<br>sh$10, 1($8)# 测试对 sh 地址上界溢出的处理<br>sb$10, 1($8)# 测试对 sb 地址上界溢出的处理<br>sw$10,-1($9)# 测试对 sw 地址下界溢出的处理<br>sh$10,-1($9)# 测试对 sh 地址下界溢出的处理<br>sb$10,-1($9)# 测试对 sb 地址下界溢出的处理<br><br>end:j end<br><br><br>.ktext 0x4180<br>mfc0 $12, $12<br>mfc0 $13, $13<br>mfc0 $14, $14<br>addi $14, $14, 4<br>mtc0 $14, $14<br>eret<br>ori $1, $0, 0<br></code></pre></td></tr></table></figure><h3 id="计算溢出"><a href="#计算溢出" class="headerlink" title="计算溢出"></a>计算溢出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text <br>ori$28, $0, 0x0000<br>ori$29, $0, 0x0f00<br>mtc0$0, $12<br><br>lui$8, 0x7fff<br>ori$8, $8, 0xffff<br><br>lui$9, 0x8000<br>ori$9, $9, 0x0000<br><br>ori$10, 0x0001<br>lui$11, 0xffff<br>ori$11, $11, 0xffff<br><br>add$12, $10, $8# 测试 add 上界溢出的情况<br>add$12, $11, $9# 测试 add 下界溢出的情况<br>addi$12, $8, 1# 测试 addi 上界溢出的情况<br>addi$12, $9, -1# 测试 addi 下界溢出的情况<br>sub$12, $8, $11# 测试 sub 上界溢出的情况<br>sub$12, $9, $10# 测试 sub 下界溢出的情况<br></code></pre></td></tr></table></figure><h3 id="计时器功能"><a href="#计时器功能" class="headerlink" title="计时器功能"></a>计时器功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br>li $12, 0x0c01<br>mtc0 $12, $12<br><br>li $1, 500<br>li $2, 9<br><br>sw $1, 0x7f04($0)<br>sw $2, 0x7f00($0)<br>li $1, 1000<br>sw $1, 0x7f14($0)<br>sw $2, 0x7f10($0)<br><br>lw $1, 0x7f00($0)<br>lw $1, 0x7f04($0)<br>lw $1, 0x7f10($0)<br>lw $1, 0x7f14($0)<br><br>li $1, 0<br>li $2, 0<br><br>for:<br>ori $3, $3, 0<br>beq $1, $0, for<br>nop<br>beq $2, $0, for<br>nop<br><br>lw $1, 0x7f00($0)<br>lw $1, 0x7f04($0)<br>lw $1, 0x7f10($0)<br>lw $1, 0x7f14($0)<br><br>end:j end<br><br>.ktext 0x4180<br>mfc0 $13, $13<br>li $15, 0x7fffffff<br>and $13, $13, $15<br>li $14, 1024<br>beq $13, $14, timer0<br>nop<br>li $14, 2048<br>beq $13, $14, timer1<br>nop<br>eret<br><br>timer0:<br>li $1, 1<br>sw $0, 0x7f00($0)<br>eret<br><br>timer1:<br>li $2, 2<br>sw $0, 0x7f10($0)<br>eret<br></code></pre></td></tr></table></figure><h3 id="延迟槽异常"><a href="#延迟槽异常" class="headerlink" title="延迟槽异常"></a>延迟槽异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text <br>ori$28, $0, 0x0000<br>ori$29, $0, 0x0f00<br>mtc0$0, $12<br><br>jnxt1<br>lw$0, 1($0)# 测试延迟槽内 lw 地址不对齐异常<br>nxt1:<br>jnxt2<br>sw$0, 1($0)# 测试延迟槽内 sw 地址不对齐异常<br>nxt2:<br>lui$8, 0x7fff<br>ori$8, $8, 0xffff<br>jend<br>addi$10, $8, 1# 测试延迟槽内 addi 溢出异常<br>end:j end<br>nop<br></code></pre></td></tr></table></figure><h3 id="未知指令-系统调用"><a href="#未知指令-系统调用" class="headerlink" title="未知指令&#x2F;系统调用"></a>未知指令&#x2F;系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lui      $s0,0x8000<br>lui      $s1,0x7fff<br>ori      $s1,$s1,0xffff<br>syscall<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br>addi    $10,$s1,10<br>sw      $10,0x1002($0)<br>sh      $10,0x1001($0)<br>mult    $10,$10<br>lw      $10,0x1002($0)<br>lh      $10,0x1001($0)<br>mult    $10,$10<br>lh      $10,0x1001($0)<br>sub     $10,$s0,$s1<br>addi    $10,$s1,10<br>sw      $10,0x1002($0)<br>sh      $10,0x1001($0)<br>mult    $10,$10<br>sw      $10,0x1002($0)<br>sh      $10,0x1001($0)<br>lw      $10,0x1002($0)<br>lh      $10,0x1001($0)<br>lhu     $10,0x1001($0) # 未知指令<br>mult    $10,$10<br>sh      $10,0x1001($0)<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br>mult    $10,$10<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br>j label_1<br>add     $10,$s0,$s0<br>sub     $10,$s0,$s1<br></code></pre></td></tr></table></figure><h3 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ori $1,$1,0x7001<br>mtc0 $1,$12<br><br>#pc地址未对齐<br>ori $2,$2,0x300a<br>#jr $2<br>#add $2,$2,$2#顺便延迟槽<br>#pc地址超范围<br>#jr $2<br>#ori $3,$3,0x0003<br><br>#lw、lh没有字对齐<br>lw $2,0($3)<br>lh $2,1($0)<br>#lh、lb取Timer寄存器的值<br>ori $4,$4,0x7f00<br>lw $5,0($4)#应该没错<br>lh $5,0($4)<br>lb $5,20($4)<br>#计算地址加法溢出<br>lui $6,65535<br>ori $6,$6,65535<br>lw $7,1($6)<br>#取数地址超出范围<br>ori $7,0x7f0c<br>lw $7,0($7)<br><br>#sw、sh没有字对齐<br>sw $2,0($3)<br>sh $2,1($0)<br>#sh、sb取Timer寄存器的值<br>sw $5,0($4)#应该没错<br>sh $5,0($4)<br>sb $5,20($4)<br>#计算地址加法溢出<br>lui $6,65535<br>ori $6,$6,65535<br>sw $7,1($6)<br>#向计时器Count寄存器存值<br>sw $7,-4($7)<br>#存数地址超出范围<br>sw $7,100($7)<br><br>#syscall<br>syscall<br><br>#RI<br>nor $2,$3,$4<br><br>#算术溢出<br>addi $1,$0,1<br>sub $8,$0,$1<br>add $9,$8,$6#不应溢出<br>sub $9,$6,$8#溢出<br>add $9,$6,$7#溢出<br>sub $9,$0,$6<br>addi $9,$9,-100#溢出<br><br><br>end:<br>beq $0,$0,end#死循环<br>nop<br><br>#异常处理程序<br>.ktext 0x4180<br>mfc0 $k0,$12<br>mfc0 $k0,$13<br>mfc0 $k0,$14<br>addi $k0,$k0,4<br>mtc0 $k0,$14<br>eret<br>add $2,$2,$2#应当没有延迟槽<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>鼠标和键盘的输入信号都会转化为不同的系统中断信号，CPU根据中断信号的值可以执行对应的汇编指令。</p></li><li><p>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>依旧可以实现，无非是需要更改一下CPU中当出现异常或中断时要跳转到的异常处理程序地址，之后由用户提供的程序依旧可以对中断和异常进行处理。但入口常常变动会导致该CPU的适用性降低，换个执行指令段需要换个入口。</p></li><li><p>为何与外设通信需要 Bridge？</p><p>使得CPU不需要关心具体的数据从何而来，只需要知道地址即可。假如每个外设都要针对CPU做单独处理，那么时间与经济成本实在是过于昂贵且没必要了。</p></li><li><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>相同之处：在允许计数的情况下，都是从初值寄存器中获取初数值到计数值寄存器中开始计数，两种模式都受控制寄存器的控制<br>区别之处：模式0在计数结束后，会一直提供中断信号，直到IM或者EN被修改使其禁止中断或停止计数，模式1在计数结束后，只会提供一周期的中断信号，然后自动再次赋初值开始计数，知道IM或者EN被修改行为才会被改变</p><p>模式0的状态转移图如下：</p><pre><code class=" mermaid">stateDiagram[*] --&gt; IDLEIDLE --&gt; IDLE:resetIDLE --&gt; LOAD:ctrl[0] = 1LOAD --&gt; CNTCNT --&gt; CNT:ctrl[0] &amp;&amp; count &gt; 1CNT --&gt; INT:ctrl[0] &amp;&amp; count &lt;= 1INT --&gt; IDLE:ctrl[0] = 0 &amp;&amp; Int = 1CNT --&gt; IDLE:!ctrl[0]</code></pre><p>模式1的状态转移图如下：</p><pre><code class=" mermaid">stateDiagram[*] --&gt; IDLEIDLE --&gt; IDLE:resetIDLE --&gt; LOAD:ctrl[0] = 1LOAD --&gt; CNTCNT --&gt; CNT:ctrl[0] &amp;&amp; count &gt; 1CNT --&gt; INT:ctrl[0] &amp;&amp; count &lt;= 1INT --&gt; IDLE:Int = 0CNT --&gt; IDLE:ctrl[0] == 0</code></pre></li><li><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>会导致宏观PC突然为0，这显然是不合理的。在清空流水线的时候，应该保留PC信息。</p></li><li><p>为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><p>如果 <code>jalr $31 $31 </code>的延迟槽内发生异常或需要响应中断，由于此时 <code>$31</code> 寄存器的值已经被 <code>jalr</code> 改变，但是处理异常结束后，会再次执行 <code>jalr</code> 指令，从而就会跳转到不正确的 <code>PC</code> 地址。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>试题</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P6 - 流水线CPU设计文档</title>
    <link href="/2023/11/28/P6%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/28/P6%20%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P6-流水线CPU设计文档"><a href="#P6-流水线CPU设计文档" class="headerlink" title="P6 流水线CPU设计文档"></a>P6 流水线CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li><p>设计的处理器为32位五级流水线处理器</p></li><li><p>处理器支持的指令集为</p><blockquote><p>add, sub, and, or, slt, sltu, lui<br>addi, andi, ori<br>lb, lh, lw, sb, sh, sw<br>mult, multu, div, divu, mfhi, mflo, mthi, mtlo<br>beq, bne, jal, jr</p></blockquote></li><li><p>所有运算类指令均暂不考虑因溢出而产生的异常</p></li></ul><p>整体架构参考了《数字设计与计算机体系结构》图7-58。</p><p><img src="https://pic.imgdb.cn/item/654cc27dc458853aef789452.png" alt="整体架构"></p><h2 id="F级：取指令（Fetch）"><a href="#F级：取指令（Fetch）" class="headerlink" title="F级：取指令（Fetch）"></a>F级：取指令（Fetch）</h2><p>本级的输入为来自D级的<code>next_pc</code>，用于更新下一个PC的值。</p><p>本级的输出为<code>F_PC</code>和<code>F_Instr</code>，分别对应从F级指令的PC和F级指令的内容，均需要参与流水。</p><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><p>只负责PC的存储与更新，F_instr来自<code>mips_txt.v</code>的交互。</p><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>PC写使能信号，高电平有效</td></tr><tr><td>next_pc[31:0]</td><td>I</td><td>待更新的指令地址</td></tr><tr><td>pc[31:0]</td><td>O</td><td>当前指令地址</td></tr></tbody></table><h4 id="与mips-txt-v交互"><a href="#与mips-txt-v交互" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog">ifu F_IFU(<br>    <span class="hljs-variable">.clk</span>(clk),<br>    <span class="hljs-variable">.reset</span>(reset),<br>    <span class="hljs-variable">.enable</span>(IFU_WE),<br>    <span class="hljs-variable">.next_pc</span>(next_PC),<br>    <span class="hljs-variable">.pc</span>(F_PC)<br>);<br><br><span class="hljs-keyword">assign</span> F_Instr = i_inst_rdata;<br><span class="hljs-keyword">assign</span> i_inst_addr = F_PC;<br></code></pre></td></tr></table></figure><h3 id="F-D级流水线寄存器"><a href="#F-D级流水线寄存器" class="headerlink" title="F&#x2F;D级流水线寄存器"></a>F&#x2F;D级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>F_pc[31:0]</td><td>I</td><td>F级PC</td></tr><tr><td>F_instr[31:0]</td><td>I</td><td>时钟信号</td></tr><tr><td>D_pc[31:0]</td><td>O</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>O</td><td>32位的指令值</td></tr></tbody></table><h2 id="D级：译码（Decode）"><a href="#D级：译码（Decode）" class="headerlink" title="D级：译码（Decode）"></a>D级：译码（Decode）</h2><p>本级的输入为来自F级的<code>F_PC</code>和<code>F_Instr</code>。</p><p>本级的输出为<code>D_gpr_rs</code>, <code>D_gpr_rt</code>, <code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>和<code>next_pc</code>。</p><p>本级涉及到来自E级、M级、W级的转发，其中来自W级的转发通过<strong>GRF内部转发</strong>的方式实现。</p><p><code>$rs</code>和<code>$rt</code>的值在本级转发成<code>D_fwd_gprrs</code>和<code>D_fwd_gprrt</code>，和<code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>参与流水。</p><p>本级需要对<strong>此级指令</strong>的$$Tuse$$和此时<strong>E级</strong>指令与<strong>M级指令</strong>的$Tnew$进行比较，从而确定是否执行阻塞。</p><blockquote><p>$Tuse$和$Tnew$:</p><ul><li><p>$Tuse$表示这条指令位于D级的时候，再经过多少个时钟周期就必须要使用相应的数据。</p><ul><li>每个指令的$Tuse$是固定不变的</li><li>一个指令可以有两个$Tuse$值</li></ul></li><li><p>$Tnew$表示位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。</p><ul><li>$Tnew$是一个动态值，每个指令处于流水线不同阶段有不同的$Tnew$值</li><li>一个指令在一个时刻至多有一个$Tnew$值（一个指令至多写一个寄存器）</li></ul></li><li><p>当$Tuse$ &gt;&#x3D; $Tnew$，说明需要的数据可以及时算出，可以通过<strong>转发</strong>来解决</p><p>当$Tuse$ &lt; $Tnew$，说明需要的数据不能及时算出，必须<strong>阻塞</strong>流水线解决</p></li></ul></blockquote><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><blockquote><ul><li>如果不需要写寄存器，只需要把A3Sel设为0即可。</li><li>此处<strong>WPC</strong>和<strong>WD</strong>均来自<strong>W级</strong>。</li></ul></blockquote><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa8</td><td>WD为<strong>当前流水线层级的PC</strong> + 8</td></tr></tbody></table><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_pc[31:0]</td><td>I</td><td>当前F级PC的值</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>当前D级PC的值</td></tr><tr><td>PCSel[1:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>branch</td><td>I</td><td>branch类型指令<strong>是否达到跳转条件</strong>，高电平有效</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即D_Instr[25:0]</td></tr><tr><td>offset[15:0]</td><td>I</td><td>branch类型指令的偏移量，即D_Instr[15:0]</td></tr><tr><td>ra[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器保存的地址值</td></tr><tr><td>next_pc[31:0]</td><td>O</td><td>下一指令的PC</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- GPR[rs]</td></tr></tbody></table><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>gpr_rs[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器中的值</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rt</code>寄存器中的值</td></tr><tr><td>CMPOp[1:0]</td><td>I</td><td>指定比较数据的方式</td></tr><tr><td>flag</td><td>O</td><td>是否满足所设条件，高电平有效</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>CMPOp</th><th>操作</th></tr></thead><tbody><tr><td>CMP_beq</td><td>beq指令: 若<code>GPR[rs] == GPR[rt]</code>，则flag置1，否则置0</td></tr></tbody></table><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="D-E级流水线寄存器"><a href="#D-E级流水线寄存器" class="headerlink" title="D&#x2F;E级流水线寄存器"></a>D&#x2F;E级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>D_extres[31:0]</td><td>I</td><td>16位立即数扩展的结果</td></tr><tr><td>D_gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>D_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>E_pc[31:0]</td><td>O</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>E_gpr_rs[31:0]</td><td>O</td><td>GPR[rs]</td></tr><tr><td>E_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="E级：执行（Execute）"><a href="#E级：执行（Execute）" class="headerlink" title="E级：执行（Execute）"></a>E级：执行（Execute）</h2><p>本级的输入为<code>D_PC</code>, <code>D_Instr</code>, <code>D_extres</code>, <code>D_gpr_rs</code>, <code>D_gpr_rt</code>。</p><p>本级的输出为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>, <code>E_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>D_fwd_gprrt</code>，和<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>参与流水。</p><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><p>详见<code>def.v</code>文件中的定义。</p><h3 id="E-MDU（乘除槽）"><a href="#E-MDU（乘除槽）" class="headerlink" title="E_MDU（乘除槽）"></a>E_MDU（乘除槽）</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>MDUOp[2:0]</td><td>I</td><td>指定乘除槽进行的操作</td></tr><tr><td>gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>start</td><td>I</td><td>指定乘除槽是否开始计算，高电平有效</td></tr><tr><td>busy</td><td>O</td><td>乘除槽是否处于运算过程中</td></tr><tr><td>HI[31:0]</td><td>O</td><td>32位HI寄存器值结果</td></tr><tr><td>LO[31:0]</td><td>O</td><td>32位LO寄存器值结果</td></tr></tbody></table><h4 id="控制信号-5"><a href="#控制信号-5" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>MDUOp</th><th>功能</th></tr></thead><tbody><tr><td><code>MDU_mult</code></td><td>乘法运算</td></tr><tr><td><code>MDU_div</code></td><td>除法运算</td></tr><tr><td><code>MDU_multu</code></td><td>无符号乘法运算</td></tr><tr><td><code>MDU_divu</code></td><td>无符号除法运算</td></tr><tr><td><code>MDU_mfhi</code></td><td><code>mfhi</code>指令</td></tr><tr><td><code>MDU_mflo</code></td><td><code>mflo</code>指令</td></tr><tr><td><code>MDU_mthi</code></td><td><code>mthi</code>指令，把<code>gpr_rs</code>的值赋给HI寄存器中</td></tr><tr><td><code>MDU_mtlo</code></td><td><code>mtlo</code>指令，把<code>gpr_rs</code>的值赋给LO寄存器中</td></tr></tbody></table><h3 id="E-M级流水线寄存器"><a href="#E-M级流水线寄存器" class="headerlink" title="E&#x2F;M级流水线寄存器"></a>E&#x2F;M级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>E_pc[31:0]</td><td>I</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>E_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>E_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>M_pc[31:0]</td><td>O</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>M_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="M级：存储器（Memory）"><a href="#M级：存储器（Memory）" class="headerlink" title="M级：存储器（Memory）"></a>M级：存储器（Memory）</h2><p>本级的输入为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>。</p><p>本级的输出为<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>, <code>M_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>M_fwd_gprrt</code>。</p><p>本机参与流水的有<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>。</p><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><p>本次实验只需要调用调用<code>mips_txt.v</code>中的接口即可，无需自行实现DM。</p><p>使用<code>fromRAM</code>模块处理DM返回的数据，使其符合写入寄存器的要求。</p><p>使用<code>toRAM</code>模块处理写入DM的数据，支持按照字、半字、字节的模式储存进DM。</p><h4 id="M-fromRAM"><a href="#M-fromRAM" class="headerlink" title="M_fromRAM"></a>M_fromRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行写操作的地址</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>m_data_rdata[31:0]</td><td>I</td><td>从<code>mips_txt.v</code>中的DM读出的数据</td></tr><tr><td>RD</td><td>O</td><td>处理后的正确的读取数据</td></tr></tbody></table><h4 id="M-toRAM"><a href="#M-toRAM" class="headerlink" title="M_toRAM"></a>M_toRAM</h4><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>进行读操作的地址</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td>读取的待处理的寄存器数据</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定模块进行的操作</td></tr><tr><td>MemWrite</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>m_data_byteen[3:0]</td><td>O</td><td>控制写入数据在DM中的位置</td></tr><tr><td>m_data_wdata[31:0]</td><td>O</td><td>处理后的正确的待写入数据</td></tr></tbody></table><h4 id="控制信号-6"><a href="#控制信号-6" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h4 id="与mips-txt-v交互-1"><a href="#与mips-txt-v交互-1" class="headerlink" title="与mips_txt.v交互"></a>与<code>mips_txt.v</code>交互</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] M_dmrd;<br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> m_data_addr = M_aluans;<br><br>toRAM M_Store(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.gpr_rt</span>(M_fwd_gprrt),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.MemWrite</span>(M_MemWrite),<br>    <span class="hljs-variable">.m_data_byteen</span>(m_data_byteen),<br>    <span class="hljs-variable">.m_data_wdata</span>(m_data_wdata)<br>);<br><br>fromRAM M_Load(<br>    <span class="hljs-variable">.A</span>(M_aluans),<br>    <span class="hljs-variable">.DMOp</span>(M_DMOp),<br>    <span class="hljs-variable">.m_data_rdata</span>(m_data_rdata),<br>    <span class="hljs-variable">.RD</span>(M_dmrd)<br>);<br><br><span class="hljs-keyword">assign</span> w_grf_wdata = W_grfWD;<br><span class="hljs-keyword">assign</span> w_inst_addr = W_PC;<br><span class="hljs-keyword">assign</span> w_grf_addr = W_A3Sel;<br></code></pre></td></tr></table></figure><h3 id="M-W级流水线寄存器"><a href="#M-W级流水线寄存器" class="headerlink" title="M&#x2F;W级流水线寄存器"></a>M&#x2F;W级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>M_pc[31:0]</td><td>I</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>M_dmrd[31:0]</td><td>I</td><td>从DM中读取的值</td></tr><tr><td>W_pc[31:0]</td><td>O</td><td>W级PC</td></tr><tr><td>W_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>W_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>W_dmrd[31:0]</td><td>O</td><td>从DM中读取的值</td></tr></tbody></table><h2 id="W级：写回（Writeback）"><a href="#W级：写回（Writeback）" class="headerlink" title="W级：写回（Writeback）"></a>W级：写回（Writeback）</h2><p>本级与D级是重合的，需要处理向E级和M级的转发。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>采用<strong>暴力转发</strong>的方式。由AT法的分析，不阻塞就意味着一定能够在使用该寄存器的值之前获得最新的且正确的值。因此采用暴力转发总能得到一个正确的值去覆盖原先错误的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// D级转发</span><br><span class="hljs-keyword">assign</span> D_fwd_gprrs = (D_rs == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rs == E_A3Sel) ? E_grfWD :<br>                    (D_rs == M_A3Sel) ? M_grfWD : D_gpr_rs;<br><br><span class="hljs-keyword">assign</span> D_fwd_gprrt = (D_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rt == E_A3Sel) ? E_grfWD :<br>                    (D_rt == M_A3Sel) ? M_grfWD : D_gpr_rt;<br><br><br><span class="hljs-comment">// E级转发</span><br><span class="hljs-keyword">assign</span> E_grfWD = (E_WDSel == `WDSel_PCa8) ? (E_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>; <span class="hljs-comment">// 不能对功能部件输出进行转发</span><br><span class="hljs-keyword">assign</span> E_fwd_gprrs = (E_rs == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rs == M_A3Sel) ? M_grfWD :<br>                    (E_rs == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rs;<br><br><span class="hljs-keyword">assign</span> E_fwd_gprrt = (E_rt == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rt == M_A3Sel) ? M_grfWD :<br>                    (E_rt == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rt;<br><br><br><span class="hljs-comment">// M级转发</span><br><span class="hljs-keyword">assign</span> M_grfWD = (M_WDSel == `WDSel_aluans) ? M_aluans :<br>                (M_WDSel == `WDSel_mduans) ? M_mduans :<br>                (M_WDSel == `WDSel_PCa8) ? (M_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br><span class="hljs-keyword">assign</span> M_fwd_gprrt = (M_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">5&#x27;d0</span>) :<br>                    (M_rt == W_A3Sel) ? W_grfWD :<br>                    M_gpr_rt;<br><br><br><span class="hljs-comment">// W级转发</span><br><span class="hljs-keyword">assign</span> W_grfWD = (W_WDSel == `WDSel_aluans) ? W_aluans :<br>                (W_WDSel == `WDSel_dmrd) ? W_dmrd :<br>                (W_WDSel == `WDSel_mduans) ? W_mduans :<br>                (W_WDSel == `WDSel_PCa8) ? (W_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>使用组合逻辑，判断每一级中指令的$Tuse$和$Tnew$。</p><p>如果有$Tuse$ &lt; $Tnew$，就执行阻塞。<strong>只可能在D级进行阻塞</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// stall_handle.v</span><br><span class="hljs-keyword">assign</span> D_Tuse_rs = (D_branch | D_j2r) ? <span class="hljs-number">3&#x27;d0</span> :<br>                (D_ic | D_rc | D_load | D_store | D_mt | D_md) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> D_Tuse_rt = (D_branch) ? <span class="hljs-number">3&#x27;d0</span> :<br>                    (D_rc | D_md) ? <span class="hljs-number">3&#x27;d1</span> :<br>                    (D_store) ? <span class="hljs-number">3&#x27;d2</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> E_Tnew = (E_rc | E_ic | E_mf) ? <span class="hljs-number">3&#x27;d1</span> :<br>                (E_load) ? <span class="hljs-number">3&#x27;d2</span> :<br>                <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> E_stall_rs = (E_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> E_stall_rt = (E_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> M_Tnew = (M_load) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> M_stall_rs = (M_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> M_stall_rt = (M_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt | E_stall_mdu;<br><br><br><span class="hljs-comment">// mips.v</span><br><span class="hljs-keyword">wire</span> stall;<br><span class="hljs-keyword">assign</span> FD_WE = !stall; <span class="hljs-comment">//冻结FD寄存器</span><br><span class="hljs-keyword">assign</span> IFU_WE = !stall; <span class="hljs-comment">//冻结PC</span><br><span class="hljs-keyword">assign</span> DE_flush = stall; <span class="hljs-comment">//清空DE寄存器</span><br><br><span class="hljs-keyword">assign</span> DE_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> EM_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> MW_WE = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">assign</span> FD_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> EM_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> MW_flush = <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>改进了P5的随机数据生成器，添加了延迟槽。</p><p>一个测试数据如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t4</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t5</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">jal </span>out<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span>,$<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-built_in">a1</span>,end<br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a2</span>,<span class="hljs-number">111</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-built_in">ra</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>为什么需要有单独的乘除法部件而不是整合进ALU？为何需要有独立的HI、LO寄存器？</p><p>乘除法的延迟远大于ALU，若整合进ALU，根据木桶原理，CPU整体周期将大幅增加。增加HI和LO寄存器可以让乘除法指令和其它指令并行执行，需要结果时再取出即可。</p></li><li><p>真实的流水线CPU是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p><p>乘法通常有若干个较小的组合逻辑的乘法单元组成，然后每个周期计算特定的几位，依次累加起来，于是会在几个周期后得到正确的最终结果；</p><p>除法通常使用试商法，通常也是使用组合逻辑在一个周期内计算4位左右的商，经过8个周期正好可以计算结束。</p></li><li><p>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p><p>当Busy信号或Start信号为 1 时，<code>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</code> 等乘除法相关的指令均被阻塞在 D 流水级。</p></li><li><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p><p>使用字节使能大幅度提高M级的效率，控制器提供控制信号，存储器决定最终存储地址，使得每个模块的功能更加清晰。</p></li><li><p>请思考，我们在按字节读和按字节写时，实际从DM获得的数据和向DM写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p><p>不是，读取到的是DM所在字的数据。只实现按字使能，就不得不先读取值再进行更改，这样数据通路就延长了，导致效率下降。</p><p>访问类型只占一个字节时，比如C语言中的<code>char</code>类型，按字节访问内存相对于按字访问内存性能上更有优势。</p></li><li><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p><p>将指令集按照一定的规则进行分类。P6完全沿用了 P5 的分类方法，新增的指令对应的特点都没有脱离这些分类，因此对于每条指令而言，只需译码后将其加入对应的分类。相同的类别在译码上有共同的结果，可以避免偶然错误。转发部分完全不用改，暂停部分只需添加一个因乘除块而导致的暂停。</p></li><li><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>P6比P5增加了乘除槽的冲突，在进行乘除指令后紧接着立即执行mfhi或mflo会造成数据冲突。此时应进行阻塞，直到乘除指令执行完成为止。</p><p>构造样例如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t0</span>,<span class="hljs-number">0x0123</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t2</span>,<span class="hljs-number">0xffff</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t0</span>,<span class="hljs-number">0x9576</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t1</span>,<span class="hljs-number">0xa312</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s1</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s1</span><br><span class="hljs-keyword">multu </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s1</span><br></code></pre></td></tr></table></figure></li><li><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</p><p>新增冲突只有一条，所以构造上述测试样例足够。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>试题</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P5 - 流水线CPU设计文档</title>
    <link href="/2023/11/13/P5-%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/13/P5-%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P5-流水线CPU设计文档"><a href="#P5-流水线CPU设计文档" class="headerlink" title="P5 流水线CPU设计文档"></a>P5 流水线CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li>设计的处理器为32位五级流水线处理器</li><li>处理器支持的指令集为<code>add, sub, ori, lw, sw, beq, lui, addi, nop，j，jal，jr，lb，sb，lh，sh</code>等</li><li><code>add, sub</code>按无符号加减法处理，不考虑溢出</li></ul><p>整体架构参考了《数字设计与计算机体系结构》图7-58。</p><p><img src="https://pic.imgdb.cn/item/654cc27dc458853aef789452.png" alt="整体架构"></p><h2 id="F级：取指令（Fetch）"><a href="#F级：取指令（Fetch）" class="headerlink" title="F级：取指令（Fetch）"></a>F级：取指令（Fetch）</h2><p>本级的输入为来自D级的<code>next_pc</code>，用于更新下一个PC的值。</p><p>本级的输出为<code>F_PC</code>和<code>F_Instr</code>，分别对应从F级指令的PC和F级指令的内容，均需要参与流水。</p><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>enable</td><td>I</td><td>PC写使能信号，高电平有效</td></tr><tr><td>next_pc[31:0]</td><td>I</td><td>待更新的指令地址</td></tr><tr><td>pc[31:0]</td><td>O</td><td>当前指令地址</td></tr><tr><td>instr[31:0]</td><td>O</td><td>当前PC对应的32位指令</td></tr></tbody></table><h3 id="F-D级流水线寄存器"><a href="#F-D级流水线寄存器" class="headerlink" title="F&#x2F;D级流水线寄存器"></a>F&#x2F;D级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>F_pc[31:0]</td><td>I</td><td>F级PC</td></tr><tr><td>F_instr[31:0]</td><td>I</td><td>时钟信号</td></tr><tr><td>D_pc[31:0]</td><td>O</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>O</td><td>32位的指令值</td></tr></tbody></table><h2 id="D级：译码（Decode）"><a href="#D级：译码（Decode）" class="headerlink" title="D级：译码（Decode）"></a>D级：译码（Decode）</h2><p>本级的输入为来自F级的<code>F_PC</code>和<code>F_Instr</code>。</p><p>本级的输出为<code>D_gpr_rs</code>, <code>D_gpr_rt</code>, <code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>和<code>next_pc</code>。</p><p>本级涉及到来自E级、M级、W级的转发，其中来自W级的转发通过<strong>GRF内部转发</strong>的方式实现。</p><p><code>$rs</code>和<code>$rt</code>的值在本级转发成<code>D_fwd_gprrs</code>和<code>D_fwd_gprrt</code>，和<code>D_extres</code>, <code>D_PC</code>, <code>D_Instr</code>参与流水。</p><p>本级需要对<strong>此级指令</strong>的$$Tuse$$和此时<strong>E级</strong>指令与<strong>M级指令</strong>的$Tnew$进行比较，从而确定是否执行阻塞。</p><blockquote><p>$Tuse$和$Tnew$:</p><ul><li><p>$Tuse$表示这条指令位于D级的时候，再经过多少个时钟周期就必须要使用相应的数据。</p><ul><li>每个指令的$Tuse$是固定不变的</li><li>一个指令可以有两个$Tuse$值</li></ul></li><li><p>$Tnew$表示位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。</p><ul><li>$Tnew$是一个动态值，每个指令处于流水线不同阶段有不同的$Tnew$值</li><li>一个指令在一个时刻至多有一个$Tnew$值（一个指令至多写一个寄存器）</li></ul></li><li><p>当$Tuse$ &gt;&#x3D; $Tnew$，说明需要的数据可以及时算出，可以通过<strong>转发</strong>来解决</p><p>当$Tuse$ &lt; $Tnew$，说明需要的数据不能及时算出，必须<strong>阻塞</strong>流水线解决</p></li></ul></blockquote><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><blockquote><ul><li>如果不需要写寄存器，只需要把A3Sel设为0即可。</li><li>此处<strong>WPC</strong>和<strong>WD</strong>均来自<strong>W级</strong>。</li></ul></blockquote><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa8</td><td>WD为<strong>当前流水线层级的PC</strong> + 8</td></tr></tbody></table><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_pc[31:0]</td><td>I</td><td>当前F级PC的值</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>当前D级PC的值</td></tr><tr><td>PCSel[1:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>branch</td><td>I</td><td>branch类型指令<strong>是否达到跳转条件</strong>，高电平有效</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即D_Instr[25:0]</td></tr><tr><td>offset[15:0]</td><td>I</td><td>branch类型指令的偏移量，即D_Instr[15:0]</td></tr><tr><td>ra[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器保存的地址值</td></tr><tr><td>next_pc[31:0]</td><td>O</td><td>下一指令的PC</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- GPR[rs]</td></tr></tbody></table><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>gpr_rs[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rs</code>寄存器中的值</td></tr><tr><td>gpr_rt[31:0]</td><td>I</td><td><strong>完成转发后</strong><code>$rt</code>寄存器中的值</td></tr><tr><td>CMPOp[1:0]</td><td>I</td><td>指定比较数据的方式</td></tr><tr><td>flag</td><td>O</td><td>是否满足所设条件，高电平有效</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>CMPOp</th><th>操作</th></tr></thead><tbody><tr><td>CMP_beq</td><td>beq指令: 若<code>GPR[rs] == GPR[rt]</code>，则flag置1，否则置0</td></tr></tbody></table><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="D-E级流水线寄存器"><a href="#D-E级流水线寄存器" class="headerlink" title="D&#x2F;E级流水线寄存器"></a>D&#x2F;E级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>D_pc[31:0]</td><td>I</td><td>D级PC</td></tr><tr><td>D_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>D_extres[31:0]</td><td>I</td><td>16位立即数扩展的结果</td></tr><tr><td>D_gpr_rs[31:0]</td><td>I</td><td>GPR[rs]</td></tr><tr><td>D_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>E_pc[31:0]</td><td>O</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>E_gpr_rs[31:0]</td><td>O</td><td>GPR[rs]</td></tr><tr><td>E_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="E级：执行（Execute）"><a href="#E级：执行（Execute）" class="headerlink" title="E级：执行（Execute）"></a>E级：执行（Execute）</h2><p>本级的输入为<code>D_PC</code>, <code>D_Instr</code>, <code>D_extres</code>, <code>D_gpr_rs</code>, <code>D_gpr_rt</code>。</p><p>本级的输出为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>, <code>E_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>D_fwd_gprrt</code>，和<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>参与流水。</p><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>ALUOp</th><th>操作</th></tr></thead><tbody><tr><td>ALU_add</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_sub</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_or</td><td>result &#x3D; A | B</td></tr><tr><td>ALU_lui</td><td>result &#x3D; B | 10<sup>16</sup></td></tr></tbody></table><h3 id="E-M级流水线寄存器"><a href="#E-M级流水线寄存器" class="headerlink" title="E&#x2F;M级流水线寄存器"></a>E&#x2F;M级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>E_pc[31:0]</td><td>I</td><td>E级PC</td></tr><tr><td>E_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>E_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>E_gpr_rt[31:0]</td><td>I</td><td>GPR[rt]</td></tr><tr><td>M_pc[31:0]</td><td>O</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>M_gpr_rt[31:0]</td><td>O</td><td>GPR[rt]</td></tr></tbody></table><h2 id="M级：存储器（Memory）"><a href="#M级：存储器（Memory）" class="headerlink" title="M级：存储器（Memory）"></a>M级：存储器（Memory）</h2><p>本级的输入为<code>E_PC</code>, <code>E_Instr</code>, <code>E_aluans</code>, <code>E_gpr_rt</code>。</p><p>本级的输出为<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>, <code>M_grfWD</code>。</p><p>本级涉及到来自M级、W级的转发，<code>$rt</code>的值在本级转发得<code>M_fwd_gprrt</code>。</p><p>本机参与流水的有<code>M_PC</code>, <code>M_Instr</code>, <code>M_aluans</code>, <code>M_dmrd</code>。</p><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>WE</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>A[31:0]</td><td>I</td><td>需要进行读&#x2F;写操作的地址</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位写入RAM的数据</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定DM进行的读&#x2F;写操作方式</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入DM时对应的指令PC值</td></tr><tr><td>RD[31:0]</td><td>O</td><td>32位从RAM读出的输出数据</td></tr></tbody></table><h4 id="控制信号-5"><a href="#控制信号-5" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h3 id="M-W级流水线寄存器"><a href="#M-W级流水线寄存器" class="headerlink" title="M&#x2F;W级流水线寄存器"></a>M&#x2F;W级流水线寄存器</h3><table><thead><tr><th>信号名</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>flush</td><td>I</td><td>寄存器刷新信号，高电平有效，发生阻塞时使用</td></tr><tr><td>enable</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>M_pc[31:0]</td><td>I</td><td>M级PC</td></tr><tr><td>M_instr[31:0]</td><td>I</td><td>32位指令值</td></tr><tr><td>M_aluans[31:0]</td><td>I</td><td>ALU的运算结果</td></tr><tr><td>M_dmrd[31:0]</td><td>I</td><td>从DM中读取的值</td></tr><tr><td>W_pc[31:0]</td><td>O</td><td>W级PC</td></tr><tr><td>W_instr[31:0]</td><td>O</td><td>32位指令值</td></tr><tr><td>W_aluans[31:0]</td><td>O</td><td>ALU的运算结果</td></tr><tr><td>W_dmrd[31:0]</td><td>O</td><td>从DM中读取的值</td></tr></tbody></table><h2 id="W级：写回（Writeback）"><a href="#W级：写回（Writeback）" class="headerlink" title="W级：写回（Writeback）"></a>W级：写回（Writeback）</h2><p>本级与D级是重合的，需要处理向E级和M级的转发。</p><h2 id="控制信号-6"><a href="#控制信号-6" class="headerlink" title="控制信号"></a>控制信号</h2><p>采用分布式译码的方式，在每一级对指令译码生成控制信号</p><table><thead><tr><th align="center"></th><th align="center">opcode</th><th align="center">funct</th><th align="center">A3Sel</th><th align="center">ALUOp</th><th align="center">ALUBSel</th><th align="center">WDSel</th><th align="center">MemWrite</th><th align="center">PCSel</th><th align="center">EXTOp</th><th align="center">DMOp</th></tr></thead><tbody><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td><td align="center">rd</td><td align="center">ALU_add</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td><td align="center">rd</td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_or</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center"></td><td align="center"></td><td align="center">PCSel_branch</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_lui</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">j</td><td align="center">000010</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jal</td><td align="center">000011</td><td align="center"><strong>undefined</strong></td><td align="center">ra</td><td align="center"></td><td align="center"></td><td align="center">WDSel_PCa4</td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jr</td><td align="center">001000</td><td align="center">001000</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_jr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lb</td><td align="center">100000</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">sb</td><td align="center">101000</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">lh</td><td align="center">100001</td><td align="center"><strong>undefined</strong></td><td align="center">rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr><tr><td align="center">sh</td><td align="center">101001</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr></tbody></table><blockquote><p> A3Sel一列缺省值为5’d0，PCSel一列缺省值为PCSel_PCa8</p></blockquote><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>采用<strong>暴力转发</strong>的方式。由AT法的分析，不阻塞就意味着一定能够在使用该寄存器的值之前获得最新的且正确的值。因此采用暴力转发总能得到一个正确的值去覆盖原先错误的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// D级转发</span><br><span class="hljs-keyword">assign</span> D_fwd_gprrs = (D_rs == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rs == E_A3Sel) ? E_grfWD :<br>                    (D_rs == M_A3Sel) ? M_grfWD : D_gpr_rs;<br><br><span class="hljs-keyword">assign</span> D_fwd_gprrt = (D_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">32&#x27;d0</span>) : <br>                    (D_rt == E_A3Sel) ? E_grfWD :<br>                    (D_rt == M_A3Sel) ? M_grfWD : D_gpr_rt;<br><br><br><span class="hljs-comment">// GRF内部转发</span><br><span class="hljs-keyword">assign</span> RD1 = (A1 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A1 == A3) ? WD : registers[A1];<br><span class="hljs-keyword">assign</span> RD2 = (A2 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A2 == A3) ? WD : registers[A2];<br><br><br><span class="hljs-comment">// E级转发</span><br><span class="hljs-keyword">assign</span> E_grfWD = (E_WDSel == `WDSel_PCa8) ? (E_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>; <span class="hljs-comment">// 不能对功能部件输出进行转发</span><br><span class="hljs-keyword">assign</span> E_fwd_gprrs = (E_rs == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rs == M_A3Sel) ? M_grfWD :<br>                    (E_rs == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rs;<br><br><span class="hljs-keyword">assign</span> E_fwd_gprrt = (E_rt == <span class="hljs-number">5&#x27;d0</span>) ? <span class="hljs-number">32&#x27;d0</span> :<br>                    (E_rt == M_A3Sel) ? M_grfWD :<br>                    (E_rt == W_A3Sel) ? W_grfWD :<br>                    E_gpr_rt;<br><br><br><span class="hljs-comment">// M级转发</span><br><span class="hljs-keyword">assign</span> M_grfWD = (M_WDSel == `WDSel_aluans) ? M_aluans :<br>                (M_WDSel == `WDSel_PCa8) ? (M_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br><span class="hljs-keyword">assign</span> M_fwd_gprrt = (M_rt == <span class="hljs-number">5&#x27;d0</span>) ? (<span class="hljs-number">5&#x27;d0</span>) :<br>                    (M_rt == W_A3Sel) ? W_grfWD :<br>                    M_gpr_rt;<br><br><br><span class="hljs-comment">// W级转发</span><br><span class="hljs-keyword">assign</span> W_grfWD = (W_WDSel == `WDSel_aluans) ? W_aluans :<br>                (W_WDSel == `WDSel_dmrd) ? W_dmrd :<br>                (W_WDSel == `WDSel_PCa8) ? (W_PC + <span class="hljs-number">8</span>) : <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>使用组合逻辑，判断每一级中指令的$Tuse$和$Tnew$。</p><p>如果有$Tuse$ &lt; $Tnew$，就执行阻塞。<strong>只可能在D级进行阻塞</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// stall_handle.v</span><br><span class="hljs-keyword">assign</span> D_Tuse_rs = (D_branch | D_j2r) ? <span class="hljs-number">3&#x27;d0</span> :<br>                (D_ic | D_rc | D_load | D_store) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> D_Tuse_rt = (D_branch) ? <span class="hljs-number">3&#x27;d0</span> :<br>                    (D_rc) ? <span class="hljs-number">3&#x27;d1</span> :<br>                    (D_store) ? <span class="hljs-number">3&#x27;d2</span> : <span class="hljs-number">3&#x27;d3</span>;<br><br><span class="hljs-keyword">assign</span> E_Tnew = (E_rc | E_ic) ? <span class="hljs-number">3&#x27;d1</span> :<br>                (E_load) ? <span class="hljs-number">3&#x27;d2</span> :<br>                <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> E_stall_rs = (E_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> E_stall_rt = (E_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (E_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> M_Tnew = (M_load) ? <span class="hljs-number">3&#x27;d1</span> : <span class="hljs-number">3&#x27;d0</span>;<br><br><span class="hljs-keyword">assign</span> M_stall_rs = (M_A3Sel == D_rs &amp;&amp; D_rs != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rs);<br><span class="hljs-keyword">assign</span> M_stall_rt = (M_A3Sel == D_rt &amp;&amp; D_rt != <span class="hljs-number">5&#x27;d0</span>) &amp;&amp; (M_Tnew &gt; D_Tuse_rt);<br><br><span class="hljs-keyword">assign</span> stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt;<br><br><br><span class="hljs-comment">// mips.v</span><br><span class="hljs-keyword">wire</span> stall;<br><span class="hljs-keyword">assign</span> FD_WE = !stall; <span class="hljs-comment">//冻结FD寄存器</span><br><span class="hljs-keyword">assign</span> IFU_WE = !stall; <span class="hljs-comment">//冻结PC</span><br><span class="hljs-keyword">assign</span> DE_flush = stall; <span class="hljs-comment">//清空DE寄存器</span><br><br><span class="hljs-keyword">assign</span> DE_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> EM_WE = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> MW_WE = <span class="hljs-number">1&#x27;b1</span>;<br><br><span class="hljs-keyword">assign</span> FD_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> EM_flush = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> MW_flush = <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>改进了P4的随机数据生成器，添加了延迟槽。</p><p>一个测试数据如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">3</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t4</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t5</span>,$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t2</span><br><span class="hljs-keyword">jal </span>out<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span>,$<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">a0</span>,$<span class="hljs-built_in">a1</span>,end<br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a2</span>,<span class="hljs-number">111</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-built_in">ra</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p><p>branch类型的$Tuse$为0，很可能产生$Tnew$ &gt; $Tuse$，从而产生堵塞</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-number">8</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">9</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x2</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">8</span>, $<span class="hljs-number">9</span>, L1<br></code></pre></td></tr></table></figure></li><li><p>因为延迟槽的存在，对于jal等需要将指令地址写入寄存器的指令，要写回PC + 8，请思考为什么这样设计？</p><p>jal的后一条指令处于延迟槽中，无论判断结果如何，都将执行分支或跳转指令的下一条指令。</p><p>如果写回PC + 4，那么执行<code>jr $ra</code>时，将会跳回到延迟槽的指令，导致其被重复执行。</p></li><li><p>我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如DM、ALU），请思考为什么？</p><p>会造成关键路径变长，使得流水线各部分延迟不均衡，产生“木桶效应”使流水线性能严重下降。</p><p>假设有DM到ALU输入的转发，那么修改之后，E级的周期将从原来的<code>ALU延迟</code>变为<code>ALU延迟 + DM延迟</code>，降低了时间频率。</p></li><li><p>我们为什么要使用 GPR 内部转发？该如何实现？</p><p>使得W级将要写入的数据及时反馈到GRF的输出端口，在一个时间周期内完成写和读，解决“写后读”冲突。</p><p>实现方法为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> RD1 = (A1 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A1 == A3) ? WD : registers[A1];<br><span class="hljs-keyword">assign</span> RD2 = (A2 == <span class="hljs-number">5&#x27;b00000</span>) ? <span class="hljs-number">32&#x27;h0000_0000</span> :<br>            (A2 == A3) ? WD : registers[A2];<br></code></pre></td></tr></table></figure></li><li><p>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p><p>见“转发”部分。</p></li><li><p>在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p><p>增加的指令主要分为三种类型：<strong>计算、跳转、存储</strong>。</p><p>计算指令的处理步骤</p><ul><li>修改ALU支持新的运算，感觉用<code>always @(*)</code>块比用<code>assign</code>写起来方便，善用<code>function</code>模块</li><li>$Tuse$和$Tnew$与<code>calc_rc</code>（R型计算指令）保持一致</li></ul><p>跳转指令的处理步骤</p><ul><li>前几个P遇到过的跳转类指令有<code>条件跳转+无条件链接</code>，<code>条件跳转+条件链接</code>，<code>条件跳转+（无）条件链接+不跳转时清空延迟槽</code></li><li>条件跳转：只增加CMP中的判断方法</li><li>链接：无条件链接直接将A3Sel设为31，与jal类似；对于有条件链接，将CMP中的flag信号进行流水，在controller里判断<code>A3Sel = (link &amp;&amp; flag) ? 31 : 0</code>，每一级根据这个信号判断写入操作，生成控制信号时可以视作<code>branch</code>和<code>jr</code>的“混合体”。</li><li>清空延迟槽，从CMP中引出信号，置1则表示<strong>发生比较</strong>且<strong>未达到跳转条件</strong>，信号名为<code>flush_flag</code>，然后<code>assign FD_flush = (flush_flag &amp;&amp; !stall)</code>。stall有效说明此时传入CMP的值的最新版本暂未计算出来，无法转发。</li></ul><p>存储指令的处理步骤</p><ul><li>前几个P遇到过的存储指令常常涉及到<code>条件存储</code>的问题，到M级才知道需要写什么</li><li>如果D级要读寄存器，而且条件存储的指令可能要写相同编号的寄存器，那么就阻塞一个周期</li></ul><p>修改通路的时候记得配合<code>def.v</code>相关宏定义的修改。</p></li><li><p>确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p><p>我采用的是分布式译码器。</p><p>该架构的<strong>优势</strong>在于不需要将控制信号流水传递，只需要流水传递指令，在每一级再译码即可。这样做降低了流水线需要传递的信号量，也避免了因为忘记流水某个信号而产生的错误。</p><p>但是，分布式译码需要在每一级都实例化一个控制器，每级都有端口闲置造成浪费，同时会增加后续流水级的逻辑复杂度。从实际应用的角度来看，使用多个控制器会增长关键路径，降低了流水线运行效率，原因与问题3相类似。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>试题</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>462OJ搭建分享-输出结果评判</title>
    <link href="/2023/11/07/462OJ%E6%90%AD%E5%BB%BA%E5%88%86%E4%BA%AB-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%AF%84%E5%88%A4/"/>
    <url>/2023/11/07/462OJ%E6%90%AD%E5%BB%BA%E5%88%86%E4%BA%AB-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%AF%84%E5%88%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有幸和zlr同学、lpf同学合作开发了462OJ1<sup>st</sup>项目。</p><p>作为一款OJ，最重要的功能就是评判用户程序的输出与期望输出是否一致。这当中就涉及到了两个需求：</p><ul><li>生成期望输出</li><li>将期望输出与用户输出进行比较</li></ul><p>这里就简单分享一下项目中，这两个需求是怎么实现的。</p><p><del>与另外两个人的工作相比，这个工作是最简单的</del></p><h1 id="生成期望输出"><a href="#生成期望输出" class="headerlink" title="生成期望输出"></a>生成期望输出</h1><p>项目当中使用了<code>Toby Shi</code>学长的魔改版Mars，通过命令行执行得到期望输出。</p><p>可以利用python的os库实现这一功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">command = <span class="hljs-string">&quot;java -jar mars.jar temp.asm mc CompactLargeText coL1 ig&quot;</span> <br><span class="hljs-comment"># test.asm包含随机生成的测试点源码</span><br><span class="hljs-keyword">with</span> os.popen(command) <span class="hljs-keyword">as</span> f:<br>     answer = f.readlines()<br></code></pre></td></tr></table></figure><p>os.popen(command)：这种调用方式是通过管道的方式来实现，函数返回一个file对象，里面的内容是脚本输出的内容，可简单理解为echo输出的内容。</p><p>当然，有时候生成的随机数据点会存在一些问题，此时Mars的输出就会带有<code>Error</code>，此时我们就在answer里捕捉Error即可。</p><p>与此同时，也可以利用Mars生成相应的机器码，供<code>.v</code>文件执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">command = <span class="hljs-string">&quot;java -jar mars.jar a mc CompactLargeText dump .text HexText tempcode.txt temp.asm&quot;</span><br>f = os.popen(command)<br>f.close()<br></code></pre></td></tr></table></figure><h1 id="比较输出"><a href="#比较输出" class="headerlink" title="比较输出"></a>比较输出</h1><p>这里用到了python中的<code>difflib</code>库。</p><p><del>我才知道difflib是标准库</del></p><p>difflib可以对比文本之间的差异，并且支持输出可读性比较强的HTML文档，与Linux下的diff命令相似。</p><table><thead><tr><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>splitlines()</td><td>按照行(’\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符</td></tr><tr><td>d.compare(a,b)</td><td>比较两个行序列，并生成delta（一系列行）</td></tr><tr><td>difflib.HtmlDiff()</td><td>可以用于创建一个完整HTML文件，该文件显示具有行间和行内更改突出的文本的逐行比较</td></tr><tr><td>d.make_file(text1,text2)</td><td>比较两个字符串列表并返回一个字符串，该字符串是一个完整的HTML文件，其中包含一个表格，显示逐行差异，突出显示行间和行内更改</td></tr><tr><td>difflib.SequenceMatcher(None, s1, s2).ratio()</td><td>None参数是一个函数，用来去掉不需要比较的字符。<br>s1,s2参数为两个需要计算相似度的字符串。<br>函数返回值是0~1之间的一个浮点数，如果为1则认为完全相等</td></tr></tbody></table><p>最终的文本当中会出现一系列标识符，他们的含义如下。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>‘-’</td><td>包含在第一个系列行中，但不包含第二个</td></tr><tr><td>‘+’</td><td>包含在第二个系列行中，但不包含第一个</td></tr><tr><td>’ ’</td><td>两个系列行一致</td></tr><tr><td>‘?’</td><td>存在增量差异</td></tr><tr><td>‘^’</td><td>存在差异字符</td></tr></tbody></table><h2 id="实现文本对比"><a href="#实现文本对比" class="headerlink" title="实现文本对比"></a>实现文本对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> difflib<br>text1 = <span class="hljs-string">&#x27;&#x27;&#x27;  1. Beautiful is better than ugly.</span><br><span class="hljs-string">       2. Explicit is better than implicit.</span><br><span class="hljs-string">       3. Simple is better than complex.</span><br><span class="hljs-string">       4. Complex is better than complicated.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br>text2 = <span class="hljs-string">&#x27;&#x27;&#x27;  1. Beautiful is better than ugly.</span><br><span class="hljs-string">       3.   Simple is better than complex.</span><br><span class="hljs-string">       4. Complicated is better than complex.</span><br><span class="hljs-string">       5. Flat is better than nested.</span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br><br>d = difflib.Differ()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">list</span>(d.compare(text1,text2))))<br></code></pre></td></tr></table></figure><h2 id="使用html对比"><a href="#使用html对比" class="headerlink" title="使用html对比"></a>使用html对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> difflib<br>text1 = <span class="hljs-string">&#x27;&#x27;&#x27;  </span><br><span class="hljs-string">       1. Beautiful is better than gly.</span><br><span class="hljs-string">       2. Explicit is better than implicit.</span><br><span class="hljs-string">       3. Simple is better than complex.</span><br><span class="hljs-string">       4. Complex is better than complicated.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br>text2 = <span class="hljs-string">&#x27;&#x27;&#x27;  </span><br><span class="hljs-string">       1. Beautiful is better than ugly.</span><br><span class="hljs-string">       3. Simple is better than complex.</span><br><span class="hljs-string">       4. Complicated is beter than complex.</span><br><span class="hljs-string">       5. Flat is better than nested.</span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>.splitlines(keepends=<span class="hljs-literal">True</span>)<br><br>d = difflib.HtmlDiff()<br>htmlContent = d.make_file(text1,text2)<br><span class="hljs-comment"># print(htmlContent)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;diff.html&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(htmlContent)<br></code></pre></td></tr></table></figure><p>输出的结果为：<br><img src="https://pic.imgdb.cn/item/6549bac6c458853aefaef147.png" alt="输出结果"></p><p><code>difflib</code>库中的内容还有很多，欢迎大家前去探索！</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P4 - 单周期CPU设计文档</title>
    <link href="/2023/11/06/P4-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/06/P4-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P4-单周期CPU设计文档"><a href="#P4-单周期CPU设计文档" class="headerlink" title="P4 单周期CPU设计文档"></a>P4 单周期CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li>设计的处理器为32位单周期处理器</li><li>处理器支持的指令集为<code>add, sub, ori, lw, sw, beq, lui, nop，j，jal，jr，lb，sb，lh，sh</code>等</li><li><code>nop</code>为空指令，其机器码为<code>0x00000000</code>，不进行任何有效行为，如修改寄存器等</li><li><code>add, sub</code>按无符号加减法处理，不考虑溢出</li></ul><p>整体架构参考了《数字设计与计算机体系结构》图7-14，同时在P3的Logisim电路设计上进行了改动。</p><p><img src="https://pic.imgdb.cn/item/653fb286c458853aef8839f2.png" alt="《数字设计与计算机体系结构》图7-14"></p><p><img src="https://pic.imgdb.cn/item/653fb2e7c458853aef8a3714.png" alt="P3 Logisim电路设计概览"></p><h2 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Control signals of GRF are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> A3Sel_rt 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> A3Sel_rd 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> A3Sel_ra 2&#x27;b10</span><br><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WDSel_aluans 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WDSel_dmrd 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WDSel_PCa4 2&#x27;b10</span><br><br><br><span class="hljs-comment">// Control signals of IFU are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_PCa4 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_branch 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_j 2&#x27;b10</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> PCSel_jr 2&#x27;b11</span><br><br><br><span class="hljs-comment">// Control signals of ALU are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_add 3&#x27;b000</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_sub 3&#x27;b001</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_or 3&#x27;b010</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALU_lui 3&#x27;b011</span><br><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALUBSel_grf 1&#x27;b0</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> ALUBSel_imm 1&#x27;b1</span><br><br><br><span class="hljs-comment">// Control signal of EXT are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> EXT_zero 1&#x27;b0</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> EXT_signed 1&#x27;b1</span><br><br><br><span class="hljs-comment">// Control signal of DM are defined here.</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> DM_word 2&#x27;b00</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> DM_halfword 2&#x27;b01</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> DM_byte 2&#x27;b10</span><br></code></pre></td></tr></table></figure><h3 id="IFU"><a href="#IFU" class="headerlink" title="IFU"></a>IFU</h3><p>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</p><p>PC 用寄存器实现，应具有<strong>同步复位</strong>功能，复位值为起始地址。</p><p><strong>起始地址：0x00003000。</strong></p><p>地址范围：0x00003000 ~ 0x00006FFF。</p><p>IM用ROM实现，容量为4096 × 32bit。</p><p>IM实际地址宽度仅为12位，需要使用恰当的方法将PC中储存的地址同IM联系起来。</p><blockquote><p>PC的处理方法：</p><ul><li>PC的变化范围为0x00003000 ~ 0x00006FFF，考虑使用PC<sup>‘</sup> &#x3D; PC - 0x00003000，则PC<sup>‘</sup>的范围为0x00000000-0x00003FFF，不仅保证PC和PC<sup>‘</sup>在数值上一一对应，而且在设计处理时更加方便。</li><li>注意，输出是需要输出PC的值，而不是PC<sup>‘</sup>。</li><li>IM的实际地址宽度为12位，而PC的有效位数（可能发生变化的位数）为低14位。因为ROM是按字寻址，在从IM读取指令时只需要用PC[13:2]作为地址，就可以正确读取数据。</li></ul></blockquote><h4 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效，将PC置为0x0000_3000</td></tr><tr><td>PCSel[2:0]</td><td>I</td><td>指定更新PC的方式</td></tr><tr><td>offset[15:0]</td><td>I</td><td>beq等branch指令的偏移量，即Instr[15:0]</td></tr><tr><td>imm[25:0]</td><td>I</td><td>j指令和jal指令中的立即数，即Instr[25:0]</td></tr><tr><td>jr_reg[31:0]</td><td>I</td><td>jr指令中指定寄存器所储存的数</td></tr><tr><td>PC[31:0]</td><td>O</td><td>输出当前PC的值</td></tr><tr><td>PCa4[31:0]</td><td>O</td><td>输出当前PC加上0x0000_0004的值</td></tr><tr><td>Instr[31:0]</td><td>O</td><td>输出IM中PC地址上的指令</td></tr></tbody></table><h4 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>同步复位</td><td>reset置1，且时钟上升沿来临时，将PC置为0x0000_3000</td></tr><tr><td>2</td><td>更新PC的值</td><td>时钟上升沿来临时，根据<strong>PCSel</strong>的值更新PC的值</td></tr></tbody></table><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>PCSel</th><th>操作</th></tr></thead><tbody><tr><td>PCSel_PCa4</td><td>PC &lt;- PC + 4</td></tr><tr><td>PCSel_branch</td><td>PC &lt;- PC + 4 + sign_extend(offset||0<sup>2</sup>&gt;)</td></tr><tr><td>PCSel_j</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup></td></tr><tr><td>PCSel_jr</td><td>PC &lt;- PC[31:28] || imm || 0<sup>2</sup><br>GPR[31] &lt;- PC + 4</td></tr></tbody></table><h3 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h3><p>使用<strong>具有写使能功能</strong>的寄存器实现，寄存器总数为<strong>32个</strong>，具有<strong>异步复位</strong>功能。</p><p>其中，<strong>0号寄存器</strong>($zero)的值始终保持为0。其他的寄存器<strong>初始值(复位后)均为0</strong>，无需专门设置。</p><h4 id="端口定义-1"><a href="#端口定义-1" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>WE</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32为数据输入信号</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入寄存器时对应的指令PC值</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table><h4 id="功能定义-1"><a href="#功能定义-1" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>reset置1，且时钟上升沿来临时，所有寄存器存储的数值清零</td></tr><tr><td>2</td><td>读数据</td><td>读出A1，A2地址对应寄存器中所存储的数据到对应的RD1，RD2</td></tr><tr><td>3</td><td>写数据</td><td>当WE有效且时钟上升沿来临时，将WD写入A3所对应的寄存器中</td></tr></tbody></table><h4 id="控制信号-1"><a href="#控制信号-1" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>A3Sel</th><th>操作</th></tr></thead><tbody><tr><td>A3Sel_rt</td><td>A3来自rt字段，对应I型指令</td></tr><tr><td>A3Sel_rd</td><td>A3来自rd字段，对应I型指令</td></tr><tr><td>A3Sel_ra</td><td>A3为$ra，对应jal指令</td></tr></tbody></table><table><thead><tr><th>WDSel</th><th>操作</th></tr></thead><tbody><tr><td>WDSel_aluans</td><td>WD来自ALU的运算结果</td></tr><tr><td>WDSel_dmrd</td><td>WD来自DM的输出RD</td></tr><tr><td>WDSel_PCa4</td><td>WD为PC + 4</td></tr></tbody></table><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>提供 32 位加、减、或运算及大小比较功能。</p><p>加减法按无符号处理（不考虑溢出）。</p><h4 id="端口定义-2"><a href="#端口定义-2" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>B[31:0]</td><td>I</td><td>32位运算数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>指定ALU进行的计算</td></tr><tr><td>zero</td><td>O</td><td>输出A - B的结果是否为0</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位运算结果</td></tr></tbody></table><h4 id="功能定义-2"><a href="#功能定义-2" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>运算</td><td>根据ALUOp指定的操作对A和B进行运算</td></tr></tbody></table><h4 id="控制信号-2"><a href="#控制信号-2" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>ALUOp</th><th>操作</th></tr></thead><tbody><tr><td>ALU_add</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_sub</td><td>result &#x3D; A + B，不考虑溢出</td></tr><tr><td>ALU_or</td><td>result &#x3D; A | B</td></tr><tr><td>ALU_lui</td><td>result &#x3D; B | 10<sup>16</sup></td></tr></tbody></table><table><thead><tr><th>ALUBSel</th><th>操作</th></tr></thead><tbody><tr><td>ALUBSel_grf</td><td>ALU的第二个运算数来自GRF</td></tr><tr><td>ALUBSel_imm</td><td>ALU的第二个运算数来自立即数</td></tr></tbody></table><h3 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h3><p>使用RAM实现，容量为3072 × 32bit，应具有<strong>同步复位</strong>功能，复位值为0x00000000。</p><p><strong>起始地址：0x00000000</strong>。</p><p>地址范围：0x00000000 ~ 0x00002FFF。</p><h4 id="端口定义-3"><a href="#端口定义-3" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>同步</strong>复位信号，高电平有效</td></tr><tr><td>A[31:0]</td><td>I</td><td>需要进行读&#x2F;写操作的地址</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位写入RAM的数据</td></tr><tr><td>WE</td><td>I</td><td>写使能信号，高电平有效</td></tr><tr><td>DMOp[1:0]</td><td>I</td><td>指定DM进行的读&#x2F;写操作方式</td></tr><tr><td>WPC[31:0]</td><td>I</td><td>写入DM时对应的指令PC值</td></tr><tr><td>RD[31:0]</td><td>O</td><td>32位从RAM读出的输出数据</td></tr></tbody></table><h4 id="功能定义-3"><a href="#功能定义-3" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>reset置1，且时钟上升沿来临时，重置RAM内存为0</td></tr><tr><td>2</td><td>写数据</td><td>当WE有效且时钟上升沿到来时，将WD中的数据写入A对应的RAM地址中</td></tr><tr><td>3</td><td>读数据</td><td>读取A对应的RAM地址中存储的数据到RD</td></tr></tbody></table><h4 id="控制信号-3"><a href="#控制信号-3" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>DMOp</th><th>操作</th></tr></thead><tbody><tr><td>DM_word</td><td>读&#x2F;写整个字，对应lw和sw指令</td></tr><tr><td>DM_halfword</td><td>读&#x2F;写半个字，对应lh和sh指令</td></tr><tr><td>DM_byte</td><td>读&#x2F;写一个字节，对应lb和sb指令</td></tr></tbody></table><h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><h4 id="端口定义-4"><a href="#端口定义-4" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>num[15:0]</td><td>I</td><td>16位需要扩展的立即数</td></tr><tr><td>EXTOp</td><td>I</td><td>指定进行扩展的方式</td></tr><tr><td>result[31:0]</td><td>O</td><td>32位完成扩展的立即数</td></tr></tbody></table><h4 id="功能定义-4"><a href="#功能定义-4" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>扩展</td><td>根据EXTOp指定的操作，对立即数进行扩展</td></tr></tbody></table><h4 id="控制信号-4"><a href="#控制信号-4" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th>EXTOp</th><th>操作</th></tr></thead><tbody><tr><td>EXT_zero</td><td>result &#x3D; zero_extend(num)</td></tr><tr><td>EXT_signed</td><td>result &#x3D; sign_extend(num)</td></tr></tbody></table><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>使用与或门阵列构造控制信号。</p><p>和逻辑的功能是<strong>识别</strong>，将输入的机器码识别为相应的指令；或逻辑的功能是<strong>生成</strong>，根据输入的指令的不同，产生不同的控制信号。</p><h4 id="端口定义-5"><a href="#端口定义-5" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>opcode</td><td>I</td><td>32位指令Instr[31:26]</td></tr><tr><td>funct</td><td>I</td><td>32位指令Instr[5:0]</td></tr><tr><td>ALUflag_zero</td><td>I</td><td>ALU中两运算数相减是否为0，对应beq指令</td></tr><tr><td>A3Sel</td><td>O</td><td>指定数据将写入GRF的寄存器序号，即A3</td></tr><tr><td>ALUOp</td><td>O</td><td>指定ALU进行的运算操作</td></tr><tr><td>ALUBSel</td><td>O</td><td>指定ALU第二个操作数是否为立即数</td></tr><tr><td>WDSel</td><td>O</td><td>指定写入GRF的数据的来源</td></tr><tr><td>RegWrite</td><td>O</td><td>是否可向GRF中写入数据</td></tr><tr><td>MemWrite</td><td>O</td><td>是否可向DM中写入数据</td></tr><tr><td>PCSel</td><td>O</td><td>指定更新PC的方式</td></tr><tr><td>EXTOp</td><td>O</td><td>指定EXT进行立即数扩展的方式</td></tr><tr><td>DMOp</td><td>O</td><td>指定DM操作的方式</td></tr></tbody></table><h4 id="功能定义-5"><a href="#功能定义-5" class="headerlink" title="功能定义"></a>功能定义</h4><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>生成控制信号</td><td>生成控制信号</td></tr></tbody></table><h2 id="重要机制实现方法"><a href="#重要机制实现方法" class="headerlink" title="重要机制实现方法"></a>重要机制实现方法</h2><h3 id="生成控制信号"><a href="#生成控制信号" class="headerlink" title="生成控制信号"></a>生成控制信号</h3><table><thead><tr><th align="center"></th><th align="center">opcode</th><th align="center">funct</th><th align="center">A3Sel</th><th align="center">ALUOp</th><th align="center">ALUBSel</th><th align="center">WDSel</th><th align="center">RegWrite</th><th align="center">MemWrite</th><th align="center">PCSel</th><th align="center">EXTOp</th><th align="center">DMOp</th></tr></thead><tbody><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td><td align="center">A3Sel_rd</td><td align="center">ALU_add</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td><td align="center">A3Sel_rd</td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_or</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_word</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_sub</td><td align="center">ALUBSel_grf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_branch</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_lui</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_aluans</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">j</td><td align="center">000010</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jal</td><td align="center">000011</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_ra</td><td align="center"></td><td align="center"></td><td align="center">WDSel_PCa4</td><td align="center">1</td><td align="center"></td><td align="center">PCSel_j</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jr</td><td align="center">001000</td><td align="center">001000</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">PCSel_jr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">lb</td><td align="center">100000</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">sb</td><td align="center">101000</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_byte</td></tr><tr><td align="center">lh</td><td align="center">100001</td><td align="center"><strong>undefined</strong></td><td align="center">A3Sel_rt</td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center">WDSel_dmrd</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr><tr><td align="center">sh</td><td align="center">101001</td><td align="center"><strong>undefined</strong></td><td align="center"></td><td align="center">ALU_add</td><td align="center">ALUBSel_imm</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">DM_halfword</td></tr></tbody></table><blockquote><ol><li><p>PCSel一列缺省值为PCSel_PCa4</p><p>当beq和ALUflag_zero同时为高电平时，PCSel为PCSel_branch</p></li></ol></blockquote><p>controller的verilog代码如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;def.v&quot;</span><br><br><span class="hljs-keyword">module</span> controller(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] opcode,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] funct,<br>    <span class="hljs-keyword">input</span> ALUflag_zero,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] A3Sel,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] ALUOp,<br>    <span class="hljs-keyword">output</span> ALUBSel,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] WDSel,<br>    <span class="hljs-keyword">output</span> RegWrite,<br>    <span class="hljs-keyword">output</span> MemWrite,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] PCSel,<br>    <span class="hljs-keyword">output</span> EXTOp,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] DMOp<br>    );<br><br><br><span class="hljs-comment">// parameter of funct, for R-type instructions.</span><br><span class="hljs-keyword">parameter</span> ADD  = <span class="hljs-number">6&#x27;b100000</span>,<br>          SUB  = <span class="hljs-number">6&#x27;b100010</span>,<br>          JR   = <span class="hljs-number">6&#x27;b001000</span>,<br>          ZERO = <span class="hljs-number">6&#x27;b000000</span>;<br><br><span class="hljs-comment">// parameter of opcode, for I-type and J-type instructions.</span><br><span class="hljs-comment">// I-Type</span><br><span class="hljs-keyword">parameter</span> ORI  = <span class="hljs-number">6&#x27;b001101</span>,<br>          LW  = <span class="hljs-number">6&#x27;b100011</span>,<br>          SW  = <span class="hljs-number">6&#x27;b101011</span>,<br>          BEQ = <span class="hljs-number">6&#x27;b000100</span>,<br>          LUI = <span class="hljs-number">6&#x27;b001111</span>,<br>          JAL = <span class="hljs-number">6&#x27;b000011</span>,<br>          LB  = <span class="hljs-number">6&#x27;b100000</span>,<br>          SB  = <span class="hljs-number">6&#x27;b101000</span>,<br>          LH  = <span class="hljs-number">6&#x27;b100001</span>,<br>          SH  = <span class="hljs-number">6&#x27;b101001</span>;<br><br><span class="hljs-comment">// J-Type</span><br><span class="hljs-keyword">parameter</span> J = <span class="hljs-number">6&#x27;b000010</span>;<br><br><br><span class="hljs-comment">// identify instruction</span><br><span class="hljs-keyword">wire</span> zero, add, sub, ori, lw, sw, beq, lui, jal, jr, j;<br><span class="hljs-keyword">wire</span> lb, sb, lh, sh;<br><br><span class="hljs-comment">// R</span><br><span class="hljs-keyword">assign</span> zero = (opcode == ZERO);<br><span class="hljs-keyword">assign</span> add = (zero &amp;&amp; (funct == ADD));<br><span class="hljs-keyword">assign</span> sub = (zero &amp;&amp; (funct == SUB));<br><span class="hljs-keyword">assign</span> jr = (zero &amp;&amp; (funct == JR));<br><br><span class="hljs-comment">// I and J</span><br><span class="hljs-keyword">assign</span> ori = (opcode == ORI);<br><span class="hljs-keyword">assign</span> lw = (opcode == LW);<br><span class="hljs-keyword">assign</span> sw = (opcode == SW);<br><span class="hljs-keyword">assign</span> beq = (opcode == BEQ);<br><span class="hljs-keyword">assign</span> lui = (opcode == LUI);<br><span class="hljs-keyword">assign</span> jal = (opcode == JAL);<br><span class="hljs-keyword">assign</span> j = (opcode == J);<br><span class="hljs-keyword">assign</span> lb = (opcode == LB);<br><span class="hljs-keyword">assign</span> sb = (opcode == SB);<br><span class="hljs-keyword">assign</span> lh = (opcode == LH);<br><span class="hljs-keyword">assign</span> sh = (opcode == SH);<br><br><br><span class="hljs-keyword">assign</span> A3Sel = (ori || lw || lui || lb || lh) ? `A3Sel_rt :<br>               (add || sub) ? `A3Sel_rd : <br>               jal ? `A3Sel_ra : <span class="hljs-number">2&#x27;b00</span>;<br><br><span class="hljs-keyword">assign</span> ALUOp = (lw || sw || add || lh || sh || lb || sb) ? `ALU_add :<br>               (sub || beq) ? `ALU_sub :<br>               ori ? `ALU_or :<br>               lui ? `ALU_lui : <span class="hljs-number">3&#x27;b000</span>;<br><br><span class="hljs-keyword">assign</span> ALUBSel = (lw || sw || lui || ori || lb || sb || lh || sh);<br><br><span class="hljs-keyword">assign</span> WDSel = (add || sub || ori || lui) ? `WDSel_aluans :<br>               (lw || lb || lh) ? `WDSel_dmrd :<br>               (jal) ? `WDSel_PCa4 : <span class="hljs-number">2&#x27;b00</span>;<br><br><span class="hljs-keyword">assign</span> RegWrite = (add || sub || ori || lui || jal || lw || lh || lb);<br><br><span class="hljs-keyword">assign</span> MemWrite = (sw || sb || sh);<br><br><span class="hljs-keyword">assign</span> PCSel = (beq &amp;&amp; ALUflag_zero) ? `PCSel_branch :<br>               (jal || j) ? `PCSel_j :<br>               (jr) ? `PCSel_jr : `PCSel_PCa4;<br><br><span class="hljs-keyword">assign</span> EXTOp = (lw || sw || lb || sb || lh || sh);<br><br><span class="hljs-keyword">assign</span> DMOp = (lw || sw) ? `DM_word :<br>              (lb || sb) ? `DM_byte :<br>              (lh || sh) ? `DM_halfword : <span class="hljs-number">2&#x27;b00</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="DM中对读写半字-字节的处理"><a href="#DM中对读写半字-字节的处理" class="headerlink" title="DM中对读写半字&#x2F;字节的处理"></a>DM中对读写半字&#x2F;字节的处理</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;def.v&quot;</span><br><br><span class="hljs-keyword">module</span> dm(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] A,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WD,<br>    <span class="hljs-keyword">input</span> WE,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] DMOp,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WPC,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RD<br>    );<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RAM [<span class="hljs-number">0</span>:<span class="hljs-number">3071</span>];<br><span class="hljs-keyword">integer</span> i;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2072</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        RAM[i] = <span class="hljs-number">32&#x27;h0000_0000</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">11</span>:<span class="hljs-number">0</span>] address;<br><span class="hljs-keyword">assign</span> address = A[<span class="hljs-number">13</span>:<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// write data with DMOp</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] tempRD;<br><span class="hljs-keyword">assign</span> tempRD = RAM[address];<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] halfword0;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] halfword1;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte0;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte1;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte2;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] byte3;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] datain;<br><br><span class="hljs-keyword">assign</span> halfword0 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>], WD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> halfword1 = &#123;WD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]&#125;;<br><br><span class="hljs-keyword">assign</span> byte0 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>], tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>], WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> byte1 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>], tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>], WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> byte2 = &#123;tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>], WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>], tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">assign</span> byte3 = &#123;WD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>], tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>], tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br><br><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (DMOp == `DM_word) <span class="hljs-keyword">begin</span><br>        datain = WD;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_halfword) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-keyword">begin</span><br>            datain = halfword0;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><br>            datain = halfword1;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            datain = WD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_byte) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b00</span>) <span class="hljs-keyword">begin</span><br>            datain = byte0;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b01</span>) <span class="hljs-keyword">begin</span><br>            datain = byte1;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b10</span>) <span class="hljs-keyword">begin</span><br>            datain = byte2;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b11</span>) <span class="hljs-keyword">begin</span><br>            datain = byte3;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            datain = WD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        datain = WD;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2072</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            RAM[i] &lt;= <span class="hljs-number">32&#x27;h0000_0000</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (WE) <span class="hljs-keyword">begin</span><br>            RAM[address] &lt;= datain;<br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%h: *%h &lt;= %h&quot;</span>, WPC, A, datain);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            RAM[address] &lt;= RAM[address];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment">// read data with DMOp</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dataout;<br><span class="hljs-keyword">assign</span> RD = dataout;<br><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (DMOp == `DM_word) <span class="hljs-keyword">begin</span><br>        dataout = tempRD;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_halfword) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">16</span>&#123;tempRD[<span class="hljs-number">15</span>]&#125;&#125;, tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">16</span>&#123;tempRD[<span class="hljs-number">31</span>]&#125;&#125;, tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            dataout = tempRD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DMOp == `DM_byte) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b00</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">7</span>]&#125;&#125;, tempRD[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b01</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">15</span>]&#125;&#125;, tempRD[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b10</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">23</span>]&#125;&#125;, tempRD[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">2&#x27;b11</span>) <span class="hljs-keyword">begin</span><br>            dataout = &#123;&#123;<span class="hljs-number">24</span>&#123;tempRD[<span class="hljs-number">31</span>]&#125;&#125;, tempRD[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>]&#125;;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            dataout = tempRD;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        dataout = tempRD;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="测试代码1"><a href="#测试代码1" class="headerlink" title="测试代码1"></a>测试代码1</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">156</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">135</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a3</span>,$<span class="hljs-built_in">a3</span>,<span class="hljs-number">1035</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a1</span>,<span class="hljs-number">101</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2211</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,end<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s6</span>,<span class="hljs-number">170</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">s0</span>,<span class="hljs-number">4</span>($<span class="hljs-built_in">t1</span>)<br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,loop<br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">v0</span>,<span class="hljs-number">11111</span><br></code></pre></td></tr></table></figure><h3 id="测试代码2"><a href="#测试代码2" class="headerlink" title="测试代码2"></a>测试代码2</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">123</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, l1e<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">j </span>  l1<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1e:</span><br><span class="hljs-keyword">jal </span>sum<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>  l2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sum:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">a2</span><br><span class="hljs-keyword">jr </span> $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l2:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="测试代码3"><a href="#测试代码3" class="headerlink" title="测试代码3"></a>测试代码3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0xf123</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">0x3f21</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x4567</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x7465</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">0x89ab</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s2</span>, <span class="hljs-number">0xb89a</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcdef</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcfed</span><br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t8</span>, -<span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">20</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">8</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s1</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">25</span><br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, -<span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t2</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t5</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>根据你的理解，在下面给出的DM的输入示例中，地址信号addr位数为什么是[11:2]而不是[9:0]？这个addr信号又是从哪里来的？</li></ol><p><img src="https://pic.imgdb.cn/item/6549bf83c458853aefbbf664.png" alt="DM示例"></p><p>DM里的RAM按字节寻址，且该DM设计大小为4KB，所以应该使用addr[11:2]</p><p>addr来自ALU的计算输出，代表要读取的数据在RAM中的地址</p><ol start="2"><li><p>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</p><p>控制器设计的译码方式有三种。</p><ul><li><p>三元运算符</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> ALUOp = (lw || sw || add || lh || sh || lb || sb) ? `ALU_add :<br>               (sub || beq) ? `ALU_sub :<br>               ori ? `ALU_or :<br>               lui ? `ALU_lui : <span class="hljs-number">3&#x27;b000</span>;<br></code></pre></td></tr></table></figure></li><li><p>case语句</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">case</span>(ALUOp)<br>`ALU_add: C = A + B;<br>`ALU_sub: C = A - B;<br>`ALU_or: C = A | B;<br>`ALU_lui: C = B &lt;&lt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">default</span>: C = <span class="hljs-number">32&#x27;h0000_0000</span>;<br><span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure></li><li><p>if-else语句</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (ALUOP == `ALU_add)<br>C = A + B;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ALUOP == `ALU_sub)<br>C = A - B;<br><span class="hljs-keyword">else</span><br>C = <span class="hljs-number">32&#x27;h0000_0000</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>assign语句配合三目运算符使用，可以不用再额外定义reg变量。</p><p>case语句，if-else语句配合宏定义使用可以增强代码的可读性。if-else语句写起来略显繁琐。</p><ol start="3"><li><p>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</p><p>同步复位中，clk的优先级高于reset；异步复位中两者优先级相同。</p></li><li><p>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</p><p>addi与addiu的区别在于当出现溢出时，addiu忽略溢出，并将溢出的最高位舍弃；addi会报错SignalException(IntegerOverflow)。忽略溢出时，二者等价。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>试题</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3 - 单周期CPU设计文档</title>
    <link href="/2023/10/30/P3-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2023/10/30/P3-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p><strong>Tips</strong></p><p>课下要求可能会发生变化，文章仅供参考，未必完全正确。</p><p>请勿抄袭！</p>          </div><h1 id="P3-单周期CPU设计文档"><a href="#P3-单周期CPU设计文档" class="headerlink" title="P3 单周期CPU设计文档"></a>P3 单周期CPU设计文档</h1><h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><ul><li>设计的处理器为32位单周期处理器</li><li>处理器支持的指令集为<code>add, sub, ori, lw, sw, beq, lui, nop，j，jal，jr，lb，sb，lh，sh</code>等</li><li><code>nop</code>为空指令，其机器码为<code>0x00000000</code>，不进行任何有效行为，如修改寄存器等</li><li><code>add, sub</code>按无符号加减法处理，不考虑溢出</li></ul><h2 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h2><p>参考了《数字设计与计算机体系结构》图7-14，在实际设计上略有改动。</p><p><img src="https://pic.imgdb.cn/item/653fb286c458853aef8839f2.png" alt="《数字设计与计算机体系结构》图7-14"></p><p>最终实现效果概览如下。</p><p><img src="https://pic.imgdb.cn/item/653fb2e7c458853aef8a3714.png" alt="单周期CPU概览图"></p><h2 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h2><h3 id="IFU-取指令单元"><a href="#IFU-取指令单元" class="headerlink" title="IFU(取指令单元)"></a>IFU(取指令单元)</h3><p>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</p><p>PC 用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</p><p><strong>起始地址：0x00003000。</strong></p><p>地址范围：0x00003000 ~ 0x00006FFF。</p><p>IM用ROM实现，容量为4096 × 32bit。</p><p>IM实际地址宽度仅为12位，需要使用恰当的方法将PC中储存的地址同IM联系起来。</p><div class="note note-success">            <p>PC的处理方法：</p><ul><li>PC的变化范围为0x00003000 ~ 0x00006FFF，考虑使用PC<sup>‘</sup> &#x3D; PC - 0x00003000，则PC<sup>‘</sup>的范围为0x00000000-0x00003FFF，不仅保证PC和PC<sup>‘</sup>在数值上一一对应，而且在设计处理时更加方便。</li><li>注意，输出是需要输出PC的值，而不是PC<sup>‘</sup>。</li><li>IM的实际地址宽度为12位，而PC的有效位数（可能发生变化的位数）为低14位。因为ROM是按字寻址，在从IM读取指令时只需要用PC[13:2]作为地址，就可以正确读取数据。</li></ul>          </div><h4 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-1-1 IFU模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>clk</td>        <td>I</td>        <td>时钟信号</td>    </tr>    <tr>        <td>reset</td>        <td>I</td>        <td><strong>异步</strong>复位信号，将PC置0</td>    </tr>    <tr>        <td>offset[15:0]</td>        <td>I</td>        <td>            beq等branch指令的偏移量，即Instr[15:0]        </td>    </tr>    <tr>        <td>imm[25:0]</td>        <td>I</td>        <td>j指令和jal指令中的立即数，即Instr[25:0]</td>    </tr>    <tr>        <td>PCsel[2:0]</td>        <td>I</td>        <td>指定更新PC的方式</td>    </tr>    <tr>        <td>Instr[31:0]</td>        <td>O</td>        <td>输出IM中PC地址上的指令</td>    </tr>    <tr>        <td>PC</td>        <td>O</td>        <td>输出当前PC的值</td>    </tr>    <tr>        <td>PC+4</td>        <td>O</td>        <td>输出PC+4的值</td>    </tr></table><h4 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption> 表2-1-2 IFU模块功能定义 </caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>异步复位</td>        <td>reset置1时，将PC置为0x00003000</td>    </tr>    <tr>        <td>2</td>        <td>更新下一个PC的值</td>        <td>            时钟上升沿来临时，更新PC的值<br>            PCsel为2'b00时，PC <- PC + 4<br>            PCsel为2'b01时，PC <- PC + 4 + sign_extend(offset||0<sup>2</sup>)<br>            PCsel为2'b10时，PC <- PC[31:28]||imm||0<sup>2</sup><br>            PCsel为2'b11时，PC <- PC[31:28]||imm||0<sup>2</sup>; GPR[31] <- PC + 4        </td>    </tr> </table><h3 id="GRF-寄存器文件"><a href="#GRF-寄存器文件" class="headerlink" title="GRF(寄存器文件)"></a>GRF(寄存器文件)</h3><p>使用<strong>具有写使能功能</strong>的寄存器实现，寄存器总数为<strong>32个</strong>，具有<strong>异步复位</strong>功能。</p><p>其中，<strong>0号寄存器</strong>($zero)的值始终保持为0。其他的寄存器<strong>初始值(复位后)均为0</strong>，无需专门设置。</p><h4 id="端口定义-1"><a href="#端口定义-1" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-2-1 GRF模块端口定义</caption>    <tr>        <td> 信号名 </td>        <td> 方向 </td>        <td> 描述 </td>    </tr>    <tr>        <td> clk </td>        <td> I </td>        <td> 时钟信号 </td>    </tr>    <tr>        <td> reset </td>        <td> I </td>        <td> <strong>异步</strong>复位信号，将32个寄存器中的值全部清零<br>1:复位<br>0:无效</td>    </tr>    <tr>        <td> WE </td>        <td> I </td>        <td> 写使能信号<br>1:可向GRF中写入数据<br>0:不能向GRF中写入数据</td>    </tr>    <tr>        <td> A1[4:0] </td>        <td> I </td>        <td> 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td>    </tr>    <tr>        <td> A2[4:0] </td>        <td> I </td>        <td> 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td>    </tr>    <tr>        <td> A3[4:0] </td>        <td> I </td>        <td> 5位地址输入信号，指定32个寄存器中的一个将WD中的数据写入</td>    </tr>    <tr>        <td> WD[31:0] </td>        <td> I </td>        <td> 32位数据输入信号</td>    </tr>    <tr>        <td> RD1[31:0] </td>        <td> O </td>        <td> 输出A1指定的寄存器中的32位数据</td>    </tr>    <tr>        <td> RD2[31:0] </td>        <td> O </td>        <td> 输出A2指定的寄存器中的32位数据</td>    </tr></table><h4 id="功能定义-1"><a href="#功能定义-1" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-2-2 GRF模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>异步复位</td>        <td>reset信号置1时，所有寄存器存储的数值清零，其行为与logisim自带部件register的reset接口完全相同</td>    </tr>    <tr>        <td>2</td>        <td>读数据</td>        <td>读出A1，A2地址对应寄存器中所存储的数据到对应的RD1，RD2</td>    </tr>    <tr>        <td>3</td>        <td>写数据</td>        <td>当<strong>WE有效且时钟上升沿来临</strong>时，将WD写入A3所对应的寄存器中</td>    </tr></table><h3 id="ALU-算术逻辑单元"><a href="#ALU-算术逻辑单元" class="headerlink" title="ALU(算术逻辑单元)"></a>ALU(算术逻辑单元)</h3><p>提供 32 位加、减、或运算及大小比较功能。</p><p>加减法按无符号处理（不考虑溢出）。</p><h4 id="端口定义-2"><a href="#端口定义-2" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-3-1 ALU模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>A[31:0]</td>        <td>I</td>        <td>第一个32位计算数</td>    </tr>    <tr>        <td>B[31:0]</td>        <td>I</td>        <td>第二个32位计算数</td>    </tr>    <tr>        <td>ALUop[2:0]</td>        <td>I</td>        <td>指定ALU进行的计算</td>    </tr>    <tr>        <td>res[31:0]</td>        <td>O</td>        <td>运算结果</td>    </tr>    <tr>        <td>comp[2:0]</td>        <td>O</td>        <td>            输出A与B的大小关系        </td>    </tr></table><h4 id="功能定义-2"><a href="#功能定义-2" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-3-2 ALU模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>比较大小</td>        <td>            A > B时，comp=2'b00<br>            A = B时，comp=2'b01<br>            A < B时，comp=2'b10<br>        </td>    </tr>    <tr>        <td>2</td>        <td>加运算</td>        <td>ALUop = 3'b000时，res = A + B，不考虑溢出</td>    </tr>    <tr>        <td>3</td>        <td>减运算</td>        <td>            ALUop = 3'b001时，res = A - B，不考虑溢出        </td>    </tr>    <tr>        <td>4</td>        <td>或运算</td>        <td>ALUop = 3'b010时，res = A | B</td>    </tr>    <tr>        <td>5</td>        <td>B置高16位</td>        <td>ALUop = 3'b011时，res = B || 10<sup>16</sup></td>    </tr></table><blockquote><p>多余的ALUop为扩展指令预留。</p></blockquote><h3 id="DM-数据存储器"><a href="#DM-数据存储器" class="headerlink" title="DM(数据存储器)"></a>DM(数据存储器)</h3><p>使用RAM实现，容量为3072 × 32bit，应具有<strong>异步复位</strong>功能，复位值为0x00000000。</p><p><strong>起始地址：0x00000000</strong>。</p><p>地址范围：0x00000000 ~ 0x00002FFF。</p><p>RAM 应使用<strong>双端口模式</strong>，即设置 RAM 的 <strong>Data Interface</strong> 属性为 <strong>Separate load and store ports</strong>。</p><h4 id="端口定义-3"><a href="#端口定义-3" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-4-1 DM模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>clk</td>        <td>I</td>        <td>时钟信号</td>    </tr>    <tr>        <td>reset</td>        <td>I</td>        <td><strong>异步</strong>复位信号，将DM内的RAM重置为0</td>    </tr>    <tr>        <td>WE</td>        <td>I</td>        <td>写使能信号，WE为1时，允许写入数据；WE为0时，禁止写入</td>    </tr>    <tr>        <td>DMop[1:0]</td>        <td>I</td>        <td>指定DM进行的读/写操作类型</td>    </tr>    <tr>        <td>A[31:0]</td>        <td>I</td>        <td>需要进行读/写操作的地址</td>    </tr>    <tr>        <td>WD[31:0]</td>        <td>I</td>        <td>写入RAM的32位输入数据</td>    </tr>    <tr>        <td>RD[31:0]</td>        <td>O</td>        <td>从RAM读出的32位输出数据</td>    </tr></table><h4 id="功能定义-3"><a href="#功能定义-3" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-4-2 DM模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>异步复位</td>        <td>reset置1时，异步重置RAM内存为0</td>    </tr>    <tr>        <td>2</td>        <td>写数据</td>        <td>            当<strong>WE有效且时钟上升沿到来</strong>时，将WD中的数据写入A对应的RAM地址中            <br>DMop为2'b00时，执行lw指令            <br>DMop为2'b01时，执行lh指令            <br>DMop为2'b10时，执行lb指令        </td>    </tr>    <tr>        <td>3</td>        <td>读数据</td>        <td>            读取A对应的RAM地址中存储的数据到RD            <br>DMop为2'b00时，执行sw指令            <br>DMop为2'b01时，执行sh指令            <br>DMop为2'b10时，执行sb指令        </td>    </tr></table><blockquote><p>与处理IFU中地址的方法相同，使用A[13:2]即可从DM的RAM中正确读取数据。</p></blockquote><h3 id="EXT-扩展单元"><a href="#EXT-扩展单元" class="headerlink" title="EXT(扩展单元)"></a>EXT(扩展单元)</h3><p>使用Logisim内置的Bit Extender。</p><h4 id="端口定义-4"><a href="#端口定义-4" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption> 表2-5-1 EXT模块端口定义 </caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>num[15:0]</td>W        <td>I</td>        <td>需要扩展的16位立即数</td>    </tr>    <tr>        <td>sel</td>        <td>I</td>        <td>指定进行扩展的方式</td>    </tr>    <tr>        <td>result[31:0]</td>        <td>O</td>        <td>扩展完成的32位数</td>    </tr></table><h4 id="功能定义-4"><a href="#功能定义-4" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-5-2 EXT模块功能定义</caption>    <tr>        <td>sel</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1'b0</td>        <td>零扩展</td>        <td>result = zero_extend(num)</td>    </tr><tr>        <td>1'b1</td>        <td>符号扩展</td>        <td>result = sign_extend(num)</td>    </tr></table><h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller(控制器)"></a>Controller(控制器)</h3><p>使用与或门阵列构造控制信号。</p><p>和逻辑的功能是<strong>识别</strong>，将输入的机器码识别为相应的指令；或逻辑的功能是<strong>生成</strong>，根据输入的指令的不同，产生不同的控制信号。</p><h4 id="端口定义-5"><a href="#端口定义-5" class="headerlink" title="端口定义"></a>端口定义</h4><table>    <caption>表2-6-1 Controller模块端口定义</caption>    <tr>        <td>信号名</td>        <td>方向</td>        <td>描述</td>    </tr>    <tr>        <td>op[5:0]</td>        <td>I</td>        <td>32位指令Instr[31:26]</td>    </tr>    <tr>        <td>comp[1:0]</td>        <td>I</td>        <td>ALU中两运算数的大小，决定是否执行branch指令</td>    </tr>    <tr>        <td>funct[5:0]</td>        <td>I</td>        <td>32位指令Instr[5:0]</td>    </tr>    <tr>        <td>RegDst[1:0]</td>        <td>O</td>        <td>            指定数据写入GRF的寄存器序号<br>            RegDst为2'b00时，序号为Instr[20:16]，对应I型指令的rt<br>            RegDst为2'b01时，序号为Instr[15:11]，对应R型指令的rd<br>            RegDst为2'b10时，序号为31，即<strong>$ra</strong>的序号，用于jal指令        </td>    </tr>    <tr>        <td>ALUSrc</td>        <td>O</td>        <td>            指定ALU第二个运算数是否是立即数<br>            ALUSrc为0时，运算数来自GRF<br>            ALUSrc为1时，运算数为立即数        </td>    </tr>    <tr>        <td>MemToReg[1:0]</td>        <td>O</td>        <td>            指定写入GRF的数据的来源<br>            MemToReg为2'b00时，数据为ALU的输出res<br>            MemToReg为2'b01时，数据为DM的输出RD<br>            MemToReg为2'b10时，数据为PC + 4，用于jal指令将PC + 4写入$ra的操作        </td>    </tr>    <tr>        <td>RegWrite</td>        <td>O</td>        <td>是否可向GRF中写入数据</td>    </tr>    <tr>        <td>MemWrite</td>        <td>O</td>        <td>是否可向DM中写入数据</td>    </tr>    <tr>        <td>PCsel[1:0]</td>        <td>O</td>        <td>指定更新PC的方式</td>    </tr>    <tr>        <td>Extop</td>        <td>O</td>        <td>            指定EXT进行立即数扩展的方式<br>            ExtOp为0时，EXT进行零扩展<br>            ExtOp为1时，EXT进行符号扩展<br>        </td>    </tr>    <tr>        <td>DMop[1:0]</td>        <td>O</td>        <td>指定操作DM的方式</td>    </tr>    <tr>        <td>ALUop[2:0]</td>        <td>O</td>        <td>指定ALU进行的计算</td>    </tr></table><h4 id="功能定义-5"><a href="#功能定义-5" class="headerlink" title="功能定义"></a>功能定义</h4><table>    <caption>表2-6-2 Controller模块功能定义</caption>    <tr>        <td>序号</td>        <td>功能</td>        <td>描述</td>    </tr>    <tr>        <td>1</td>        <td>生成控制信号</td>        <td>生成控制信号</td>    </tr></table><h2 id="重要机制实现方法"><a href="#重要机制实现方法" class="headerlink" title="重要机制实现方法"></a>重要机制实现方法</h2><h3 id="生成控制信号"><a href="#生成控制信号" class="headerlink" title="生成控制信号"></a>生成控制信号</h3><p><img src="https://pic.imgdb.cn/item/653fb25bc458853aef877fb7.png" alt="控制信号真值表"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><img src="https://pic.imgdb.cn/item/653fb332c458853aef8bb437.png" alt="程序计数器细节"></p><h3 id="DM中对读写半字-字节的处理"><a href="#DM中对读写半字-字节的处理" class="headerlink" title="DM中对读写半字&#x2F;字节的处理"></a>DM中对读写半字&#x2F;字节的处理</h3><p><img src="https://pic.imgdb.cn/item/653fb331c458853aef8bb0ee.png" alt="DM总览"></p><p><img src="https://pic.imgdb.cn/item/653fb331c458853aef8bb190.png" alt="写字/半字/字节"></p><p><img src="https://pic.imgdb.cn/item/653fb332c458853aef8bb2cd.png" alt="读字/半字/字节"></p><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="测试代码1"><a href="#测试代码1" class="headerlink" title="测试代码1"></a>测试代码1</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">156</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">135</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a3</span>,$<span class="hljs-built_in">a3</span>,<span class="hljs-number">1035</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">a1</span>,<span class="hljs-number">101</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">a1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2211</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,end<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s6</span>,<span class="hljs-number">170</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t4</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">s0</span>,<span class="hljs-number">4</span>($<span class="hljs-built_in">t1</span>)<br><span class="hljs-symbol">out:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,loop<br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">v0</span>,<span class="hljs-number">11111</span><br></code></pre></td></tr></table></figure><p>导出为</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns">v2.<span class="hljs-number">0</span> raw<br><span class="hljs-number">3408009</span>c<br><span class="hljs-number">340a0087</span><br><span class="hljs-number">34</span>e7040b<br><span class="hljs-number">3c050065</span><br><span class="hljs-number">340508a3</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">116a0008</span><br><span class="hljs-number">358c0008</span><br><span class="hljs-number">3</span>c1600aa<br><span class="hljs-number">016c5820</span><br><span class="hljs-number">01405820</span><br><span class="hljs-number">8d300004</span><br><span class="hljs-number">01495020</span><br><span class="hljs-number">01405822</span><br><span class="hljs-number">116</span>afff7<br><span class="hljs-number">3c022b67</span><br></code></pre></td></tr></table></figure><h3 id="测试代码2"><a href="#测试代码2" class="headerlink" title="测试代码2"></a>测试代码2</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">123</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, l1e<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">j </span>  l1<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l1e:</span><br><span class="hljs-keyword">jal </span>sum<br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>  l2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sum:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s0</span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s2</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">a2</span><br><span class="hljs-keyword">jr </span> $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">l2:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="测试代码3"><a href="#测试代码3" class="headerlink" title="测试代码3"></a>测试代码3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0xf123</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">0x3f21</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x4567</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s1</span>, <span class="hljs-number">0x7465</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">0x89ab</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s2</span>, <span class="hljs-number">0xb89a</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcdef</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s3</span>, <span class="hljs-number">0xcfed</span><br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t8</span>, -<span class="hljs-number">4</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">20</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">8</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s1</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sh </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">25</span><br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, -<span class="hljs-number">2</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t3</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">19</span><br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t2</span>, -<span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-built_in">t5</span>, <span class="hljs-number">1</span>($<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</li></ol><p>状态存储：GRF、DM</p><p>状态转移：IFU、ALU、EXT、Controller</p><ol start="2"><li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？请给出分析，若有改进意见也请一并给出。</li></ol><p>我认为是合理的。</p><p>IM只需要被读取，而ROM是只读的，下次打开文件时内存依然存在，且运行过程中不会被篡改；</p><p>DM需要支持读、写功能，一个时钟周期内只会进行读、写的其中一种操作。RAM即可支持读写操作，又在占用空间上优于寄存器文件。</p><p>GRF需要支持读、写功能，且与ALU直接相连，对读、写速度要求较高，故使用寄存器文件。</p><ol start="3"><li>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</li></ol><p>并未设计新的模块。</p><p>4.事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</p><p>Controller采用与或门阵列实现，读入nop指令时所有的控制信号均保持在低电平，只进行了PC &lt;- PC + 4，而不会产生其他任何操作。</p><ol start="5"><li>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</li></ol><p>我认为该样例覆盖了该CPU中支持的所有指令，且先由最基本的可独立判断正误的指令进行验证，之后再对更高层的指令的结果正误进行验证，能对CPU的设计起到较为准确的反馈。</p><p>可以考虑加入一些32位数、16位无符号数的边界情况，多增加一些目标寄存器为<code>$0</code>的指令，达到更好的测试效果。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>试题</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归调用汇编代码翻译的一些心得</title>
    <link href="/2023/10/21/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
    <url>/2023/10/21/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>教程 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-5/mips5-11/#_6">函数调用 - 计算机组成教程 (buaa.edu.cn)</a> 中曾介绍过如何将带有递归函数调用的c语言代码翻译成汇编指令。P2课下也涉及了部分需要应用递归的题目，在此总结一下我完成此类汇编翻译的一些心得。</p><p>我们在此就以 <a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=36&PieId=1121">P2_L0_full_1 - 系统能力课程实验平台 (buaa.edu.cn)</a> 当作例题，简要介绍一下设计思路。</p><h1 id="例题1：全排列生成"><a href="#例题1：全排列生成" class="headerlink" title="例题1：全排列生成"></a>例题1：全排列生成</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>题目编号 1121-36</p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>实现满足下面功能的汇编程序：</p><ol><li><p>使用mips实现全排列生成算法。</p></li><li><p>以0x00000000为数据段起始地址。</p></li><li><p>输入一个小于等于6的正整数，求出n的全排列，并按照字典序输出。</p></li><li><p>每组数据最多执行500,000条指令。</p></li><li><p>请使用syscall结束指令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>只输入一行，输入一个整数n **(0 &lt; n &lt;&#x3D; 6)**。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照字典序输出n!行数组，每行输出n个数字，数字之间以空格隔开，每行最后一个数字后可以有空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="解答步骤"><a href="#解答步骤" class="headerlink" title="解答步骤"></a>解答步骤</h2><p>在此分享一下我完成汇编代码的一些思路步骤。</p><h3 id="第一步：完成符合要求的C语言代码"><a href="#第一步：完成符合要求的C语言代码" class="headerlink" title="第一步：完成符合要求的C语言代码"></a>第一步：完成符合要求的C语言代码</h3><p>C语言的代码与汇编指令具有很高的相似性，如果有一份正确的C语言代码，汇编编程题就相当于一个“翻译题”。</p><p>全排列问题的C语言代码如下：（如果对此有疑问的话，可以去网上搜索一下全排列的相关讲解，在此不展开说明）</p><p><img src="https://pic.imgdb.cn/item/6533b63bc458853aef395a40.png" alt="全排列问题的C语言解答"></p><h3 id="第二步：一些必要的macro"><a href="#第二步：一些必要的macro" class="headerlink" title="第二步：一些必要的macro"></a>第二步：一些必要的macro</h3><p>使用宏可有效提高代码的复用性，提高代码的可读性。</p><p>我比较习惯用的macro有：</p><ul><li><p>取array[i]的值到%d</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> getNum(%d,%i)<br><span class="hljs-keyword">sll </span>%d,%i,<span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>%d,array(%d)<br>.end_macro<br></code></pre></td></tr></table></figure></li><li><p>取array[i] [j]的值到%d，矩阵的<strong>列数</strong>为%n</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> getNum(%d,%i,%<span class="hljs-keyword">j,%n)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mul </span>%d,%i,%n<br><span class="hljs-keyword">add </span>%d,%d,%<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span>%d,%d,<span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>%d,array(%d)<br>.end_macro<br></code></pre></td></tr></table></figure></li><li><p>将字压入栈</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br></code></pre></td></tr></table></figure><p>相对应的弹出栈</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br></code></pre></td></tr></table></figure></li></ul><h3 id="第三步：合理规划寄存器"><a href="#第三步：合理规划寄存器" class="headerlink" title="第三步：合理规划寄存器"></a>第三步：合理规划寄存器</h3><p><code>s0</code>-<code>s7</code>是留给“需要保存的变量”，如常量，全局变量等；<code>t0</code>-<code>t9</code>是留给“临时变量”，如循环时常用的i、j、k变量等。对于一般的题目，我使用<code>s0</code>来保存n的值，<code>t0</code>留给循环变量i，<code>t9</code>留给计算出来的临时地址。</p><p>当然，如何分配主要还是看自己写的顺不顺手，只要自己有一套可操作的规则即可。</p><h3 id="第四步：完成代码"><a href="#第四步：完成代码" class="headerlink" title="第四步：完成代码"></a>第四步：完成代码</h3><p>我们在此先给出完整的汇编代码。如果对递归调用之外的地方存在疑问，可以再去阅读额外的讲解。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">array:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">symbol:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">blank:</span> .asciiz <span class="hljs-string">&quot; &quot;</span><br><span class="hljs-symbol">next_line:</span> .asciiz <span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br><br><span class="hljs-meta">.text</span><br><span class="hljs-symbol">main:</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br>li   $<span class="hljs-built_in">s1</span>, <span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-symbol">init_loop:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, symbol($<span class="hljs-built_in">t8</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s0</span>, init_loop<br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># index</span><br><span class="hljs-keyword">jal </span> FullArray<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">FullArray:</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, search<br><span class="hljs-symbol">print:</span><br>li   $<span class="hljs-built_in">t9</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">print_loop:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">a0</span>, array($<span class="hljs-built_in">t8</span>)<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">4</span><br>la   $<span class="hljs-built_in">a0</span>, <span class="hljs-keyword">blank</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t9</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s0</span>, print_loop<br><span class="hljs-symbol">print_end:</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">4</span><br>la   $<span class="hljs-built_in">a0</span>, next_line<br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">search:</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># i</span><br><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t8</span>, symbol($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-number">0</span>, Else<br><span class="hljs-symbol">If:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">t2</span>, array($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s1</span>, symbol($<span class="hljs-built_in">t9</span>)<br><br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">t0</span>)<br>push($<span class="hljs-built_in">t1</span>)<br><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jal </span> FullArray<br><br>pop($<span class="hljs-built_in">t1</span>)<br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, symbol($<span class="hljs-built_in">t9</span>)<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Else:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">blt </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s0</span>, loop<br><span class="hljs-symbol">loop_end:</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure><h2 id="两个注意事项"><a href="#两个注意事项" class="headerlink" title="两个注意事项"></a>两个注意事项</h2><h3 id="1-注意return的位置"><a href="#1-注意return的位置" class="headerlink" title="1.注意return的位置"></a>1.注意return的位置</h3><p>观察C语言代码，我们发现有两个需要return的位置。一般来说，return直接写作<code>jr $ra</code>即可。</p><h3 id="2-递归调用前后的处理工作"><a href="#2-递归调用前后的处理工作" class="headerlink" title="2.递归调用前后的处理工作"></a>2.递归调用前后的处理工作</h3><p>我们把上面代码中设计递归调用的片段截取下来：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">t2</span>, array($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s1</span>, symbol($<span class="hljs-built_in">t9</span>)<br><br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">t0</span>)<br>push($<span class="hljs-built_in">t1</span>)<br><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jal </span> FullArray<br><br>pop($<span class="hljs-built_in">t1</span>)<br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, symbol($<span class="hljs-built_in">t9</span>)<br></code></pre></td></tr></table></figure><p>这里，<code>$ra</code>存储的是之前调用的位置+4，比如说在执行完<code>jal FullArray</code>之后，<code>$ra</code>存储的是pop($t1)的地址。<code>$t0</code>存的是参数index，<code>$t1</code>存的是FullArray里的遍历变量i。</p><p>进行push和pop的原因，无非是对寄存器内原有的值进行保护。<strong>对寄存器的保护(进行push和pop操作)一定是在函数调用前后进行的</strong>，而往往不是刚进入函数的时候。</p><p>难点在于，哪些变量需要被push？</p><ul><li><p>首先，<code>$ra</code>是必须被存在栈里的，否则调用结束后返回调用位置可能会出现异常；</p></li><li><p>然后，函数的参数、返回值等一般是需要被push的，在这里就是index；</p></li><li><p>其次，就是一些涉及到函数“状态”的量，比如说变量i，因为是对不同数字是否被占用进行遍历，存在遍历的先后顺序，所以i的不同会导致函数的“当前状态不同”；</p><p>假如不对i进行保存，i&#x3D;3时递归到第二层，在第二层中假设i最后为0且未进入第三层递归，那么再回到第一层时，i的值就与之前发生了变化，会造成函数执行异常；</p></li><li><p>最后，调用者(caller)调用的函数(callee)中，callee使用到了一些caller中使用的寄存器，那么进行函数调用的时候需要保护caller中的这些寄存器。</p></li></ul><p>确定了需要被push和pop的变量之后，我们还需要注意push和pop的顺序是否对应，栈是后入先出，最先<code>push($ra)</code>就要最后<code>pop($ra)</code>。</p><p>完成了push和pop的代码之后，我们就需要更新函数的参数</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># 下一个FullArray调用时参数为index + 1</span><br></code></pre></td></tr></table></figure><p>然后就可以递归调用了！</p><p>（一般来说函数的参数保存在<code>a0</code>-<code>a3</code>寄存器里，当我意识到这点时已经晚了）</p><p>至此，一个完整的含有递归的汇编代码就完成了！</p><p>借助上面的分析，看看下面这两道例题，并尝试自己解决。</p><h1 id="例题2：哈密顿回路"><a href="#例题2：哈密顿回路" class="headerlink" title="例题2：哈密顿回路"></a>例题2：哈密顿回路</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>题目编号 1109-5 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-5/mips5-12/">challenge！哈密顿回路 - 计算机组成教程 (buaa.edu.cn)</a></p><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><p>输入一个具有n个顶点的无向图G，判断G是否有哈密顿回路<a href="https://oi-wiki.org/graph/hamilton/">哈密顿图 - OI Wiki (oi-wiki.org)</a>。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数n，代表G有n个顶点，第二行是一个整数m，代表G有m条边，接下来的2 * m行，每行具有一个整数，设每个奇数行的数为a，它下一行的数b，序号为a, b的两个顶点间具有一条边，两个整数之间以回车隔开（点的标号从 1 开始）。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，若为 0 则代表G不具有哈密顿回路，若为 1 则代表G具有哈密顿回路。</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>1、0 &lt; n &lt; 100</p><p>2、0 &lt; m &lt; 100</p><p>3、请勿使用 <code>.globl main</code></p><p>4、最大运行指令条数限制为 100000</p><p>5、请使用 <code>syscall</code> 结束程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>6<br>1<br>2<br>1<br>3<br>2<br>3<br>2<br>4<br>3<br>5<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>6<br>1<br>2<br>1<br>3<br>2<br>3<br>2<br>4<br>1<br>4<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2"></a>输出样例2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h3 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h3><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="参考C语言代码"><a href="#参考C语言代码" class="headerlink" title="参考C语言代码"></a>参考C语言代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> G[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];    <span class="hljs-comment">// 采用邻接矩阵存储图中的边</span><br><span class="hljs-type">int</span> book[<span class="hljs-number">8</span>];    <span class="hljs-comment">// 用于记录每个点是否已经走过</span><br><span class="hljs-type">int</span> m, n, ans;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    book[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>, i;<br>    <span class="hljs-comment">// 判断是否经过了所有的点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        flag &amp;= book[i];<br>    &#125;<br>    <span class="hljs-comment">// 判断是否形成一条哈密顿回路</span><br>    <span class="hljs-keyword">if</span> (flag &amp;&amp; G[x][<span class="hljs-number">0</span>]) &#123;<br>        ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 搜索与之相邻且未经过的边</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!book[i] &amp;&amp; G[x][i]) &#123;<br>            dfs(i);<br>        &#125;<br>    &#125;<br>    book[x] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-type">int</span> i, x, y;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>        G[x - <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        G[y - <span class="hljs-number">1</span>][x - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从第0个点（编号为1）开始深搜</span><br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考解答"><a href="#参考解答" class="headerlink" title="参考解答"></a>参考解答</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br>G: <span class="hljs-meta">.space</span> <span class="hljs-number">280</span><br><span class="hljs-symbol">book:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">40</span><br><br><span class="hljs-meta">.macro</span> get(%des, %i, %<span class="hljs-keyword">j, </span>%col)<br><span class="hljs-keyword">mult </span>%i, %col<br><span class="hljs-keyword">mflo </span>%des<br><span class="hljs-keyword">add </span> %des, %des, %<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %des, <span class="hljs-number">2</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br><br><span class="hljs-meta">.text</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># n</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># m</span><br>li   $<span class="hljs-built_in">s7</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># constant</span><br><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">loop1:</span><br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s1</span>, loop1_end<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span><br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, G($<span class="hljs-built_in">t9</span>)<br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, G($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop1<br><span class="hljs-symbol">loop1_end:</span><br><br>li   $<span class="hljs-built_in">a0</span>, <span class="hljs-number">0</span><br>li   $<span class="hljs-built_in">s2</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># ans</span><br><span class="hljs-keyword">jal </span> dfs<br><br><span class="hljs-comment">## print answer</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">s2</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">dfs:</span><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t8</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># i</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># flag</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loop2:</span><br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">s0</span>, loop2_end<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t8</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">and </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t9</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t8</span>, $<span class="hljs-built_in">t8</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop2<br><span class="hljs-symbol">loop2_end:</span><br><br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, $<span class="hljs-number">0</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, G($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">Nope</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">Nope</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">s2</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Nope:</span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># i in stack</span><br><span class="hljs-symbol">loop3:</span><br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, loop3_end<br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-number">0</span>, Else<br>get($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t9</span>, G($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">beq </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-number">0</span>, Else<br><br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">t0</span>)<br>push($<span class="hljs-built_in">a0</span>)<br><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span><br><span class="hljs-keyword">jal </span> dfs<br><br>pop($<span class="hljs-built_in">a0</span>)<br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Else:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop3<br><span class="hljs-symbol">loop3_end:</span><br><br><span class="hljs-keyword">sll </span> $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">a0</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">book($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure><h1 id="例题3：01迷宫"><a href="#例题3：01迷宫" class="headerlink" title="例题3：01迷宫"></a>例题3：01迷宫</h1><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>题目编号 1121-38 <a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=38&PieId=1121">P2_L1_puzzle - 系统能力课程实验平台 (buaa.edu.cn)</a></p><h3 id="题目要求-2"><a href="#题目要求-2" class="headerlink" title="题目要求"></a>题目要求</h3><ol><li>使用mips实现01迷宫路线数目计算。</li><li>以0x00000000为数据段起始地址。</li><li>输入一个n*m的01矩阵作为01迷宫，并给定他的起点与终点，求出他不同逃跑路线的数目（不同逃跑路线中可以有相同的部分，但是不能完全相同）。</li><li>每组数据最多执行5,000,000条指令。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://pic.imgdb.cn/item/6533cfecc458853aefa04018.png" alt="迷宫示例"></p><ol><li>上图表示的是一个4*5的01矩阵，这个矩阵就是一个01迷宫。</li><li>如上图，以红色0作为起点，绿色0作为终点，每一次行进只能选择上下左右中值为0且未走过的位置，满足上述条件的路线，即为一条迷宫逃跑路线。如右图中，蓝色的路线即为一条逃跑路线。</li></ol><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>前两行输入两个整数n和m（n、m均为正整数并且小于等于7），分别代表01矩阵行数和列数。接下来的n*m行，每行输入1个整数（0或1），对应着01矩阵各个元素值(第i*m+j个整数为矩阵的第（i+1）行第j个元素，即一行一行输入)。接下来的四行分别代表迷宫的起点和终点，每行一个整数，分别代表起点与终点行数和列数。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>只输出一个整数，代表逃跑路线的数目。</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>5<br>0<br>0<br>1<br>0<br>0<br>1<br>0<br>0<br>0<br>1<br>1<br>0<br>1<br>0<br>1<br>1<br>0<br>0<br>0<br>0<br>1<br>1<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h3 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h3><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="参考C语言代码-1"><a href="#参考C语言代码-1" class="headerlink" title="参考C语言代码"></a>参考C语言代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 100007</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1007</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> db double</span><br><span class="hljs-type">int</span> n, m, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> start_x, start_y, end_x, end_y;<br><span class="hljs-type">int</span> space[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>], book[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;, cnt);</span><br>    <span class="hljs-keyword">if</span> (x == end_x &amp;&amp; y == end_y) &#123;<br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> tx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (tx &lt;= <span class="hljs-number">0</span> || tx &gt; n || ty &lt;= <span class="hljs-number">0</span> || ty &gt; m || book[tx][ty] ||<br>            space[tx][ty]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        book[tx][ty] = <span class="hljs-number">1</span>;<br>        dfs(tx, ty);<br>        book[tx][ty] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;space[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;start_x, &amp;start_y);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;end_x, &amp;end_y);<br>    book[start_x][start_y] = <span class="hljs-number">1</span>;<br>    dfs(start_x, start_y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考解答-1"><a href="#参考解答-1" class="headerlink" title="参考解答"></a>参考解答</h2><h3 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">map:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">400</span><br><span class="hljs-symbol">dir:</span> <span class="hljs-meta">.space</span> <span class="hljs-number">48</span><br><br><span class="hljs-meta">.macro</span> get_map(%des, %i, %<span class="hljs-keyword">j, </span>%col)<br><span class="hljs-keyword">mult </span>%i, %col<br><span class="hljs-keyword">mflo </span>%des<br><span class="hljs-keyword">add </span> %des, %des, %<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %des, <span class="hljs-number">2</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> get_dir(%des, %i, %<span class="hljs-keyword">j)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %i, <span class="hljs-number">1</span><br><span class="hljs-keyword">add </span> %des, %des, %<span class="hljs-keyword">j</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sll </span> %des, %des, <span class="hljs-number">2</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> push(%src)<br><span class="hljs-keyword">sw </span>  %src, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>.end_macro<br><br><span class="hljs-meta">.macro</span> pop(%des)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>  %des, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br>.end_macro<br><br><span class="hljs-meta">.text</span><br>li   $<span class="hljs-built_in">s6</span>, -<span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">s7</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># const</span><br>li   $<span class="hljs-built_in">t8</span>, <span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">init_dir:</span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s7</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">3</span><br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">0</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">main:</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># n</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># m</span><br><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># i</span><br><span class="hljs-symbol">input1:</span><br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s0</span>, input1_end<br>li   $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span> <span class="hljs-comment"># j</span><br><span class="hljs-symbol">input2:</span><br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s1</span>, input2_end<br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s1</span>)<br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">v0</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   input2<br><span class="hljs-symbol">input2_end:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   input1<br><span class="hljs-symbol">input1_end:</span><br><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># start_x</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># start_y</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s4</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># end_x</span><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">s5</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment"># end_y</span><br>li   $<span class="hljs-built_in">t7</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># result</span><br><br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">s2</span> <span class="hljs-comment"># argument x</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">s3</span> <span class="hljs-comment"># argument y</span><br><br><span class="hljs-keyword">jal </span> dfs<br><br>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t7</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>li   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">dfs:</span><br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">s4</span>, Else<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">s5</span>, Else<br><span class="hljs-symbol">If0:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t7</span>, $<span class="hljs-built_in">t7</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br><span class="hljs-symbol">Else:</span><br><br>li   $<span class="hljs-built_in">t0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># for int i = 0;</span><br><span class="hljs-symbol">loop:</span><br><span class="hljs-keyword">bge </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t8</span>, loop_end<br>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t1</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span>get_dir($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">s7</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t2</span>, <span class="hljs-keyword">dir($t9)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">add </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">a1</span> <span class="hljs-comment">#tx</span><br><span class="hljs-keyword">add </span> $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">a2</span> <span class="hljs-comment">#ty</span><br><br><span class="hljs-keyword">ble </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-number">0</span>, If<br><span class="hljs-keyword">ble </span> $<span class="hljs-built_in">t2</span>, $<span class="hljs-number">0</span>, If<br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">s0</span>, If<br><span class="hljs-keyword">bgt </span> $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>, If<br><br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">lw </span>  $<span class="hljs-built_in">t3</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-keyword">bne </span> $<span class="hljs-built_in">t3</span>, $<span class="hljs-number">0</span>, If<br><br><span class="hljs-comment"># possible</span><br><span class="hljs-keyword">sw </span>  $<span class="hljs-built_in">s6</span>, map($<span class="hljs-built_in">t9</span>)<br>push($<span class="hljs-built_in">ra</span>)<br>push($<span class="hljs-built_in">a2</span>)<br>push($<span class="hljs-built_in">a1</span>)<br>push($<span class="hljs-built_in">t2</span>)<br>push($<span class="hljs-built_in">t1</span>)<br>push($<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">t2</span><br><br><span class="hljs-keyword">jal </span> dfs<br><br>pop($<span class="hljs-built_in">t0</span>)<br>pop($<span class="hljs-built_in">t1</span>)<br>pop($<span class="hljs-built_in">t2</span>)<br>pop($<span class="hljs-built_in">a1</span>)<br>pop($<span class="hljs-built_in">a2</span>)<br>pop($<span class="hljs-built_in">ra</span>)<br>get_map($<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">s1</span>)<br><span class="hljs-keyword">sw </span>  $<span class="hljs-number">0</span>, map($<span class="hljs-built_in">t9</span>)<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">If:</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>   loop<br><span class="hljs-symbol">loop_end:</span><br><span class="hljs-keyword">jr </span>  $<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式总结</title>
    <link href="/2023/10/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/10/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（也称为”元字符”），是一种可以用来描述和匹配字符串的特定模式。</p><p>正则表达式提供了一种灵活且强大的方式来查找、替换、验证和提取文本数据，是一种用于模式匹配和搜索文本的工具。</p><h2 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串<br>可以查找文档内或输入域内特定的文本。</li></ul><p>如果需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p><h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>正则表达式的模式可以包括以下内容：</p><ul><li>字面值字符：例如字母、数字、空格等，可以直接匹配它们自身。</li><li>特殊字符：例如点号 .、星号 *、加号 +、问号 ? 等，它们具有特殊的含义和功能。</li><li>字符类：用方括号 [ ] 包围的字符集合，用于匹配方括号内的任意一个字符。</li><li>元字符：例如 \d、\w、\s 等，用于匹配特定类型的字符，如数字、字母、空白字符等。</li><li>量词：例如 {n}、{n,}、{n,m}等，用于指定匹配的次数或范围。</li><li>边界符号：例如 ^、$、\b、\B 等，用于匹配字符串的开头、结尾或单词边界位置。</li></ul><div class="note note-success">            <p><strong>Example</strong></p><p>我们有这样的一个正则表达式：^ [0-9]+abc$。这是什么意思呢？</p><ul><li><p>^ 为匹配输入字符串的开始位置。</p></li><li><p>[0-9]+匹配多个数字，[0-9]匹配单个数字，+表示匹配一个或者多个。</p></li><li><p>abc匹配字母abc并以abc结尾，$为匹配输入字符串的结束位置。</p></li></ul><p>这个样例让我们直观的感受了一下正则表达式的作用，后面的内容会介绍相关的字符和语法规则。</p>          </div><h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><ul><li>普通字符（字面值字符）：普通字符按照字面意义进行匹配，例如匹配字母 “a” 将匹配到文本中的 “a” 字符。<blockquote><p>(hello world) —- hello world √ Hello world ×<br>(12345) —- 12345 √ 1234×</p></blockquote></li><li>元字符：元字符具有特殊的含义，例如 \d 匹配任意数字字符，\w 匹配任意字母数字字符，. 匹配任意字符（除了换行符）等。</li></ul><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><ul><li>*：匹配前面的模式零次或多次。<blockquote><p>(hel*o world) —– helo world √ hello world √ heo world √<br>(hello world) * —– 空串 √ hello world √ hello worldhello world √</p></blockquote></li><li>+：匹配前面的模式一次或多次。<blockquote><p>(hel+o world) —– helo world √ hello world √ heo world ×<br>(hello world)+ —– 空串 × hello world √ hello worldhello world √</p></blockquote></li><li>?：匹配前面的模式零次或一次。<blockquote><p>(hel?o world) —– helo world √ hello world × heo world √<br>(hello world)? —– 空串 √ hello world √ hello worldhello world ×</p></blockquote></li><li>{n}：匹配前面的模式恰好 n 次。</li><li>{n,}：匹配前面的模式至少 n 次。</li><li>{n,m}：匹配前面的模式至少 n 次且不超过 m 次。<blockquote><p>(hello{3}) —– hellooo √ hello ×<br>(hello{1,}) —– hello √ helloo √<br>(hello{1,3}) —– hello √ helloo √ hellooo √</p></blockquote></li><li>要匹配这些特殊字符本身，需要在其前方加上反斜杠符号。</li></ul><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ul><li>[ ]：匹配括号内的任意一个字符。<br>例如，[abc] 匹配字符 “a”、”b” 或 “c”。</li><li>[^ ]：匹配除了括号内的字符以外的任意一个字符。<br>例如，[^abc] 匹配除了字符 “a”、”b” 或 “c” 以外的任意字符。<blockquote><p>([123]{2}) — 11 √ 12 √ 13 √ 21 √ 22 √ 34 ×</p></blockquote></li></ul><h2 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h2><ul><li>^：匹配字符串的开头。</li><li>$：匹配字符串的结尾。</li><li>\b：匹配单词边界。</li><li>\B：匹配非单词边界。</li><li>\w: 匹配一个字，包括大小写字母，数字和下划线，等价于[0-9a-zA-Z_]。<blockquote><p>\w+ —– a √ 123 √ 2024O_o √</p></blockquote></li><li>\d: 匹配一个数字，等价于[0-9]。<blockquote><p>\d+ —– 1 √ 123 √</p></blockquote></li></ul><h2 id="分组和捕获"><a href="#分组和捕获" class="headerlink" title="分组和捕获"></a>分组和捕获</h2><ul><li>( )：用于分组和捕获子表达式。</li><li>(?: )：用于分组但不捕获子表达式。</li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li>\：转义字符，用于匹配特殊字符本身。</li><li>.：匹配任意字符（除了换行符）。<blockquote><p>(hello.rld) —– hello world × hellowrld √<br>(hello\.world) —– hello.world √ hello world × helloworld ×</p></blockquote></li><li>|：用于指定多个模式的选择。</li></ul><h1 id="修饰符（标记）"><a href="#修饰符（标记）" class="headerlink" title="修饰符（标记）"></a>修饰符（标记）</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><div class="note note-success">            <p><strong>Example</strong></p><p>&#x2F;pattern&#x2F;flags</p>          </div><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore-不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 . 中<br>包含换行符\n</td><td align="left">默认情况下的圆点 . 是匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符\n。</td></tr></tbody></table><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>(), (?:), (?&#x3D;), []</td><td>圆括号和方括号</td></tr><tr><td>*, +, ?, {n}, {n,}, {n,m}</td><td>限定符</td></tr><tr><td>^, $, \任何元字符、任何字符</td><td>定位点和序列（即：位置和顺序）</td></tr><tr><td>|</td><td>替换，”或”操作<br>字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-danger">            <p>这部分内容感觉更像是新的讲解 :)</p>          </div><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td>.</td><td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 “(.|n)”的模式。</td></tr><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘\(‘ 或 ‘\)’。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies)’ 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td>(?&#x3D;pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?&lt;&#x3D;pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。</td></tr><tr><td>x|y</td><td>匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\cx</td><td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td>\xn</td><td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td>\num</td><td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td>\nml</td><td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td>\un</td><td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>菜鸟教程：<a href="https://www.runoob.com/regexp/regexp-tutorial.html">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>]]></content>
    
    
    <categories>
      
      <category>面向对象程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>coPre测试题目与解析</title>
    <link href="/2023/09/27/coPre%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/09/27/coPre%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>Pre共有三道题，分别考察了MIPS、Verilog和Logisim，考试时间2小时。<br>以下试题内容均为回忆版，还请见谅。</p>          </div><h1 id="第一题：supaltitude"><a href="#第一题：supaltitude" class="headerlink" title="第一题：supaltitude"></a>第一题：supaltitude</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>阿庄哥（随便起的名字）从某处开始沿着山路骑车。设起点的相对海拔为$0$，从起点到终点一共经过了$n$个记录点，给出该记录点与前一个记录点的相对海拔差，输出整个过程中所处的最高相对海拔值。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul><li>一个正整数$n$，表示从起点开始总共经过的记录点的个数；</li><li>一个数组$a[n]$，其中$a[i]$表示第$i$个记录点相对于第$i-1$个检查点的相对海拔差；</li><li>输入数据保证$0 \le n \le 128$, $-128 \le a[i] \le 128$。</li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li>一个整数，表示整个过程中所处的最高相对海拔值。</li></ul><h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">7<br>3<br>-1<br>-4<br>1<br>5<br>-3<br>1<br></code></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h3><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">6<br>-4<br>-3<br>-2<br>-1<br>4<br>4<br></code></pre></td></tr></table></figure><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先需要考虑的是，需不需要开辟数组空间？</p><p>题目的本质是想要我们求<strong>连续子数组的最大和</strong>，所以其实只需要每次读入一个数，更新当前的前缀和，并与最大前缀和对比即可，并不需要开辟数组空间。</p><div class="note note-info">            <p>前缀和：从nums数组第0个数开始累加，到第$i$个位置的累加结果。</p>          </div><p>清楚题意之后，我们可以尝试写出以下c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, n, a;<br>    <span class="hljs-comment">// max是最大前缀和，sum是当前前缀和</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>        sum += a;<br>        <span class="hljs-keyword">if</span>(max &lt; sum)<br>            max = sum;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, max);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在Pre的MIPS汇编程序设计中已经学习了条件语句和循环语句的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text<br>li $t1, 100             #t1 = 100<br>li $t2, 200             #t2 = 200<br>slt $t3, $t1, $t2       #if(t1 &lt; t2) t3 = 1 <br>beq $t3, $0, if_1_else<br>nop<br>#do something<br>j if_1_end              #jump to end<br>nop<br>if_1_else:<br>#do something else<br><br>if_1_end:<br>li $v0, 10<br>syscall<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text<br>li $t1, 100             #n = 100<br>li $t2, 0               #i<br><br>for_begin1:             #for (int i = 0; i &lt; n; i++)<br>slt $t3, $t2, $t1       #&#123;<br>beq $t3, $0, for_end1  <br>nop      <br>#do something<br>addi $t2, $t2, 1        #i++<br>j for_begin1<br>nop                     #&#125;  <br><br>for_end1:<br>li $v0, 10<br>syscall<br><br></code></pre></td></tr></table></figure><p>基于以上分析与所学知识，我们便可以完成所需的MIPS程序。</p><blockquote><p>提示： </p><ul><li>对于MIPS程序设计题，先写出可解决该问题的C语言程序代码，再逐句“翻译”成对应的MIPS指令，是一种值得尝试的选择；</li><li>编写MIPS代码时可以添加一些空格、缩进、标签、注释等，增强代码的可读性。</li></ul></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">main:<br>li   $v0, 5<br>syscall<br>move $s0, $v0 #n = $v0 = $s0<br>li   $s1, 0   #max = 0<br>li   $s2, 0   #sum = 0<br>li   $t0, 0   #i = 0<br>for_loop:<br>beq  $t0, $s0, for_loop_end<br>li   $v0, 5<br>syscall<br>move $t1, $v0<br>add  $s2, $s2, $t1<br>ble  $s2, $s1, else<br>if:<br>move $s1, $s2<br>else:<br>addi $t0, $t0, 1<br>j    for_loop<br><br>for_loop_end:<br>move $a0, $s1<br>li   $v0, 1<br>syscall<br>li   $v0, 10<br>syscall<br></code></pre></td></tr></table></figure><h1 id="第二题：noDescendSequence"><a href="#第二题：noDescendSequence" class="headerlink" title="第二题：noDescendSequence"></a>第二题：noDescendSequence</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>“不下降数”表示一个整数的高位数码不会大于低位数码。例如，$1234$、$1223$是“不下降数”，而$1243$不是“不下降数”。</p><p>使用Verilog构建一个判断一个4位16进制数输入是否为“不下降数”的电路。</p><p>端口定义如下：</p><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>in[15:0]</td><td>I</td><td>接受带判断的数字</td></tr><tr><td>out</td><td>O</td><td>如果是“不下降数”，返回1；<br>否则，返回0</td></tr></tbody></table><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这道题很简单，只需要把in的四个数码分别比较即可。</p><blockquote><p>在完成模块的设计后，最好使用testbench进行测试。</p></blockquote><h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> noDescendSequence(<br><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in,<br><span class="hljs-keyword">output</span> out<br>);<br><span class="hljs-keyword">assign</span> out = (in[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>] &lt;= in[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>] &amp;&amp; in[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>] &lt;= in[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>] <br>&amp;&amp; in[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>] &lt;= in[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h1 id="第三题：tetris"><a href="#第三题：tetris" class="headerlink" title="第三题：tetris"></a>第三题：tetris</h1><p>忘了题目了，好像是Mealy型自动机，大家全面准备吧:)</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>试题</tag>
      
      <tag>解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
